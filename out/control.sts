'# This file is encoded in ASCII# line delimitor is CR.SmallSchemeSmallScheme code for Squeak 3.0Translated from file /usr/local/src/Squeak/ProtoScheme/scm/control.scm'!!SmallScheme class methodsFor: 'initialization'!initControl SmallScheme define:  #'procedureX3F'    "procedure?"  as: (        [ :obj |  ( obj isKindOf: BlockClosure)] ) . SmallScheme define:  #'apply'  as: (        [ :proc :args |            args := args asRest.            [ :key20 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key20) value: ( ({ 00. } asRest)))) == false) not)                   	ifTrue: [(proc value)]                   	ifFalse: [ [ :key21 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key21) value: ( ({ 1. } asRest)))) == false) not)                           	ifTrue: [ [ :arg |                                 ((( ( arg == nil)) == false) not)                                   	ifTrue: [(proc value)]                                   	ifFalse: [ ( proc valueWithArguments: ( arg asArray))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'car')                                    value: ( args))). }]                           	ifFalse: [ [                              key21.                                                          [ :lp |                                [ :arglist |                                   [                                    (((((SmallScheme globalRef:  #'not')                                            value: (((SmallScheme globalRef:  #'listX3F')                                            value: ( arglist))))) == false) not)                                       	ifTrue: [((SmallScheme globalRef:  #'error')                                            value: ( 'APPLY requires a list as the last argument') value: ( args))].                                   ((SmallScheme globalRef:  #'setX2DcdrX21')                                        value: ( lp) value: (((SmallScheme globalRef:  #'cdr')                                        value: ( arglist)))).                                   ((SmallScheme globalRef:  #'setX2DcarX21')                                        value: ( lp) value: (((SmallScheme globalRef:  #'car')                                        value: ( arglist)))).                                    ( proc valueWithArguments: ( args asArray)).                                  ] value                               ] value: (((SmallScheme globalRef:  #'car')                                    value: ( lp)))                             ] value: (((SmallScheme globalRef:  #'lastX2Dpair')                                  value: ( args))).                            ] value].                   ] valueWithArguments: {( key20). }].           ] valueWithArguments: {(((SmallScheme globalRef:  #'length')                    value: ( args))). }] withLastArgRest  ) . SmallScheme define:  #'map'  as: (        [ :fn :list |            list := list asRest.            (((((SmallScheme globalRef:  #'nullX3F')                    value: (((SmallScheme globalRef:  #'car')                    value: ( list))))) == false) not)               	ifTrue: [ nil]               	ifFalse: [ (((((SmallScheme globalRef:  #'pairX3F')                        value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'cons')                        value: (((SmallScheme globalRef:  #'apply')                        value: ( fn) value: ( ( list collect: (SmallScheme globalRef:  #'car')                       )))) value: (((SmallScheme globalRef:  #'apply')                        value: ( (SmallScheme globalRef:  #'map')                       ) value: ( fn) value: ( ( list collect: (SmallScheme globalRef:  #'cdr')                       )))))]                   	ifFalse: [((SmallScheme globalRef:  #'apply')                        value: ( fn) value: ( list))]]] withLastArgRest  ) . SmallScheme define:  #'any'  as: (        [ :pred :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ false]               	ifFalse: [ ((((pred value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'car')                        value: ( list))]                   	ifFalse: [((SmallScheme globalRef:  #'any')                        value: ( pred) value: (((SmallScheme globalRef:  #'cdr')                        value: ( list))))]]] ) . SmallScheme define:  #'forX2Deach'    "for-each"  as: (        [ :proc :first :rest |            rest := rest asRest.            (((((SmallScheme globalRef:  #'nullX3F')                    value: ( rest))) == false) not)               	ifTrue: [ (((((SmallScheme globalRef:  #'not')                        value: (((SmallScheme globalRef:  #'nullX3F')                        value: ( first))))) == false) not)                   	ifTrue: [ ( first do: proc)]]               	ifFalse: [                [ | loop |                    loop :=                    [ :lists |                     (((((SmallScheme globalRef:  #'not')                            value: (((SmallScheme globalRef:  #'any')                            value: ( (SmallScheme globalRef:  #'nullX3F')                           ) value: ( lists))))) == false) not)                       	ifTrue: [ [                         ((SmallScheme globalRef:  #'apply')                              value: ( proc) value: ( ( (SmallScheme globalRef:  #'list')                              collect: (SmallScheme globalRef:  #'car')                             ))).                         (loop value: ( proc) value: ( ( (SmallScheme globalRef:  #'list')                              collect: (SmallScheme globalRef:  #'cdr')                             ))).                        ] value]               ].               loop valueWithArguments: {                   ((SmallScheme globalRef:  #'cons')                        value: ( first) value: ( rest)). } ] value]] withLastArgRest  ) . SmallScheme define:  #'makeX2Dpromise'    "make-promise"  as: (        [ :thunk |  [ :forcedX3F :result |                               [ ((( forcedX3F) == false) not)                       	ifTrue: [ result]                       	ifFalse: [ [ :whatever |                             ((( forcedX3F) == false) not)                               	ifTrue: [ result]                               	ifFalse: [ [                                 (result :=  whatever).                                 (forcedX3F :=  true).                                 (thunk :=  false).                                  result.                                ] value].                       ] valueWithArguments: {((thunk value)). }]].           ] valueWithArguments: {( false). ( false). }] ) . SmallScheme define:  #'force'  as: (        [ :promise | (promise value)] ) . SmallScheme define:  #'callX2DwithX2Dvalues'    "call-with-values"  as: (        [ :producer :consumer |  ( consumer valueWithArguments:(producer value))] ) . SmallScheme define:  #'dynamicX2Dwind'    "dynamic-wind"  as: (        [ :before :thunk :after |  (           [ [                 (before value).                 (thunk value).                ] value] ensure:           [(after value)])] ) .! !