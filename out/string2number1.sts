'# This file is encoded in ASCII# line delimitor is CR.SmallSchemeSmallScheme code for Squeak 3.0Translated from file /usr/local/src/Squeak/ProtoScheme/scm/string2number1.scm'!!SmallScheme class methodsFor: 'initialization'!initString2number1 SmallScheme define:  #'numX2D2X2Dchars'    "num-2-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( '01')) ) . SmallScheme define:  #'numX2D8X2Dchars'    "num-8-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( '01234567')) ) . SmallScheme define:  #'numX2D10X2Dchars'    "num-10-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( '0123456789')) ) . SmallScheme define:  #'numX2D16X2Dchars'    "num-16-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( '0123456789abcdefABCDEF')) ) . SmallScheme define:  #'exponentX2DmarkerX2Dchars'    "exponent-marker-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( 'esfdlESFDL')) ) . SmallScheme define:  #'radixX2Dchars'    "radix-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( 'bodxBODX')) ) . SmallScheme define:  #'exactnessX2Dchars'    "exactness-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( 'ieIE')) ) . SmallScheme define:  #'signX2Dchars'    "sign-chars"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( '+-')) ) . SmallScheme define:  #'radixX2Dtable'    "radix-table"  as: (  ({ (Pair car:  $b cdr:  2).  (Pair car:  $o cdr:  8).  (Pair car:  $d cdr:  10).  (Pair car:  $x cdr:  16).  (Pair car:  $B cdr:  2).  (Pair car:  $O cdr:  8).  (Pair car:  $D cdr:  10).  (Pair car:  $X cdr:  16). } asRest) ) . SmallScheme define:  #'charX2DX3Eradix'    "char->radix"  as: (        [ :char |  [ :result19 |                 ((( result19) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'cdr')                        value: ( result19))]                   	ifFalse: [ false].           ] valueWithArguments: {(((SmallScheme globalRef:  #'assq')                    value: ( char) value: ( (SmallScheme globalRef:  #'radixX2Dtable')                   ))). }] ) . SmallScheme define:  #'stringX2Dupcase'    "string-upcase"  as: (        [ :str | ((SmallScheme globalRef:  #'listX2DX3Estring')                value: (((SmallScheme globalRef:  #'map')                value: ( (SmallScheme globalRef:  #'charX2Dupcase')               ) value: (((SmallScheme globalRef:  #'stringX2DX3Elist')                value: ( str))))))] ) . SmallScheme define:  #'toX2DssX2Dint'    "to-ss-int"  as: (        [ :intX2Dstr :radix | ((SmallScheme globalRef:  #'stringX2Dappend')                value: ( [ :key20 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key20) value: ( ({ 2. } asRest)))) == false) not)                   	ifTrue: [ '2r']                   	ifFalse: [ [ :key21 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key21) value: ( ({ 8. } asRest)))) == false) not)                           	ifTrue: [ '8r']                           	ifFalse: [ [ :key22 |                                 (((((SmallScheme globalRef:  #'memv')                                        value: ( key22) value: ( ({ 16. } asRest)))) == false) not)                                   	ifTrue: [ '16r']                                   	ifFalse: [ [                                      key22.                                      ''.                                    ] value].                           ] valueWithArguments: {( key21). }].                   ] valueWithArguments: {( key20). }].           ] valueWithArguments: {( radix). }) value: (((SmallScheme globalRef:  #'stringX2Dupcase')                value: ( intX2Dstr))))] ) . SmallScheme define:  #'toX2DssX2Dfloat'    "to-ss-float"  as: (        [ :signX2Dchar :intX2Dstr :fracX2Dstr :exptX2DsignX2Dchar :exptX2Dstr |            [ :int |              [ :frac |                [ :sign |                  [ :exptX2Dsign |                    [ :expt |                       ((( (((((SmallScheme globalRef:  #'zeroX3F')                                  value: (((SmallScheme globalRef:  #'stringX2Dlength')                                  value: ( intX2Dstr))))) == false) not)                             	ifTrue: [((SmallScheme globalRef:  #'zeroX3F')                                  value: (((SmallScheme globalRef:  #'stringX2Dlength')                                  value: ( fracX2Dstr))))]                             	ifFalse: [ false]) == false) not)                         	ifTrue: [ false]                         	ifFalse: [((SmallScheme globalRef:  #'stringX2Dappend')                                                       valueWithArguments: {  sign.  int.  '.'.  frac.  expt.})]                   ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                            value: (((SmallScheme globalRef:  #'stringX2Dlength')                            value: ( exptX2Dstr))))) == false) not)                       	ifTrue: [ '']                       	ifFalse: [((SmallScheme globalRef:  #'stringX2Dappend')                            value: ( 'e') value: ( exptX2Dsign) value: ( exptX2Dstr))])                 ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( exptX2DsignX2Dchar) value: ( $-))) == false) not)                     	ifTrue: [ '-']                     	ifFalse: [ ''])               ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                        value: ( signX2Dchar) value: ( $-))) == false) not)                   	ifTrue: [ '-']                   	ifFalse: [ ''])             ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                      value: (((SmallScheme globalRef:  #'stringX2Dlength')                      value: ( fracX2Dstr))))) == false) not)                 	ifTrue: [ '0']                 	ifFalse: [ fracX2Dstr])           ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                    value: (((SmallScheme globalRef:  #'stringX2Dlength')                    value: ( intX2Dstr))))) == false) not)               	ifTrue: [ '0']               	ifFalse: [ intX2Dstr])] ) . SmallScheme define:  #'coerceX2DifX2Dneeded'    "coerce-if-needed"  as: (        [ :num :exactX3F :makeX2DinexactX3F |  [ :key23 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key23) value: ( ({ $e. } asRest)))) == false) not)                   	ifTrue: [ ((( exactX3F) == false) not)                       	ifTrue: [ num]                       	ifFalse: [((SmallScheme globalRef:  #'inexactX2DX3Eexact')                            value: ( num))]]                   	ifFalse: [ [ :key24 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key24) value: ( ({ $i. } asRest)))) == false) not)                           	ifTrue: [ ((( exactX3F) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'exactX2DX3Einexact')                                    value: ( num))]                               	ifFalse: [ num]]                           	ifFalse: [ [                              key24.                              num.                            ] value].                   ] valueWithArguments: {( key23). }].           ] valueWithArguments: {( makeX2DinexactX3F). }] ) . SmallScheme define:  #'makeX2Dinteger'    "make-integer"  as: (        [ :sign :str :radix :exactX3F :makeX2DinexactX3F |  [ :num |                ((SmallScheme globalRef:  #'coerceX2DifX2Dneeded')                    value: ( (((((SmallScheme globalRef:  #'eqX3F')                        value: ( sign) value: ( $-))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'X2D')                        value: ( 00) value: ( num))]                   	ifFalse: [ num]) value: ( exactX3F) value: ( makeX2DinexactX3F)).           ] valueWithArguments: {( (((SmallScheme globalRef:  #'toX2DssX2Dint')                    value: ( str) value: ( radix)) asNumber)). }] ) . SmallScheme define:  #'makeX2Ddecimal'    "make-decimal"  as: (        [ :sign :intX2Dpart :fracX2Dpart :expX2Dsign :exponentX2Dpart :exactX3F :makeX2DinexactX3F |  [ :num |                ((SmallScheme globalRef:  #'coerceX2DifX2Dneeded')                    value: ( num) value: ( exactX3F) value: ( makeX2DinexactX3F)).           ] valueWithArguments: {( (((SmallScheme globalRef:  #'toX2DssX2Dfloat')                                   valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign.  exponentX2Dpart.}) asNumber)). }] ) . SmallScheme define:  #'makeX2Drational'    "make-rational"  as: (        [ :sign :numerator :denominator :radix :exactX3F :makeX2DinexactX3F |            [ :numX2Dpart |              [ :denomX2Dpart |                [ :num |                  ((SmallScheme globalRef:  #'coerceX2DifX2Dneeded')                      value: ( num) value: ( exactX3F) value: ( makeX2DinexactX3F))               ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                        value: ( sign) value: ( $-))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'X2D')                        value: (((SmallScheme globalRef:  #'X2F')                        value: ( numX2Dpart) value: ( denomX2Dpart))))]                   	ifFalse: [((SmallScheme globalRef:  #'X2F')                        value: ( numX2Dpart) value: ( denomX2Dpart))])             ] value: ( (((SmallScheme globalRef:  #'toX2DssX2Dint')                  value: ( denominator) value: ( radix)) asNumber))           ] value: ( (((SmallScheme globalRef:  #'toX2DssX2Dint')                value: ( numerator) value: ( radix)) asNumber))] ) . SmallScheme define:  #'makeX2Dcomplex'    "make-complex"  as: (        [ :realX2Dpart :imaginativeX2Dpart :exactX3F :makeX2DinexactX3F | ((SmallScheme globalRef:  #'coerceX2DifX2Dneeded')                value: ( ( Complex real: realX2Dpart imaginary: imaginativeX2Dpart)) value: ( exactX3F) value: ( makeX2DinexactX3F))] ) . SmallScheme define:  #'prefix'  as: (        [ :str :idx :sign :radix :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                    value: ( idx) value: (((SmallScheme globalRef:  #'stringX2Dlength')                    value: ( str))))) == false) not)               	ifTrue: [ false]               	ifFalse: [ [ :char |                     (((((SmallScheme globalRef:  #'memv')                            value: ( char) value: ( (SmallScheme globalRef:  #'numX2D16X2Dchars')                           ))) == false) not)                       	ifTrue: [ [ :key25 |                             (((((SmallScheme globalRef:  #'memv')                                    value: ( key25) value: ( ({ 10. } asRest)))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'integer')                                                                   valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                    value: ( str)).  (SmallScheme globalRef:  #'numX2D10X2Dchars')                                   .  sign.  10.  nil.  true.  makeX2DinexactX3F.})]                               	ifFalse: [ [ :key26 |                                     (((((SmallScheme globalRef:  #'memv')                                            value: ( key26) value: ( ({ 2. } asRest)))) == false) not)                                       	ifTrue: [((SmallScheme globalRef:  #'integer')                                                                                   valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                            value: ( str)).  (SmallScheme globalRef:  #'numX2D2X2Dchars')                                           .  sign.  2.  nil.  true.  makeX2DinexactX3F.})]                                       	ifFalse: [ [ :key27 |                                             (((((SmallScheme globalRef:  #'memv')                                                    value: ( key27) value: ( ({ 8. } asRest)))) == false) not)                                               	ifTrue: [((SmallScheme globalRef:  #'integer')                                                                                                   valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                                    value: ( str)).  (SmallScheme globalRef:  #'numX2D8X2Dchars')                                                   .  sign.  8.  nil.  true.  makeX2DinexactX3F.})]                                               	ifFalse: [ [ :key28 |                                                     (((((SmallScheme globalRef:  #'memv')                                                            value: ( key28) value: ( ({ 16. } asRest)))) == false) not)                                                       	ifTrue: [((SmallScheme globalRef:  #'integer')                                                                                                                   valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                                            value: ( str)).  (SmallScheme globalRef:  #'numX2D16X2Dchars')                                                           .  sign.  16.  nil.  true.  makeX2DinexactX3F.})]                                                       	ifFalse: [ [                                                          key28.                                                          false.                                                        ] value].                                               ] valueWithArguments: {( key27). }].                                       ] valueWithArguments: {( key26). }].                               ] valueWithArguments: {( key25). }].                       ] valueWithArguments: {( radix). }]                       	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                value: ( char) value: ( $.))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'decimal')                                                           valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                value: ( 1) value: ( idx)). ((SmallScheme globalRef:  #'stringX2Dlength')                                value: ( str)).  $+.  '0'.  nil.  true.  makeX2DinexactX3F.})]                           	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                    value: ( char) value: ( (SmallScheme globalRef:  #'signX2Dchars')                                   ))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'prefix')                                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                    value: ( 1) value: ( idx)).  char.  radix.  makeX2DinexactX3F.})]                               	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                        value: ( char) value: ( $#))) == false) not)                                   	ifTrue: [ [ :char2 |                                         (((((SmallScheme globalRef:  #'memv')                                                value: ( char2) value: ( (SmallScheme globalRef:  #'radixX2Dchars')                                               ))) == false) not)                                           	ifTrue: [((SmallScheme globalRef:  #'prefix')                                                                                           valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                value: ( 2) value: ( idx)).  sign. ((SmallScheme globalRef:  #'charX2DX3Eradix')                                                value: ( char2)).  makeX2DinexactX3F.})]                                           	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                    value: ( char2) value: ( (SmallScheme globalRef:  #'exactnessX2Dchars')                                                   ))) == false) not)                                               	ifTrue: [((SmallScheme globalRef:  #'prefix')                                                                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                    value: ( 2) value: ( idx)).  sign.  radix.  char2.})]                                               	ifFalse: [ false]].                                   ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                                            value: ( str) value: (((SmallScheme globalRef:  #'X2B')                                            value: ( 1) value: ( idx))))). }]                                   	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                            value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                            value: ( char))) value: ( $i))) == false) not)                                       	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                value: (((SmallScheme globalRef:  #'X2B')                                                value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                value: ( str))))) == false) not)                                           	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                    value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                    value: ( str))))) == false) not)                                               	ifTrue: [ false]                                               	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                        value: ( sign))) == false) not)                                                   	ifTrue: [ false]                                                   	ifFalse: [((SmallScheme globalRef:  #'makeX2Dcomplex')                                                                                                           valueWithArguments: {  00.  00.  (SmallScheme globalRef:  #'exactX3F')                                                       .  makeX2DinexactX3F.})]]]                                           	ifFalse: [ false]]                                       	ifFalse: [ false]]]]].               ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                        value: ( str) value: ( idx))). }]] ) . SmallScheme define:  #'integer'  as: (        [ :str :idx :len :legalX2Dchars :sign :radix :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                    value: ( idx) value: ( len))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'makeX2Dinteger')                                   valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                    value: (((SmallScheme globalRef:  #'reverse')                    value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.})]               	ifFalse: [ [ :char |                     (((((SmallScheme globalRef:  #'memv')                            value: (((SmallScheme globalRef:  #'stringX2Dref')                            value: ( str) value: ( idx))) value: ( legalX2Dchars))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'integer')                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                            value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'cons')                            value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                       	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                value: ( char) value: ( $#))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'integer')                                                           valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'cons')                                value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                           	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                    value: ( char) value: ( $.))) == false) not)                               	ifTrue: [ ((( ((( radix) == false) not)                                       	ifTrue: [((SmallScheme globalRef:  #'X3D')                                            value: ( radix) value: ( 10))]                                       	ifFalse: [ false]) == false) not)                                   	ifTrue: [((SmallScheme globalRef:  #'decimal')                                                                           valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                        value: ( 1) value: ( idx)).  len.  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                        value: (((SmallScheme globalRef:  #'reverse')                                        value: ( digits)))).  nil.  exactX3F.  makeX2DinexactX3F.})]                                   	ifFalse: [ false]]                               	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                        value: ( char) value: ( $/))) == false) not)                                   	ifTrue: [((SmallScheme globalRef:  #'rational')                                                                           valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                        value: ( 1) value: ( idx)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'listX2DX3Estring')                                        value: (((SmallScheme globalRef:  #'reverse')                                        value: ( digits)))).  nil.  exactX3F.  makeX2DinexactX3F.})]                                   	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                            value: ( char) value: ( (SmallScheme globalRef:  #'signX2Dchars')                                           ))) == false) not)                                       	ifTrue: [ (((((SmallScheme globalRef:  #'nullX3F')                                                value: ( digits))) == false) not)                                           	ifTrue: [((SmallScheme globalRef:  #'complex')                                                                                           valueWithArguments: {  00.  str.  idx.  radix.})]                                           	ifFalse: [((SmallScheme globalRef:  #'complex')                                                                                           valueWithArguments: { ((SmallScheme globalRef:  #'makeX2Dinteger')                                                                                           valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                value: (((SmallScheme globalRef:  #'reverse')                                                value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  radix.})]]                                       	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                                value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                                value: ( char))) value: ( $i))) == false) not)                                           	ifTrue: [ (((((SmallScheme globalRef:  #'not')                                                    value: (((SmallScheme globalRef:  #'X3D')                                                    value: (((SmallScheme globalRef:  #'X2B')                                                    value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                    value: ( str))))))) == false) not)                                               	ifTrue: [ false]                                               	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                                        value: ( digits))) == false) not)                                                   	ifTrue: [((SmallScheme globalRef:  #'makeX2Dcomplex')                                                                                                           valueWithArguments: {  00.  00.  exactX3F.  makeX2DinexactX3F.})]                                                   	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                            value: ( sign))) == false) not)                                                       	ifTrue: [ false]                                                       	ifFalse: [((SmallScheme globalRef:  #'makeX2Dcomplex')                                                                                                                   valueWithArguments: {  00. ((SmallScheme globalRef:  #'makeX2Dinteger')                                                                                                                   valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                            value: (((SmallScheme globalRef:  #'reverse')                                                            value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]]]                                           	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                    value: ( char) value: ( (SmallScheme globalRef:  #'exponentX2DmarkerX2Dchars')                                                   ))) == false) not)                                               	ifTrue: [ ((( ((( radix) == false) not)                                                       	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                                value: ( radix) value: ( 10))) == false) not)                                                           	ifTrue: [((SmallScheme globalRef:  #'X3E')                                                                value: (((SmallScheme globalRef:  #'length')                                                                value: ( digits))) value: ( 00))]                                                           	ifFalse: [ false]]                                                       	ifFalse: [ false]) == false) not)                                                   	ifTrue: [((SmallScheme globalRef:  #'exponent')                                                                                                           valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                        value: ( 1) value: ( idx)).  len.  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                        value: (((SmallScheme globalRef:  #'reverse')                                                        value: ( digits)))).  '0'.  nil.  $+.  exactX3F.  makeX2DinexactX3F.})]                                                   	ifFalse: [ false]]                                               	ifFalse: [ false]]]]]]].               ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                        value: ( str) value: ( idx))). }]] ) . SmallScheme define:  #'rational'  as: (        [ :str :idx :len :legalX2Dchars :sign :radix :numerator :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                    value: ( idx) value: ( len))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'makeX2Drational')                                   valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                    value: (((SmallScheme globalRef:  #'reverse')                    value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.})]               	ifFalse: [ [ :char |                     (((((SmallScheme globalRef:  #'memv')                            value: (((SmallScheme globalRef:  #'stringX2Dref')                            value: ( str) value: ( idx))) value: ( legalX2Dchars))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'rational')                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                            value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix.  numerator. ((SmallScheme globalRef:  #'cons')                            value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                       	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                value: ( char) value: ( (SmallScheme globalRef:  #'signX2Dchars')                               ))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'complex')                                                           valueWithArguments: { ((SmallScheme globalRef:  #'makeX2Drational')                                                           valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                                value: (((SmallScheme globalRef:  #'reverse')                                value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  radix.})]                           	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                    value: ( char) value: ( $#))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'rational')                                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                    value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix.  numerator. ((SmallScheme globalRef:  #'cons')                                    value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                               	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                        value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                        value: ( char))) value: ( $i))) == false) not)                                   	ifTrue: [ (((((SmallScheme globalRef:  #'not')                                            value: (((SmallScheme globalRef:  #'X3D')                                            value: (((SmallScheme globalRef:  #'X2B')                                            value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                            value: ( str))))))) == false) not)                                       	ifTrue: [ false]                                       	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                                value: ( digits))) == false) not)                                           	ifTrue: [ false]                                           	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                    value: ( sign))) == false) not)                                               	ifTrue: [ false]                                               	ifFalse: [((SmallScheme globalRef:  #'makeX2Dcomplex')                                                                                                   valueWithArguments: {  00. ((SmallScheme globalRef:  #'makeX2Drational')                                                                                                   valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                    value: (((SmallScheme globalRef:  #'reverse')                                                    value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]]]                                   	ifFalse: [ false]]]].               ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                        value: ( str) value: ( idx))). }]] ) . SmallScheme define:  #'decimal'  as: (        [ :str :idx :len :sign :intX2Dpart :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                    value: ( idx) value: ( len))) == false) not)               	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                        value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                        value: ( str))))) == false) not)                   	ifTrue: [ false]                   	ifFalse: [((SmallScheme globalRef:  #'makeX2Ddecimal')                                           valueWithArguments: {  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                        value: (((SmallScheme globalRef:  #'reverse')                        value: ( digits)))).  $+.  '0'.  exactX3F.  makeX2DinexactX3F.})]]               	ifFalse: [ [ :char |                     (((((SmallScheme globalRef:  #'memv')                            value: (((SmallScheme globalRef:  #'stringX2Dref')                            value: ( str) value: ( idx))) value: ( (SmallScheme globalRef:  #'numX2D10X2Dchars')                           ))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'decimal')                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                            value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'cons')                            value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                       	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                value: ( char) value: ( $#))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'decimal')                                                           valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'cons')                                value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                           	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                    value: ( char) value: ( (SmallScheme globalRef:  #'exponentX2DmarkerX2Dchars')                                   ))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'exponent')                                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                    value: ( 1) value: ( idx)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                                    value: (((SmallScheme globalRef:  #'reverse')                                    value: ( digits)))).  nil.  $+.  exactX3F.  makeX2DinexactX3F.})]                               	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                        value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                        value: ( char))) value: ( $i))) == false) not)                                   	ifTrue: [ ((( ((( sign) == false) not)                                           	ifTrue: [((SmallScheme globalRef:  #'X3D')                                                value: (((SmallScheme globalRef:  #'X2B')                                                value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                value: ( str))))]                                           	ifFalse: [ false]) == false) not)                                       	ifTrue: [((SmallScheme globalRef:  #'makeX2Dcomplex')                                                                                   valueWithArguments: {  00. ((SmallScheme globalRef:  #'makeX2Ddecimal')                                                                                   valueWithArguments: {  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                                            value: (((SmallScheme globalRef:  #'reverse')                                            value: ( digits)))).  $+.  '0'.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]                                       	ifFalse: [ false]]                                   	ifFalse: [ false]]]].               ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                        value: ( str) value: ( idx))). }]] ) . SmallScheme define:  #'exponent'  as: (        [ :str :idx :len :sign :intX2Dpart :fracX2Dpart :digits :expX2Dsign :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                    value: ( idx) value: ( len))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'makeX2Ddecimal')                                   valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                    value: (((SmallScheme globalRef:  #'reverse')                    value: ( digits)))).  exactX3F.  makeX2DinexactX3F.})]               	ifFalse: [ [ :char |                     (((((SmallScheme globalRef:  #'memv')                            value: ( char) value: ( (SmallScheme globalRef:  #'numX2D10X2Dchars')                           ))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'exponent')                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                            value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart.  fracX2Dpart. ((SmallScheme globalRef:  #'cons')                            value: ( char) value: ( digits)).  expX2Dsign.  exactX3F.  makeX2DinexactX3F.})]                       	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                value: ( char) value: ( (SmallScheme globalRef:  #'signX2Dchars')                               ))) == false) not)                           	ifTrue: [ (((((SmallScheme globalRef:  #'nullX3F')                                    value: ( digits))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'exponent')                                                                   valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                    value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart.  fracX2Dpart.  digits.  char.  exactX3F.  makeX2DinexactX3F.})]                               	ifFalse: [((SmallScheme globalRef:  #'complex')                                                                   valueWithArguments: { ((SmallScheme globalRef:  #'makeX2Ddecimal')                                                                   valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                    value: (((SmallScheme globalRef:  #'reverse')                                    value: ( digits)))).  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  (SmallScheme globalRef:  #'radix')                                   .})]]                           	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                    value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                    value: ( char))) value: ( $i))) == false) not)                               	ifTrue: [ ((( [ :temp29 |                                         ((( temp29) == false) not)                                           	ifTrue: [ temp29]                                           	ifFalse: [ [ :temp30 |                                                 ((( temp30) == false) not)                                                   	ifTrue: [ temp30]                                                   	ifFalse: [((SmallScheme globalRef:  #'not')                                                        value: (((SmallScheme globalRef:  #'X3D')                                                        value: (((SmallScheme globalRef:  #'X2B')                                                        value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                        value: ( str))))))].                                           ] valueWithArguments: {(((SmallScheme globalRef:  #'not')                                                    value: ( sign))). }].                                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                                            value: ( digits))). }) == false) not)                                   	ifTrue: [ false]                                   	ifFalse: [((SmallScheme globalRef:  #'makeX2Dcomplex')                                                                           valueWithArguments: {  00. ((SmallScheme globalRef:  #'makeX2Ddecimal')                                                                           valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                        value: (((SmallScheme globalRef:  #'reverse')                                        value: ( digits)))).  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]                               	ifFalse: [ false]]].               ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                        value: ( str) value: ( idx))). }]] ) . SmallScheme define:  #'complex'  as: (        [ :realX2Dpart :str :idx :radix |  [ :imaginitiveX2Dpart |                 ((( imaginitiveX2Dpart) == false) not)                   	ifTrue: [ ( realX2Dpart + imaginitiveX2Dpart)]                   	ifFalse: [ false].           ] valueWithArguments: {(((SmallScheme globalRef:  #'prefix')                                   valueWithArguments: {  str.  idx.  $+.  radix.  false.})). }] ) . SmallScheme define:  #'stringX2DX3Enumber'    "string->number"  as: (        [ :str :radix |            radix := radix asRest.            [              (((((SmallScheme globalRef:  #'not')                      value: (((SmallScheme globalRef:  #'stringX3F')                      value: ( str))))) == false) not)                 	ifTrue: [((SmallScheme globalRef:  #'error')                      value: ( 'Expected a string') value: ( str))].              (((((SmallScheme globalRef:  #'X3C')                      value: (((SmallScheme globalRef:  #'stringX2Dlength')                      value: ( str))) value: ( 1))) == false) not)                 	ifTrue: [ false]                 	ifFalse: [((SmallScheme globalRef:  #'prefix')                                       valueWithArguments: {  str.  00.  false.  (((((SmallScheme globalRef:  #'nullX3F')                          value: ( radix))) == false) not)                     	ifTrue: [ 10]                     	ifFalse: [((SmallScheme globalRef:  #'car')                          value: ( radix))].  false.})].            ] value] withLastArgRest  ) .! !