'# This file is encoded in ASCII# line delimitor is CR.SmallSchemeSmallScheme code for Squeak 3.0Translated from file /usr/local/src/Squeak/ProtoScheme/scm/read.scm'!!SmallScheme class methodsFor: 'initialization'!initRead SmallScheme define:  #'whitespace'  as: (  ({ $ . (Character cr). } asRest) ) . SmallScheme define:  #'delimiters'  as: ( ((SmallScheme globalRef:  #'append')            value: (((SmallScheme globalRef:  #'list')                   valueWithArguments: {  $(.  $).  $".  $;.})) value: ( (SmallScheme globalRef:  #'whitespace')           )) ) . SmallScheme define:  #'specialX2DinitialX2Dchars'    "special-initial-chars"  as: (  '!!!!$%&/:*<=>?^_~' ) . SmallScheme define:  #'specialX2Dinitials'    "special-initials"  as: ( ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'specialX2DinitialX2Dchars')           )) ) . SmallScheme define:  #'specialX2DsubsequentX2Dchars'    "special-subsequent-chars"  as: (  '+-.@' ) . SmallScheme define:  #'pecularX2Didentifier'    "pecular-identifier"  as: (  ({ #'X2B'.  #'X2D'.  #'X2EX2EX2E'. } asRest) ) . SmallScheme define:  #'pecularX2Dinitials'    "pecular-initials"  as: (  ({ $+.  $-.  $.. } asRest) ) . SmallScheme define:  #'syntacticX2Dkeywords'    "syntactic-keywords"  as: (  ({ #'else'.  #'X3DX3E'.  #'define'.  #'unquote'.  #'unquoteX2Dsplicing'. } asRest) ) . SmallScheme define:  #'expressionX2Dkeywords'    "expression-keywords"  as: (  ({ #'quote'.  #'lambda'.  #'if'.  #'setX21'.  #'begin'.  #'cond'.  #'and'.  #'or'.  #'case'.  #'let'.  #'letX2A'.  #'letrec'.  #'do'.  #'delay'.  #'quasiquote'. } asRest) ) . SmallScheme define:  #'characterX2DnamesX2Dalist'    "character-names-alist"  as: ( ((SmallScheme globalRef:  #'cons')            value: (((SmallScheme globalRef:  #'cons')            value: ( #'space') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')            value: ( 32))))) value: (((SmallScheme globalRef:  #'cons')            value: (((SmallScheme globalRef:  #'cons')            value: ( #'tab') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')            value: ( 9))))) value: (((SmallScheme globalRef:  #'cons')            value: (((SmallScheme globalRef:  #'cons')            value: ( #'return') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')            value: ( 13))))) value: (((SmallScheme globalRef:  #'cons')            value: (((SmallScheme globalRef:  #'cons')            value: ( #'newline') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')            value: ( 10))))) value: (((SmallScheme globalRef:  #'cons')            value: (((SmallScheme globalRef:  #'cons')            value: ( #'formfeed') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')            value: ( 12))))) value: ( nil)))))))))) ) . SmallScheme define:  #'tokenX2Dclasses'    "token-classes"  as: (  ({ #'identifier'.  #'boolean'.  #'number'.  #'character'.  #'string'.  #'lparen'.  #'rparen'.  #'sharpX2Dlparen'.  #'quote'.  #'backquote'.  #'comma'.  #'commaX2Dsplice'.  #'period'. } asRest) ) . SmallScheme define:  #'abbreviationX2Dstarts'    "abbreviation-starts"  as: (  ({ $,.  $'.  $`. } asRest) ) . SmallScheme define:  #'radixX2Dchars'    "radix-chars"  as: (  'bodx' ) . SmallScheme define:  #'exactnessX2Dchars'    "exactness-chars"  as: (  'ie' ) . SmallScheme define:  #'letterX2Dchars'    "letter-chars"  as: (  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ) . SmallScheme define:  #'digitX2Dchars'    "digit-chars"  as: (  '0123456789' ) . SmallScheme define:  #'numX2D2X2Dchars'    "num-2-chars"  as: (  '01' ) . SmallScheme define:  #'numX2D8X2Dchars'    "num-8-chars"  as: (  '01234567' ) . SmallScheme define:  #'numX2D10X2Dchars'    "num-10-chars"  as: (  (SmallScheme globalRef:  #'digitX2Dchars')            ) . SmallScheme define:  #'numX2D16X2Dchars'    "num-16-chars"  as: (  '01234567689abcdefABCDEF' ) . SmallScheme define:  #'exponentX2DmarkerX2Dchars'    "exponent-marker-chars"  as: (  'esfdl' ) . SmallScheme define:  #'signX2Dchars'    "sign-chars"  as: (  '+-' ) . SmallScheme define:  #'legalX2DnumberX2DcharsX2Dlist'    "legal-number-chars-list"  as: ( ((SmallScheme globalRef:  #'append')                   valueWithArguments: { ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'signX2Dchars')           )). ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'numX2D16X2Dchars')           )). ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'exponentX2DmarkerX2Dchars')           )). ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'radixX2Dchars')           )). ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'exactnessX2Dchars')           )). ((SmallScheme globalRef:  #'list')                   valueWithArguments: {  $..  $#.  $@.  $/.}).}) ) . SmallScheme define:  #'subsequents'  as: ( ((SmallScheme globalRef:  #'append')                   valueWithArguments: { ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'letterX2Dchars')           )). ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'digitX2Dchars')           )). ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'specialX2DinitialX2Dchars')           )). ((SmallScheme globalRef:  #'stringX2DX3Elist')            value: ( (SmallScheme globalRef:  #'specialX2DsubsequentX2Dchars')           )).}) ) . SmallScheme define:  #'rparenX2Dmarker'    "rparen-marker"  as: (  ')' ) . SmallScheme define:  #'periodX2Dmarker'    "period-marker"  as: (  '.' ) . SmallScheme define:  #'stringX2DX3EcaseifiedX2Dsymbol'    "string->caseified-symbol"  as: (  [ :squashX2Dcase |                       [ :str | ((SmallScheme globalRef:  #'stringX2DX3Esymbol')                    value: (((SmallScheme globalRef:  #'listX2DX3Estring')                    value: (((SmallScheme globalRef:  #'map')                    value: ( squashX2Dcase) value: (((SmallScheme globalRef:  #'stringX2DX3Elist')                    value: ( str))))))))].       ] valueWithArguments: {( (((((SmallScheme globalRef:  #'eqX3F')                    value: ( $a) value: (((SmallScheme globalRef:  #'stringX2Dref')                    value: (((SmallScheme globalRef:  #'symbolX2DX3Estring')                    value: ( #'a'))) value: ( 00))))) == false) not)               	ifTrue: [ (SmallScheme globalRef:  #'charX2Ddowncase')                   ]               	ifFalse: [ (SmallScheme globalRef:  #'charX2Dupcase')                   ]). } ) . SmallScheme define:  #'read1'  as: (        [ :port |             [ | loop |                loop :=                [ :next |                 (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                        value: ( next))) == false) not)                   	ifTrue: [ next]                   	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DwhitespaceX3F')                            value: ( next))) == false) not)                       	ifTrue: [ [                         ((SmallScheme globalRef:  #'readX2Dchar')                              value: ( port)).                         (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                              value: ( port)))).                        ] value]                       	ifFalse: [ (((((SmallScheme globalRef:  #'commentX2DcharX3F')                                value: ( next))) == false) not)                           	ifTrue: [ [                             ((SmallScheme globalRef:  #'consumeX2Dcomment')                                  value: ( port)).                             (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                                  value: ( port)))).                            ] value]                           	ifFalse: [ (((((SmallScheme globalRef:  #'sharpX2DcharX3F')                                    value: ( next))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'readX2DsharpX2Dthingie')                                    value: ( port))]                               	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DnumericX3F')                                        value: ( next))) == false) not)                                   	ifTrue: [((SmallScheme globalRef:  #'readX2Dnumber')                                        value: ( port))]                                   	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DalphabeticX3F')                                            value: ( next))) == false) not)                                       	ifTrue: [((SmallScheme globalRef:  #'readX2Didentifier')                                            value: ( port))]                                       	ifFalse: [ (((((SmallScheme globalRef:  #'stringX2DcharX3F')                                                value: ( next))) == false) not)                                           	ifTrue: [((SmallScheme globalRef:  #'readX2Dstring')                                                value: ( port))]                                           	ifFalse: [ (((((SmallScheme globalRef:  #'abbrevX2DcharX3F')                                                    value: ( next))) == false) not)                                               	ifTrue: [((SmallScheme globalRef:  #'readX2Dabbreviation')                                                    value: ( port))]                                               	ifFalse: [ (((((SmallScheme globalRef:  #'lparenX2DcharX3F')                                                        value: ( next))) == false) not)                                                   	ifTrue: [((SmallScheme globalRef:  #'readX2Dlist')                                                        value: ( port))]                                                   	ifFalse: [ (((((SmallScheme globalRef:  #'specialX2DinitialX3F')                                                            value: ( next))) == false) not)                                                       	ifTrue: [((SmallScheme globalRef:  #'readX2Didentifier')                                                            value: ( port))]                                                       	ifFalse: [ (((((SmallScheme globalRef:  #'pecularX2DinitialX3F')                                                                value: ( next))) == false) not)                                                           	ifTrue: [((SmallScheme globalRef:  #'readX2Dpecular')                                                                value: ( port))]                                                           	ifFalse: [ (((((SmallScheme globalRef:  #'rparenX2DcharX3F')                                                                    value: ( next))) == false) not)                                                               	ifTrue: [ [                                                                 ((SmallScheme globalRef:  #'consumeX2Dchar')                                                                      value: ( port)).                                                                  (SmallScheme globalRef:  #'rparenX2Dmarker')                                                                     .                                                                ] value]                                                               	ifFalse: [((SmallScheme globalRef:  #'error')                                                                    value: ( 'read: unacceptable character with code:') value: (((SmallScheme globalRef:  #'charX2DX3Einteger')                                                                    value: ( next))))]]]]]]]]]]]]           ].           loop valueWithArguments: {               ((SmallScheme globalRef:  #'peekX2Dchar')                    value: ( port)). } ] value] ) . SmallScheme define:  #'commentX2DcharX3F'    "comment-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'eqX3F')                value: ( c) value: ( $;))] ) . SmallScheme define:  #'sharpX2DcharX3F'    "sharp-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'eqX3F')                value: ( c) value: ( $#))] ) . SmallScheme define:  #'stringX2DcharX3F'    "string-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'eqX3F')                value: ( c) value: ( $"))] ) . SmallScheme define:  #'lparenX2DcharX3F'    "lparen-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'eqX3F')                value: ( c) value: ( $())] ) . SmallScheme define:  #'rparenX2DcharX3F'    "rparen-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'eqX3F')                value: ( c) value: ( $)))] ) . SmallScheme define:  #'specialX2DinitialX3F'    "special-initial?"  as: (        [ :c | ((SmallScheme globalRef:  #'memv')                value: ( c) value: ( (SmallScheme globalRef:  #'specialX2Dinitials')               ))] ) . SmallScheme define:  #'pecularX2DinitialX3F'    "pecular-initial?"  as: (        [ :c | ((SmallScheme globalRef:  #'memv')                value: ( c) value: ( (SmallScheme globalRef:  #'pecularX2Dinitials')               ))] ) . SmallScheme define:  #'identifierX2DsubsequentX2DcharX3F'    "identifier-subsequent-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'memv')                value: ( c) value: ( (SmallScheme globalRef:  #'subsequents')               ))] ) . SmallScheme define:  #'abbrevX2DcharX3F'    "abbrev-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'memv')                value: ( c) value: ( (SmallScheme globalRef:  #'abbreviationX2Dstarts')               ))] ) . SmallScheme define:  #'legalX2DnumberX2DcharX3F'    "legal-number-char?"  as: (        [ :c | ((SmallScheme globalRef:  #'memv')                value: ( c) value: ( (SmallScheme globalRef:  #'legalX2DnumberX2DcharsX2Dlist')               ))] ) . SmallScheme define:  #'consumeX2Dchar'    "consume-char"  as: (        [ :port |  (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                    value: (((SmallScheme globalRef:  #'readX2Dchar')                    value: ( port))))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'error')                    value: ( 'Unexpected End Of File'))]] ) . SmallScheme define:  #'consumeX2Dcomment'    "consume-comment"  as: (        [ :port |  [             ((SmallScheme globalRef:  #'consumeX2Dchar')                  value: ( port)).                           [ | loop |                  loop :=                  [ :next |                   (((((SmallScheme globalRef:  #'not')                          value: ( [ :temp1 |                           ((( temp1) == false) not)                             	ifTrue: [ temp1]                             	ifFalse: [((SmallScheme globalRef:  #'charX2DnewlineX3F')                                  value: ( next))].                     ] valueWithArguments: {(((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))). }))) == false) not)                     	ifTrue: [ [                       ((SmallScheme globalRef:  #'consumeX2Dchar')                            value: ( port)).                       (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                            value: ( port)))).                      ] value]                     	ifFalse: [ #'done']             ].             loop valueWithArguments: {                 ((SmallScheme globalRef:  #'peekX2Dchar')                      value: ( port)). } ] value.            ] value] ) . SmallScheme define:  #'readX2DsharpX2Dthingie'    "read-sharp-thingie"  as: (        [ :port |  [             ((SmallScheme globalRef:  #'consumeX2Dchar')                  value: ( port)).              [ :next |                   [ :key2 |                       (((((SmallScheme globalRef:  #'memv')                              value: ( key2) value: ( ({ $t.  $f.  $T.  $F. } asRest)))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'makeX2Dboolean')                              value: ( port))]                         	ifFalse: [ [ :key3 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key3) value: ( ({ $e.  $i.  $o.  $b.  $d.  $x.  $E.  $I.  $O.  $B.  $D.  $X. } asRest)))) == false) not)                                 	ifTrue: [((SmallScheme globalRef:  #'readX2DnumberX2Dloop')                                      value: ( ({ $#. } asRest)) value: ( port))]                                 	ifFalse: [ [ :key4 |                                       (((((SmallScheme globalRef:  #'memv')                                              value: ( key4) value: ( ({ $\. } asRest)))) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'readX2Dcharacter')                                              value: ( port))]                                         	ifFalse: [ [ :key5 |                                               (((((SmallScheme globalRef:  #'memv')                                                      value: ( key5) value: ( ({ $(. } asRest)))) == false) not)                                                 	ifTrue: [((SmallScheme globalRef:  #'readX2Dvector')                                                      value: ( port))]                                                 	ifFalse: [ [ :key6 |                                                       (((((SmallScheme globalRef:  #'memv')                                                              value: ( key6) value: ( ({ $'. } asRest)))) == false) not)                                                         	ifTrue: [((SmallScheme globalRef:  #'readX2DsharpX2Dsym')                                                              value: ( port))]                                                         	ifFalse: [ [                                                            key6.                                                           ((SmallScheme globalRef:  #'error')                                                                value: ( 'Unknown sharp syntax') value: ( next)).                                                          ] value].                                                 ] valueWithArguments: {( key5). }].                                         ] valueWithArguments: {( key4). }].                                 ] valueWithArguments: {( key3). }].                         ] valueWithArguments: {( key2). }].                 ] valueWithArguments: {( next). }.             ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                      value: ( port))). }.            ] value] ) . SmallScheme define:  #'makeX2Dboolean'    "make-boolean"  as: (        [ :port |  [ :key7 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key7) value: ( ({ $t.  $T. } asRest)))) == false) not)                   	ifTrue: [ true]                   	ifFalse: [ [ :key8 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key8) value: ( ({ $f.  $F. } asRest)))) == false) not)                           	ifTrue: [ false]                           	ifFalse: [ [                              key8.                             ((SmallScheme globalRef:  #'error')                                  value: ( 'reading boolean: expected #t or #f here')).                            ] value].                   ] valueWithArguments: {( key7). }].           ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dchar')                    value: ( port))). }] ) . SmallScheme define:  #'readX2DsharpX2Dsym'    "read-sharp-sym"  as: (        [ :port |  [             ((SmallScheme globalRef:  #'consumeX2Dchar')                  value: ( port)).             ((SmallScheme globalRef:  #'cons')                  value: ( #'stringX2DX3Esymbol') value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'readX2DidentifierX2Dstring')                  value: ( port))) value: ( nil)))).            ] value] ) . SmallScheme define:  #'readX2Dcharacter'    "read-character"  as: (        [ :port |  [             ((SmallScheme globalRef:  #'consumeX2Dchar')                  value: ( port)).                          [ :next |                 (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                        value: ( next))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'EOF parsing character while reading file'))]                   	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DalphabeticX3F')                            value: ( next))) == false) not)                       	ifTrue: [ [ :charX2DnameX2Dstring |                             (((((SmallScheme globalRef:  #'X3D')                                    value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                    value: ( charX2DnameX2Dstring))))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'stringX2Dref')                                    value: ( charX2DnameX2Dstring) value: ( 00))]                               	ifFalse: [ [ :result9 |                                     ((( result9) == false) not)                                       	ifTrue: [((                                       [ :bucket | ((SmallScheme globalRef:  #'cdr')                                                value: ( bucket))]) value: ( result9))]                                       	ifFalse: [((SmallScheme globalRef:  #'error')                                            value: ( 'read: invalid character name') value: ( charX2DnameX2Dstring))].                               ] valueWithArguments: {(((SmallScheme globalRef:  #'assq')                                        value: (((SmallScheme globalRef:  #'stringX2DX3EcaseifiedX2Dsymbol')                                        value: ( charX2DnameX2Dstring))) value: ( (SmallScheme globalRef:  #'characterX2DnamesX2Dalist')                                       ))). }].                       ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2DidentifierX2Dstring')                                value: ( port))). }]                       	ifFalse: [((SmallScheme globalRef:  #'readX2Dchar')                            value: ( port))]]             ] value: (((SmallScheme globalRef:  #'peekX2Dchar')                  value: ( port))).            ] value] ) . SmallScheme define:  #'readX2DidentifierX2Dstring'    "read-identifier-string"  as: (        [ :port |             [ | loop |                loop :=                [ :chars |                 [ :next |                     (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                            value: ( next))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'listX2DX3Estring')                            value: (((SmallScheme globalRef:  #'reverse')                            value: ( chars))))]                       	ifFalse: [ (((((SmallScheme globalRef:  #'identifierX2DsubsequentX2DcharX3F')                                value: ( next))) == false) not)                           	ifTrue: [(loop value: (((SmallScheme globalRef:  #'cons')                                value: (((SmallScheme globalRef:  #'readX2Dchar')                                value: ( port))) value: ( chars))))]                           	ifFalse: [((SmallScheme globalRef:  #'listX2DX3Estring')                                value: (((SmallScheme globalRef:  #'reverse')                                value: ( chars))))]].               ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                        value: ( port))). }           ].           loop valueWithArguments: {               ((SmallScheme globalRef:  #'list')                    value: (((SmallScheme globalRef:  #'readX2Dchar')                    value: ( port)))). } ] value] ) . SmallScheme define:  #'readX2Dnumber'    "read-number"  as: (        [ :port | ((SmallScheme globalRef:  #'readX2DnumberX2Dloop')                value: (((SmallScheme globalRef:  #'list')                value: (((SmallScheme globalRef:  #'readX2Dchar')                value: ( port))))) value: ( port))] ) . SmallScheme define:  #'readX2DnumberX2Dloop'    "read-number-loop"  as: (        [ :chars :port |  [ :next |                 (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                        value: ( next))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'stringX2DX3Enumber')                        value: (((SmallScheme globalRef:  #'listX2DX3Estring')                        value: (((SmallScheme globalRef:  #'reverse')                        value: ( chars))))))]                   	ifFalse: [ (((((SmallScheme globalRef:  #'legalX2DnumberX2DcharX3F')                            value: ( next))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'readX2DnumberX2Dloop')                            value: (((SmallScheme globalRef:  #'cons')                            value: (((SmallScheme globalRef:  #'readX2Dchar')                            value: ( port))) value: ( chars))) value: ( port))]                       	ifFalse: [((SmallScheme globalRef:  #'stringX2DX3Enumber')                            value: (((SmallScheme globalRef:  #'listX2DX3Estring')                            value: (((SmallScheme globalRef:  #'reverse')                            value: ( chars))))))]].           ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                    value: ( port))). }] ) . SmallScheme define:  #'readX2Didentifier'    "read-identifier"  as: (        [ :port | ((SmallScheme globalRef:  #'stringX2DX3EcaseifiedX2Dsymbol')                value: (((SmallScheme globalRef:  #'readX2DidentifierX2Dstring')                value: ( port))))] ) . SmallScheme define:  #'readX2Dabbreviation'    "read-abbreviation"  as: (        [ :port |  [ :key10 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key10) value: ( ({ $`. } asRest)))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'list')                        value: ( #'quasiquote') value: (((SmallScheme globalRef:  #'read1')                        value: ( port))))]                   	ifFalse: [ [ :key11 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key11) value: ( ({ $'. } asRest)))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'list')                                value: ( #'quote') value: (((SmallScheme globalRef:  #'read1')                                value: ( port))))]                           	ifFalse: [ [ :key12 |                                 (((((SmallScheme globalRef:  #'memv')                                        value: ( key12) value: ( ({ $,. } asRest)))) == false) not)                                   	ifTrue: [ (((((SmallScheme globalRef:  #'eqX3F')                                            value: ( $@) value: (((SmallScheme globalRef:  #'peekX2Dchar')                                            value: ( port))))) == false) not)                                       	ifTrue: [ [                                         ((SmallScheme globalRef:  #'consumeX2Dchar')                                              value: ( port)).                                         ((SmallScheme globalRef:  #'list')                                              value: ( #'unquoteX2Dsplicing') value: (((SmallScheme globalRef:  #'read1')                                              value: ( port)))).                                        ] value]                                       	ifFalse: [((SmallScheme globalRef:  #'list')                                            value: ( #'unquote') value: (((SmallScheme globalRef:  #'read1')                                            value: ( port))))]]                                   	ifFalse: [ [                                      key12.                                     ((SmallScheme globalRef:  #'error')                                          value: ( 'Assert failed in reading abbreviation')).                                    ] value].                           ] valueWithArguments: {( key11). }].                   ] valueWithArguments: {( key10). }].           ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dchar')                    value: ( port))). }] ) . SmallScheme define:  #'readX2Dstring'    "read-string"  as: (        [ :port |  [             ((SmallScheme globalRef:  #'consumeX2Dchar')                  value: ( port)).                           [ | loop |                  loop :=                  [ :chars |                   [ :next |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'error')                              value: ( 'read: End Of File reading string'))]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( next) value: ( $"))) == false) not)                             	ifTrue: [ [                               ((SmallScheme globalRef:  #'consumeX2Dchar')                                    value: ( port)).                               ((SmallScheme globalRef:  #'listX2DX3Estring')                                    value: (((SmallScheme globalRef:  #'reverse')                                    value: ( chars)))).                              ] value]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( next) value: ( $\))) == false) not)                                 	ifTrue: [ [                                   ((SmallScheme globalRef:  #'consumeX2Dchar')                                        value: ( port)).                                    [ :following |                                         (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                                value: ( following))) == false) not)                                           	ifTrue: [((SmallScheme globalRef:  #'error')                                                value: ( 'EOF in read-string'))]                                           	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                    value: ( following) value: ( ({ $".  $\. } asRest)))) == false) not)                                               	ifTrue: [(loop value: (((SmallScheme globalRef:  #'cons')                                                    value: (((SmallScheme globalRef:  #'readX2Dchar')                                                    value: ( port))) value: ( chars))))]                                               	ifFalse: [((SmallScheme globalRef:  #'error')                                                    value: ( 'Illegal char following #\') value: ( following))]].                                   ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                                            value: ( port))). }.                                  ] value]                                 	ifFalse: [(loop value: (((SmallScheme globalRef:  #'cons')                                      value: (((SmallScheme globalRef:  #'readX2Dchar')                                      value: ( port))) value: ( chars))))]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                          value: ( port))). }             ].             loop valueWithArguments: {                  nil. } ] value.            ] value] ) . SmallScheme define:  #'readX2Dpecular'    "read-pecular"  as: (        [ :port |            [ :char |              [ :next |                 (((((SmallScheme globalRef:  #'memv')                        value: ( char) value: ( ({ $+.  $-. } asRest)))) == false) not)                   	ifTrue: [ (((((SmallScheme globalRef:  #'legalX2DnumberX2DcharX3F')                            value: ( next))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'readX2DnumberX2Dloop')                            value: (((SmallScheme globalRef:  #'list')                            value: ( char))) value: ( port))]                       	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                value: ( char) value: ( $+))) == false) not)                           	ifTrue: [ #'X2B']                           	ifFalse: [ #'X2D']]]                   	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                            value: ( $.) value: ( char))) == false) not)                       	ifTrue: [ (((((SmallScheme globalRef:  #'eqX3F')                                value: ( $.) value: ( next))) == false) not)                           	ifTrue: [ [                             ((SmallScheme globalRef:  #'consumeX2Dchar')                                  value: ( port)).                              (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( $.) value: (((SmallScheme globalRef:  #'peekX2Dchar')                                      value: ( port))))) == false) not)                                 	ifTrue: [ [                                   ((SmallScheme globalRef:  #'consumeX2Dchar')                                        value: ( port)).                                    #'X2EX2EX2E'.                                  ] value]                                 	ifFalse: [((SmallScheme globalRef:  #'error')                                      value: ( 'Illegal period literal'))].                            ] value]                           	ifFalse: [ (SmallScheme globalRef:  #'periodX2Dmarker')                               ]]                       	ifFalse: [((SmallScheme globalRef:  #'error')                            value: ( 'Assert failed in reading pecular identifier') value: ( char))]]             ] value: (((SmallScheme globalRef:  #'peekX2Dchar')                  value: ( port)))           ] value: (((SmallScheme globalRef:  #'readX2Dchar')                value: ( port)))] ) . SmallScheme define:  #'periodX2DmarkerX3F'    "period-marker?"  as: (        [ :thing | ((SmallScheme globalRef:  #'eqX3F')                value: ( (SmallScheme globalRef:  #'periodX2Dmarker')               ) value: ( thing))] ) . SmallScheme define:  #'rparenX2DmarkerX3F'    "rparen-marker?"  as: (        [ :thing | ((SmallScheme globalRef:  #'eqX3F')                value: ( (SmallScheme globalRef:  #'rparenX2Dmarker')               ) value: ( thing))] ) . SmallScheme define:  #'readX2Dlist'    "read-list"  as: (        [ :port |  [             ((SmallScheme globalRef:  #'consumeX2Dchar')                  value: ( port)).                           [ | loop |                  loop :=                  [ :result |                   [ :thing |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( thing))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'error')                              value: ( 'unexpected end of file reading list'))]                         	ifFalse: [ (((((SmallScheme globalRef:  #'rparenX2DmarkerX3F')                                  value: ( thing))) == false) not)                             	ifTrue: [((SmallScheme globalRef:  #'reverse')                                  value: ( result))]                             	ifFalse: [ (((((SmallScheme globalRef:  #'periodX2DmarkerX3F')                                      value: ( thing))) == false) not)                                 	ifTrue: [ [ :next |                                       (((((SmallScheme globalRef:  #'memv')                                              value: ( next) value: (((SmallScheme globalRef:  #'cons')                                              value: ( (SmallScheme globalRef:  #'periodX2Dmarker')                                             ) value: (((SmallScheme globalRef:  #'cons')                                              value: ( (SmallScheme globalRef:  #'rparenX2Dmarker')                                             ) value: ( nil))))))) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'error')                                              value: ( 'read: ill-formed list'))]                                         	ifFalse: [ [ :final |                                               (((((SmallScheme globalRef:  #'rparenX2DmarkerX3F')                                                      value: ( final))) == false) not)                                                 	ifTrue: [((SmallScheme globalRef:  #'setX2DlastX2Dpair')                                                      value: (((SmallScheme globalRef:  #'reverse')                                                      value: ( result))) value: ( next))]                                                 	ifFalse: [((SmallScheme globalRef:  #'error')                                                      value: ( 'read: ill-formed dotted list tail'))].                                         ] valueWithArguments: {(((SmallScheme globalRef:  #'read1')                                                  value: ( port))). }].                                 ] valueWithArguments: {(((SmallScheme globalRef:  #'read1')                                          value: ( port))). }]                                 	ifFalse: [(loop value: (((SmallScheme globalRef:  #'cons')                                      value: ( thing) value: ( result))))]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'read1')                          value: ( port))). }             ].             loop valueWithArguments: {                  nil. } ] value.            ] value] ) . SmallScheme define:  #'readX2Dvector'    "read-vector"  as: (        [ :port |  [ :list |                 (((((SmallScheme globalRef:  #'listX3F')                        value: ( list))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'listX2DX3Evector')                        value: ( list))]                   	ifFalse: [((SmallScheme globalRef:  #'error')                        value: ( 'read: ill-formed vector'))].           ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dlist')                    value: ( port))). }] ) . SmallScheme define:  #'read'  as: (        [ :inputX2Dport |            inputX2Dport := inputX2Dport asRest.           ((SmallScheme globalRef:  #'read1')                value: ( (((((SmallScheme globalRef:  #'nullX3F')                    value: ( inputX2Dport))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                    value)]               	ifFalse: [((SmallScheme globalRef:  #'car')                    value: ( inputX2Dport))]))] withLastArgRest  ) .! !