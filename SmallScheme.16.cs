'From Squeak3.2gamma[BC] of 15 January 2002 [latest update: #4743] on 23 June 2002 at 5:40:34 pm'!"Change Set:		SmallSchemeDate:			08 June 2002Author:			Kenneth A DickeyAdds Scheme programming language support."!BlockClosure variableSubclass: #BlockClosureLastArgRest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Execution'!Number subclass: #Complex	instanceVariableNames: 'real imaginal '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Complex commentStamp: '<historical>' prior: 0!Complex Numbers.Complex Numbers have real and imaginal (a.k.a. imaginary) elements.Structure: real imaginalCOPYRIGHT (c) 2002 by Kenneth A DickeyThis code is free for any use, but without warranty or liability of any kind.Functions from    _Less Complex Elementary Functions_          by  Henry Baker  ACM SIGPLAN Notices, Volume 27, Number 11, November 1992 !Object subclass: #Pair	instanceVariableNames: 'car cdr '	classVariableNames: ''	poolDictionaries: ''	category: 'SchemeCore'!!Pair commentStamp: '<historical>' prior: 0!Pairs are CONS cells.  List and Cons are sometimes used for other things, so cons cells are called pairs here.Pairs are CONS (list) cells.  Print using #asSchemeStringStructure: car	traditional name for FIRST cdr		traditional name for RESTCAR and CDR were the names of machine registers on an early computer when LISP was first implemented.  They don't make much sense until youuse, e.g., CADADR, which is a useful form for (CAr (cDr (cAr (cDR <whatever>)))).!Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList errorHandler dynamicVars '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!Link subclass: #Process2	instanceVariableNames: 'callStack priority myList suspendedControllers isaUIProcess dynamicVars '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Execution'!Model subclass: #SchemeEvalWindow	instanceVariableNames: 'schemeUserEnv schemeSource evalResult evalTextMorph resultTextMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'SchemeCore'!!SchemeEvalWindow commentStamp: 'KenD 6/18/2002 18:48' prior: 0!A SchemeEvalWindow is a simple EVAL display.SchemeEvalWindow open.Structure: schemeUserEnv  SmallScheme -- scheme EVAL environment. schemeSource	 text -- Source to be EVALed evalResult		 text -- what EVAL returnsBaby steps. Not a workspace.!Object subclass: #SmallScheme	instanceVariableNames: 'userEnv '	classVariableNames: 'LibraryDirPrefix R5RSEnv '	poolDictionaries: ''	category: 'SchemeCore'!!SmallScheme commentStamp: 'KenD 6/8/2002 19:25' prior: 0!SmallScheme is an implementation of R^5RS Scheme less call-with-current-continuation.Scheme programming language <href="http://www.schemers.org">.Structure: userEnv		user (instance) global environment (dictionary) R5RSEnv		shared (class) implementation environmentCOPYRIGHT (c) 2001, 2002 by Kenneth A DickeyThis software may be used for any purpose butwithout warrenty or liability of any kind.<HREF="mailto:kend0@earthlink.net">NOTES:  This system is intended as an intermediary/prototypeto allow me to learn the syntax and semantics for a full(perhaps less Call/CC) implementation of ANSI/IEEE/ISO Schemein Smalltalk.  Pole Star goal is compile Scheme to Smalltalkbytecodes in a unified runtime.  I would like to be ableto transliterate/decompile Smalltalk as Scheme (view SSthrough Scheme glasses).This is a _very_ rough cut to get the basic Scheme runtime up.The initial strategy is to make a Scheme runtime by augmenting theSmalltalk runtime and to generate code by translitering fromScheme to Smalltalk.  E.g. (lambda (n) (+ n 2)) -> [:n|n + 2].The Scheme user environment is contained in the scheme instance of theSmallScheme Class.Scheme allows one to redefine primitives, e.g.:  (define car 'chevy)But this cannot have an effect on other Schemeruntime functions, e.g. append, cadr, which use car.I.e. the original bindings are used there.The R5RSEnv namespace is used to store the 'immutable'.Scheme namespace.  Each Scheme instance 'inherits' fromthis but has their own dictionary in which a user canredefine (shadow) "primitives" without having an effecton the R5RS Scheme prims.Lexical vars use #toSchemeIdentifier and #fromSchemeIdentifier.('set-car!!' fromSchemeIdentifier) -> 'setX2dcarX21'('setX2dcarX21' toSchemeIdentifier) -> 'set-car!!'If you regen library init functions from the Scheme source,be sure to reset libraryDirPrefix in the class init function,then eval/doIt on:  SmallScheme fileinLibrary.  SmallScheme initLibrary.See also: Class documentation methods!Object subclass: #Stack	instanceVariableNames: 'top valuesArray '	classVariableNames: ''	poolDictionaries: ''	category: 'SchemeCore'!!Stack commentStamp: '<historical>' prior: 0!Main comment stating the purpose of this class and relevant relationship to other classes.LIFO Stack.Structure: top				number of elements == size == index of top value. valuesArray		array of valuesvaluesArray grows by doubling; no shrinkage at present.Initial purpose in life is to support SmallScheme dynamic variables.!!Object methodsFor: 'copying' stamp: 'ajh 5/23/2002 00:38'!copySameFrom: otherObject	"Copy to myself all instance variables named the same in otherObject.	This ignores otherObject's control over its own inst vars."	| myInstVars otherInstVars match |	myInstVars _ self class allInstVarNames.	otherInstVars _ otherObject class allInstVarNames.	myInstVars doWithIndex: [:each :index |		(match _ otherInstVars indexOf: each) > 0 ifTrue:			[self instVarAt: index put: (otherObject instVarAt: match)]].	1 to: (self basicSize min: otherObject basicSize) do: [:i |		self basicAt: i put: (otherObject basicAt: i)].! !!Object methodsFor: 'testing' stamp: 'KenD 5/12/2002 21:14'!isComplex		^ false! !!Object methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:54'!asPair	"asPair only works on lists, id elsewhere."	^self! !!Object methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:19'!asSchemeObjString	"base case: WRITE"	^( self asSchemeString )! !!Object methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:20'!asSchemeString	"base case: DISPLAY"	^( self asString )! !!Object methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:48'!isEmptyList		^(self == nil)! !!Object methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:47'!isPair		^false! !!BlockClosure methodsFor: 'converting' stamp: 'ajh 5/21/2002 20:59'!withLastArgRest	^ self as: BlockClosureLastArgRest! !!BlockClosure methodsFor: 'SchemeCore' stamp: 'KenD 6/7/2002 11:51'!asSchemeString	^('#<proc(' , ((self numArgs) asString) ,')>')! !!BlockClosureLastArgRest methodsFor: 'evaluating' stamp: 'ajh 5/21/2002 20:55'!value	^ self valueWithArguments: #()! !!BlockClosureLastArgRest methodsFor: 'evaluating' stamp: 'ajh 5/21/2002 20:55'!value: a	^ self valueWithArguments: {a}! !!BlockClosureLastArgRest methodsFor: 'evaluating' stamp: 'ajh 5/21/2002 20:56'!value: a value: b	^ self valueWithArguments: {a. b}! !!BlockClosureLastArgRest methodsFor: 'evaluating' stamp: 'ajh 5/21/2002 20:56'!value: a value: b value: c	^ self valueWithArguments: {a. b. c}! !!BlockClosureLastArgRest methodsFor: 'evaluating' stamp: 'ajh 5/21/2002 20:56'!value: a value: b value: c value: d	^ self valueWithArguments: {a. b. c. d}! !!BlockClosureLastArgRest methodsFor: 'evaluating' stamp: 'ajh 5/21/2002 20:55'!valueWithArguments: args	^ self valueWithRestArgs: args! !!BlockClosureLastArgRest methodsFor: 'evaluating' stamp: 'KenD 5/31/2002 12:00'!valueWithRestArgs: anArray 	"Call block with rest args packaged into a list"	"NB: assumes last arg is #rest arg."	| nFormal nActual newArgsArray |	nFormal := self numArgs.	nActual := anArray size.	(nFormal = 0)	ifTrue: [Error signal: 'Cannot have ZERO #rest args']	ifFalse: [		(nFormal > (nActual + 1))		ifTrue: [Error signal: 'Too few arguments']		ifFalse:[			newArgsArray := Array ofSize: nFormal.			"copy non-rest args"			1 to: (nFormal - 1) do:				[:index |					newArgsArray at: index put: (anArray at: index)].			"fill in the REST"			(nFormal > nActual)			ifTrue:  [newArgsArray at: nFormal put: #()]			ifFalse: [newArgsArray at: nFormal						 put: ((anArray copyFrom: nFormal to: nActual) asRest).].			^ super valueWithArguments: newArgsArray		].	].! !!BlockClosureLastArgRest methodsFor: 'SchemeCore' stamp: 'KenD 6/7/2002 11:51'!asSchemeString	^('#<proc(', (((self numArgs) - 1) asString) ,'.1)>')! !!BlockContext methodsFor: 'evaluating' stamp: 'KenD 5/20/2002 09:52'!valueWithRestArgs: anArray 	"Call block with rest args packaged into a list"	"NB: assumes last arg is #rest arg."	| nFormal nActual newArgsArray |	nFormal := self numArgs.	nActual := anArray size.	(nFormal = 0)	ifTrue: [Error signal: 'Cannot have ZERO #rest args']	ifFalse: [		(nFormal > (nActual + 1))		ifTrue: [Error signal: 'Too few arguments']		ifFalse:[			newArgsArray := Array ofSize: nFormal.			"copy non-rest args"			1 to: (nFormal - 1) do:				[:index |					newArgsArray at: index put: (anArray at: index)].			"fill in the REST"			(nFormal > nActual)			ifTrue:  [newArgsArray at: nFormal put: nil]			ifFalse: [newArgsArray at: nFormal						 put: ((anArray copyFrom: nFormal to: nActual) asPair).].			^self valueWithArguments: newArgsArray		].	].! !!Browser methodsFor: 'system category functions' stamp: 'Rik 2/1/2001 14:31'!reSortSystemCategories	self okToChange ifFalse: [^ self].	Cursor execute showWhile: [		systemOrganizer reSort.		self changed: #systemCategoryList.	].	^ true! !!Browser methodsFor: 'system category functions' stamp: 'Rik 12/23/2000 11:30'!systemCategoryMenu: aMenu^ aMenu labels:'find class... (f)recent classes... (r)browse allbrowseprintOutfileOutreorganizere-sortupdateadd item...rename...remove' 	lines: #(2 4 6 9)	selections:		#(findClass recent browseAllClasses buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory		editSystemCategories reSortSystemCategories updateSystemCategories		addSystemCategory renameSystemCategory removeSystemCategory )! !!Character methodsFor: 'SchemeCore' stamp: 'KenD 6/9/2002 16:16'!asSchemeObjString	| asciiVal |	asciiVal := self asciiValue.	(asciiVal = 32)	ifTrue: [ ^ '#\space' ]	ifFalse: [		(asciiVal = 13)		ifTrue: [^'#\return']		ifFalse: [			(asciiVal = 9)			ifTrue: [^'#\tab']			ifFalse: [ 				(asciiVal = 10)				ifTrue: [^'#\newline']				ifFalse: [					(asciiVal = 12)					ifTrue: [^'#\formfeed']					ifFalse: [^('#\' , (self asString)) ].		]  ]    ]	].! !!Character methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 12:05'!isHexChar       ^((($0 <= self) & (self <= $9)) |	 (($A <= self) & (self <= $F)) |	 (($a <= self) & (self <= $f)))! !!ClassOrganizer methodsFor: 'accessing'!reSort	self categories: self categories asSortedArray  ! !!Collection methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 09:48'!asPair	"collection -> Scheme Pair list	Nota Bene: converts (sub)collections recursively.	Distinguish asRest, which does NOT convert subcollections."	| firstPair lastPair |	(self isEmpty)	ifTrue: [ ^nil ]	ifFalse: [		firstPair := nil.		lastPair := nil.		self do: [ :elt | | newCons | 	     	newCons := Pair car: (elt asPair) cdr: nil. "<--NB: asPair recursion"			(firstPair == nil)			   ifTrue: [firstPair := newCons]			   ifFalse: [lastPair setCdr: newCons].			 lastPair := newCons.		].	 	^firstPair	].! !!Collection methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 09:45'!asRest	"collection -> Scheme REST list	Like asPair, but does not convert elts using asPair"	| firstPair lastPair |	(self isEmpty)	ifTrue: [ ^nil ]	ifFalse: [		firstPair := nil.		lastPair := nil.		self do: [ :elt | | newCons | 	     	newCons := Pair car: elt cdr: nil.			(firstPair == nil)			   ifTrue: [firstPair := newCons]			   ifFalse: [lastPair setCdr: newCons].			 lastPair := newCons.		].	 	^firstPair	].! !!Array methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:46'!asSchemeObjString	| str firstTime | 	str := '#('.	firstTime := true.	self do: [:elt| 		(firstTime)		ifTrue: [str := str , (elt asSchemeObjString).		   		firstTime := false.]		ifFalse: [str := str , ' ', (elt asSchemeObjString)].	].	^(str , ')')! !!Array methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:46'!asSchemeString	| str firstTime | 	str := '#('.	firstTime := true.	self do: [:elt| 		(firstTime)		ifTrue: [str := str , (elt asSchemeString).		   		firstTime := false.]		ifFalse: [str := str , ' ', (elt asSchemeString)].	].	^(str , ')')! !!CompiledMethod2 methodsFor: 'testing' stamp: 'ajh 5/30/2002 12:22'!= method	"Answer whether the receiver implements the same code as method."	(method isKindOf: CompiledMethod2) ifFalse: [^ false].	self size = method size ifFalse: [^ false].	header = method header ifFalse: [^ false].	bytecodes = method bytecodes ifFalse: [^ false].	1 to: self size do: [:i |		(self at: i) = (method at: i) ifFalse: [^ false]].	^ true! !!CompiledMethod2 methodsFor: 'testing' stamp: 'ajh 5/30/2002 12:23'!hash	^ bytecodes hash! !!False methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:24'!asSchemeString		^ '#f'! !!MethodContext2 methodsFor: 'accessing' stamp: 'ajh 3/20/2002 16:21'!printOn: aStream	| selector class mclass oldMethod home |	self isDead ifTrue: [^ aStream nextPutAll: 'dead '; nextPutAll: self class name].	self isBlockContext ifTrue: [		aStream nextPutAll: '[...]'.		^ (home _ self findBlockHome) ifNotNil: [aStream nextPutAll: ' from '; print: home]	].	self method == nil ifTrue: [^ super printOn: aStream].	oldMethod _ Smalltalk isClosureVersion		ifTrue: [self method]		ifFalse: [BytecodeInterpreter oldForNewMethod: self method 				 ifAbsent: [^ super printOn: aStream]].	selector _ 		(class _ self receiver class) 			selectorAtMethod: oldMethod			setClass: [:c | mclass _ c].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector.	selector == #doesNotUnderstand: ifTrue: [		aStream space; nextPutAll: (self arg: 0) selector].! !!MethodContext2 methodsFor: 'debugger access' stamp: 'ajh 2/14/2002 02:21'!previousPc	"Answer the index of the last bytecode executed."	^ InstructionStream2 ipBefore: self pc in: self method! !!MethodContext2 methodsFor: 'testing' stamp: 'ajh 5/24/2002 11:00'!isDead	"A frame becomes dead once execution returns from it (once it is popped)"	stack size < (frameIndex + FrameActiveOffset) ifTrue: [^ true].	(stack at: frameIndex + FrameActiveOffset) == self ifFalse: [^ true].	"very rare but the above could be true even if self is dead, if it just happened to be put on the stack by another frame in the same place where it used to reside."	(stack at: frameIndex + FrameMethodOffset) class == CompiledMethod2 ifFalse: [^ true].	"The last two conditions combined are very very rare if self is dead, so we can assume self is not dead"	^ false! !!Number methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:55'!ln	"Answer the natural log of the receiver."	(self < 0)	  ifTrue: [^Complex real: (((self negated) asFloat) ln) 		           imaginary: (Float pi) ]	  ifFalse: [^self asFloat ln].! !!Number methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 18:13'!signum	"For complex number implementation. NB: 0 signum -> 1"	"KenD 5/12/2002 18:12"	(self < 0)		ifTrue: [ ^ -1 ]		ifFalse: [ ^ 1 ].! !!Number methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 11:30'!sqrt	"Answer the square root of the receiver."	(self <  0)	ifTrue: [ ^ Complex real: 0 imaginary: ((self negated) asFloat) sqrt]	ifFalse: [ ^self asFloat sqrt].! !!Number methodsFor: 'converting' stamp: 'KenD 5/13/2002 08:58'!asComplex	"Coerce self to Complex number"	^ Complex real: self imaginary: 0! !!Number methodsFor: 'converting' stamp: 'KenD 6/9/2002 14:36'!i	"Return a complex number"	"KenD 5/12/2002 20:26"	^ (Complex real: 0 imaginary: self)! !!Complex methodsFor: 'arithmetic' stamp: 'KenD 5/12/2002 20:02'!* other	| c x1 x2 y1 y2 |	c := other asComplex.	x1 := (self  real).	x2 := (c real).	y1 := (self  imag).	y2 := (c imag).	^ Complex real: ((x1 * x2) - (y1 * y2)) 	     imaginary: ((x1 * y2) + (y1 * x2))! !!Complex methodsFor: 'arithmetic' stamp: 'KenD 5/12/2002 21:27'!+ other	| c |	c := other asComplex.	^ Complex real:  (real + (c real)) imaginary: (imaginal + (c imag))! !!Complex methodsFor: 'arithmetic' stamp: 'KenD 5/12/2002 21:27'!- other	| c |	c := other asComplex.	^ Complex real:  (real - (c real)) imaginary: (imaginal - (c imag))! !!Complex methodsFor: 'arithmetic' stamp: 'KenD 5/12/2002 20:27'!/ other	| c x1 x2 y1 y2 |	c := other asComplex.	x1 := (self  real).	x2 := (c real).	y1 := (self  imag).	y2 := (c imag).	^ Complex real:  ((x1 * x2) + (y1 * y2)) / ((x2 * x2) + (y2 * y2))	     imaginary: ((y1 * x2) - (x1 * y2)) / ((x2 * x2) + (y2 * y2))! !!Complex methodsFor: 'comparing' stamp: 'KenD 5/13/2002 09:17'!= aNumber	| c |	aNumber isNumber ifFalse: [^ false].	c := aNumber asComplex.	^ ((self real) = (c real)) & ((self imaginary) = (c imaginary))! !!Complex methodsFor: 'comparing' stamp: 'KenD 5/13/2002 09:19'!hash	"@@ could do better @@"	^ ((self real) + (self imaginary)) hash! !!Complex methodsFor: 'testing' stamp: 'KenD 5/12/2002 21:14'!isComplex		^ true! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:32'!abs	| x y |	x := real.	y := imaginal.	^(((x * x) + (y * y)) sqrt)! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:40'!acos	^((Float pi)/2 - (self asin))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 11:14'!acosh	| x y az az2 hairy |	x := real asFloat.	y := imaginal asFloat.     az := (self abs).	az2 := az squared.     hairy := ((((az2 - 1) squared) + (4 * y * y)) sqrt).	^Complex real: (1/2 * ((hairy + az2) acosh))	    imaginary: (1/2 * (y signum) 			* ((Float pi) - ((x signum) * ((hairy - az2) arcCos))))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:01'!asin	| x y az az2 hairy |	x := real.	y := imaginal.     az := (self abs).	az2 := az squared.     hairy := ((((az2 - 1) squared) + (4 * y * y)) sqrt).	^Complex real: (1/2 * (x signum) * ((hairy - az2) arcCos))	   imaginary: (1/2 * (y signum) * ((hairy + az2) acosh))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 11:12'!asinh	| x y az az2 hairy |	x := real asFloat.	y := imaginal asFloat.     az := (self abs).	az2 := az squared.     hairy := ((((az2 - 1) squared) + (4 * x * x)) sqrt).	^Complex real: (1/2 * (x signum) * ((hairy + az2) acosh))	   imaginary: (1/2 * (y signum) * ((hairy - az2) arcCos))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:49'!atan	| x y |	x := real.	y := imaginal.	^Complex real: (1/2 * 					((x ~= 0) 						ifTrue: [(2 * x) arcTan: (1 - ((self abs) squared))]						ifFalse: [ 							((y abs) > 1)							ifTrue: [(Float pi) * (x signum)]							ifFalse: [0].						])					)	   imaginary: (1/2 * (((2 * y) / (1 + ((self abs) squared))) atanh)).! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:54'!atanh	| x y az2 |	x := real.	y := imaginal.	az2 := (self abs) squared.	^ Complex real: (1/2 * (((2 * x) / (1 + az2)) atanh))	    imaginary: (1/2 * 					((y ~= 0) 					ifTrue: [(2 * y) arcTan: (1 - az2)]					ifFalse: [						((x abs) > 1)						ifTrue: [((Float pi) negated) * (x signum)]						ifFalse: [0]					]))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:31'!conjugate	| x y |	x := real.	y := imaginal.	^ Complex real: x imaginary: (y negated)! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:37'!cos	| x y |	x := real.	y := imaginal.	^ Complex real: ((x cos) * (y cosh)) imaginary: (((x sin) * (y sinh)) negated)! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:04'!cosh	| x y |	x := real asFloat.	y := imaginal asFloat.	^ Complex real: ((x cosh) * (y cos)) imaginary: ((x sinh) * (y sin))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:35'!exp	| x y e2x |	x := real.	y := imaginal.	e2x := x exp.	^ (Complex real: (e2x * (y cos)) imaginary: (e2x * (y sin)))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:33'!inverse	^(self / (self norm))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:49'!ln	| x y |	x := real.	y := imaginal.	^ (Complex real: ( 1/2 * ((((self abs) squared) asFloat) ln) )	     imaginary: (y arcTan: x))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:33'!norm	^(self * (self conjugate))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:34'!signum	"NB: signum(0) is 1 [required]"	^(self / (self abs))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:36'!sin	| x y |	x := real.	y := imaginal.	^ Complex real: ((x sin) * (y cosh)) imaginary: ((x cos) * (y sinh))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:03'!sinh	| x y |	x := real asFloat.	y := imaginal asFloat.	^ Complex real: ((x sinh) * (y cos)) imaginary: ((x cosh) * (y sin))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 11:25'!sqrt	| az |	az := self abs.	^Complex real: (((az + real) / 2) sqrt) 	   imaginary: ((imaginal signum) * (((az - real) / 2) sqrt))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:31'!squared	| x y |	x := real.	y := imaginal.	^ Complex real: ((x + y) * (x - y))	     imaginary: (2 * x * y)! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/12/2002 20:38'!tan	| x2 y2 |	x2 := (real * 2).	y2 := (imaginal * 2).	^Complex real: ((x2 sin) / ((x2 cos) + (y2 cosh)))	   imaginary: ((y2 tanh) / (1 + ((x2 cos) / (y2 cosh))))! !!Complex methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:11'!tanh	| x2 y2 |	x2 := (real * 2) asFloat.	y2 := (imaginal * 2) asFloat.	^ Complex real: ((x2 tanh) / (1 + ((y2 cos)/(x2 cosh))))	    imaginary: ((y2 sin) / ((x2 cosh) + (y2 cos)))! !!Complex methodsFor: 'converting' stamp: 'KenD 5/13/2002 09:08'!adaptToFloat: rcvr andSend: selector	^ (rcvr asComplex) perform: selector with: self! !!Complex methodsFor: 'converting' stamp: 'KenD 5/13/2002 09:08'!adaptToFraction: rcvr andSend: selector	^ (rcvr asComplex) perform: selector with: self! !!Complex methodsFor: 'converting' stamp: 'KenD 5/13/2002 09:09'!adaptToInteger: rcvr andSend: selector	^ (rcvr asComplex) perform: selector with: self! !!Complex methodsFor: 'converting' stamp: 'KenD 5/13/2002 09:13'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a Point, convert me to a Point."	^ rcvr perform: selector with: (self asPoint)! !!Complex methodsFor: 'converting' stamp: 'KenD 5/12/2002 18:46'!asComplex	^self! !!Complex methodsFor: 'converting' stamp: 'KenD 5/13/2002 09:12'!asPoint	^ (self real) @ (self imaginary)! !!Complex methodsFor: 'converting' stamp: 'KenD 6/9/2002 14:55'!asSchemeString       ((imaginal = 0) | (imaginal = nil))	  ifTrue: [ ^ real ifNil: ['0'] ifNotNil: [real asSchemeString]]	  ifFalse: [		((real = 0) | (real = nil))	  	ifTrue: [ ^ (imaginal asSchemeString), 'i']	  	ifFalse: [ (imaginal < 0)			ifTrue: [ ^  (real asSchemeString)  , (imaginal asSchemeString) , 'i' ]			ifFalse: [ ^  (real asSchemeString) , '+' , (imaginal asSchemeString) , 'i' ].		]	  ].! !!Complex methodsFor: 'converting' stamp: 'KenD 5/12/2002 19:31'!asString       ((imaginal = 0) | (imaginal = nil))	  ifTrue: [ ^ real ifNil: ['0'] ifNotNil: [real asString]]	  ifFalse: [		((real = 0) | (real = nil))	  	ifTrue: [ ^ (imaginal asString), 'i']	  	ifFalse: [ ^ '(' , (real asString) , ' + ' , (imaginal asString) , 'i)'].	  ].! !!Complex methodsFor: 'access' stamp: 'KenD 5/24/2002 19:29'!angle	^ ((imaginal / real) arcTan)! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:58'!imag	^imaginal! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:59'!imag: i	imaginal := i.	^self! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:58'!imaginal	^imaginal! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:59'!imaginal: i	imaginal := i.	^self! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:58'!imaginary	^imaginal! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:59'!imaginary: i	imaginal := i.	^self! !!Complex methodsFor: 'access' stamp: 'KenD 5/24/2002 19:23'!magnitude	^self abs! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:57'!real	^real! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 19:59'!real: r	real := r.	^self! !!Complex methodsFor: 'access' stamp: 'KenD 5/12/2002 18:50'!real: r imaginary: i	real := r.	imaginal := i.	^ self! !!Complex methodsFor: 'printing' stamp: 'KenD 5/12/2002 19:05'!printOn: aStream	aStream nextPutAll: (self asString).! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 10:49'!acosh	"answer hyperbolic arc cosine of self"	(self >= 1)		ifTrue: [ ^ (self * (1 + ((1 - (1 / (self * self))) sqrt))) ln]	  	ifFalse: [			((self abs) <= 1)	  		ifTrue: [ ^ (((1 - (self * self)) sqrt) arcTan: self)i ]	  		ifFalse: [ ^ Complex real: ((self negated) acosh) imaginary: (Float pi)].		].	"KenD 5/12/2002 19:40"! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:33'!asinh	"answer hyperbolic arc sine of self"	^(1/2 * (self signum) * ((1 + (2 * self * self)) acosh))! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:33'!atanh	"answer hyperbolic arc tangent of self"	| x |	x := self abs.	(x < 1)	  ifTrue: [^ 1/2 * (((1 + self) / (1 - self)) ln)]	  ifFalse: [^ Complex real: ((1/self) atanh) 				  imaginary: (((Float pi)/2 * (self signum)) negated)].	"KenD 5/12/2002 19:40"! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:29'!cosh	"Answer the hyperbolic cosine of the receiver taken as an angle in radians."	^ ( (self exp) + ((self negated) exp) ) / 2! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:33'!coth	"Answer the hyperbolic cotangent of the receiver taken as an angle in radians."	^ ( (self exp) + ((self negated) exp) ) / ( (self exp) - ((self negated) exp) ) ! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:31'!csch	"Answer the hyperbolic cosecant of the receiver taken as an angle in radians."	^ 2 / ( (self exp) - ((self negated) exp) ) ! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 12:35'!ln	"Answer the natural logarithm of the receiver.	 PrimOp fails for complex case."	(self <= 0.0)	ifTrue: [^ self asComplex ln ]	ifFalse: [^ self lnPrim ].! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 12:32'!lnPrim	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [^Complex real: (((self negated) asFloat) ln) 		             		  imaginary: (Float pi)].	"get a rough estimate from binary exponent"	expt _ self exponent.	n _ Ln2 * expt.	mant _ self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x _ mant - 1.0.	div _ 1.0.	pow _ delta _ sum _ x.	x _ x negated.  "x <= 0"	eps _ Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta.		"pass two: delta is negative"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 11:42'!log	"Answer the base 10 logarithm of the receiver."	(self < 0)	ifTrue: [ ^ (self asComplex) ln / Ln10 ]	ifFalse: [ ^ self ln / Ln10 ].! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:31'!sech	"Answer the hyperbolic secant of the receiver taken as an angle in radians."	^ 2 / ( (self exp) + ((self negated) exp) ) ! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:31'!sinh	"Answer the hyperbolic sine of the receiver taken as an angle in radians."	^ ( (self exp) - ((self negated) exp) ) / 2! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 11:49'!sqrt	"Answer the square root of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	"Newton-Raphson"	self <= 0.0 ifTrue: [		self = 0.0			ifTrue: [^ 0.0]			ifFalse: [^ self asComplex sqrt]].	"first guess is half the exponent"	exp _ self exponent // 2.	guess _ self timesTwoPower: (0 - exp).	"get eps value"	eps _ guess * Epsilon.	eps _ eps * eps.	delta _ (self - (guess * guess)) / (guess * 2.0).	[(delta * delta) > eps] whileTrue: [		guess _ guess + delta.		delta _ (self - (guess * guess)) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'mathematical functions' stamp: 'KenD 5/13/2002 09:31'!tanh	"Answer the hyperbolic tangent of the receiver taken as an angle in radians."	^ ( (self exp) - ((self negated) exp) ) / ( (self exp) + ((self negated) exp) ) ! !!Float methodsFor: 'truncation and round off' stamp: 'KenD 6/23/2002 07:56'!round	"Answer the integer nearest the receiver but round to even if in middle."	(self fractionPart abs = 0.5)		ifTrue: [ | trunc |			trunc := self truncated.			(trunc even)				ifTrue: [^trunc]				ifFalse: [					self >= 0.0						ifTrue: [^trunc + 1]						ifFalse: [^trunc - 1].				]		]		ifFalse: [			self >= 0.0				ifTrue: [^(self + 0.5) truncated]				ifFalse: [^(self - 0.5) truncated]		].! !!Fraction methodsFor: 'SchemeCore' stamp: 'KenD 6/9/2002 14:47'!asSchemeString	"don't print within parens"	^(numerator asString) ,  '/' , (denominator asString)! !!Object class methodsFor: 'instance creation' stamp: 'ajh 5/23/2002 00:35'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject.	If the classes have any instance varaibles with the same names, copy them across.	If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]	  ) copySameFrom: aSimilarObject! !!Complex class methodsFor: 'instance creation' stamp: 'KenD 5/24/2002 19:32'!magnitude: m angle: a	"Polar form"	^ (m * (Complex real:(a cos) imaginary:(a sin)))! !!Complex class methodsFor: 'instance creation' stamp: 'KenD 5/24/2002 19:33'!real: r imaginary: i	"rectangular form"	| newSelf |	newSelf := super new.	newSelf real: r imaginary: i.	^newSelf! !!Complex class methodsFor: 'testing' stamp: 'KenD 5/13/2002 11:04'!quickCheck	Complex quickCheck: Transcript.! !!Complex class methodsFor: 'testing' stamp: 'KenD 5/13/2002 11:03'!quickCheck: aStream"Expected Result================================Sample Complex usage: 3.2i prints as: 3.2i     a = ((1/2) + 2.1i)     b = ((3/4) + 5.7i) a + b = ((5/4) + 7.8i) a - b = ((-1/4) + -3.6i) a * b = (-11.595 + 4.425i) a * 3 = (1.5 + 6.3i) 3 * b = (2.25 + 17.1i) a / b = (0.373497 + -0.038575i) a / 3 = (0.166667 + 0.7i) 3 / b = (0.0680735 + -0.517359i)sin(a) = (1.98689 + 3.52951i)cos(a) = (3.63698 + -1.92818i)tan(a) = (0.0248288 + 0.983615i) ln(3) = 1.09861ln(-3) = (1.09861 + 3.14159i) ln(a) = (0.769508 + 1.33705i)exp(3) = 20.0855exp(a) = (-0.832351 + 1.42319i)conjugate(a) = ((1/2) + -2.1i)  inverse(a) = (0.107296 + 0.450644i)     norm(a) = 4.66asin(sin(a)) = (0.5 + 2.1i)acos(cos(a)) = (0.5 + 2.1i)atan(tan(a)) = (0.5 + 2.1i)  abs(a - b) = 3.60867 norm(a - b) = 13.0225     sinh(a) = (-0.263073 + 0.973377i)     cosh(a) = (-0.569278 + 0.449814i)     tanh(a) = (1.11624 + -0.827849i)asinh(sinh(a)) = (-0.5 + 1.04159i)acosh(cosh(a)) = (0.5 + 2.1i)atanh(tanh(a)) = (0.5 + 2.1i)"	| a b |	aStream cr.	aStream show: 'Sample Complex usage:'. 	aStream cr.	aStream show: ' 3.2i prints as: ' , (3.2i asString).	a := Complex real: 1/2 imaginary: 2.1 .	b := Complex real: 3/4 imaginary: 5.7 .	aStream cr.	aStream show: '     a = ' , (a asString). 	aStream cr.	aStream show: '     b = ' , (b asString). 	aStream cr.	aStream show: ' a + b = ' , ((a + b) asString). 	aStream cr.	aStream show: ' a - b = ' , ((a - b) asString). 	aStream cr.	aStream show: ' a * b = ' , ((a * b) asString). 	aStream cr.	aStream show: ' a * 3 = ' , ((a * 3) asString). 	aStream cr.	aStream show: ' 3 * b = ' , ((3 * b) asString). 	aStream cr.	aStream show: ' a / b = ' , ((a / b) asString). 	aStream cr.	aStream show: ' a / 3 = ' , ((a / 3) asString). 	aStream cr.	aStream show: ' 3 / b = ' , ((3 / b) asString). 	aStream cr.	aStream show: 'sin(a) = ' , ((a sin) asString). 	aStream cr.	aStream show: 'cos(a) = ' , ((a cos) asString). 	aStream cr.	aStream show: 'tan(a) = ' , ((a tan) asString). 	aStream cr.	aStream show: ' ln(3) = ' , ((3 ln) asString). 	aStream cr.	aStream show: 'ln(-3) = ' , ((-3 ln) asString). 	aStream cr.	aStream show: ' ln(a) = ' , ((a ln) asString). 	aStream cr.	aStream show: 'exp(3) = ' , ((3 exp) asString). 	aStream cr.	aStream show: 'exp(a) = ' , ((a exp) asString). 	aStream cr.	aStream show: 'conjugate(a) = ' , ((a conjugate) asString). 	aStream cr.	aStream show: '  inverse(a) = ' , ((a inverse) asString). 	aStream cr.	aStream show: '     norm(a) = ' , ((a norm) asString). 	aStream cr.	aStream show: 'asin(sin(a)) = ' , (((a sin) asin) asString). 	aStream cr.	aStream show: 'acos(cos(a)) = ' , (((a cos) acos) asString). 	aStream cr.	aStream show: 'atan(tan(a)) = ' , (((a tan) atan) asString). 	aStream cr.	aStream show: '  abs(a - b) = ' , (((a - b) abs) asString). 	aStream cr.	aStream show: ' norm(a - b) = ' , (((a - b) norm) asString). 	aStream cr.	aStream show: '     sinh(a) = ' , ((a sinh) asString). 	aStream cr.	aStream show: '     cosh(a) = ' , ((a cosh) asString). 	aStream cr.	aStream show: '     tanh(a) = ' , ((a tanh) asString). 	aStream cr.	aStream show: 'asinh(sinh(a)) = ' , (((a sinh) asinh) asString). 	aStream cr.	aStream show: 'acosh(cosh(a)) = ' , (((a cosh) acosh) asString). 	aStream cr.	aStream show: 'atanh(tanh(a)) = ' , (((a tanh) atanh) asString).	aStream cr.	aStream show: ''! !!Pair methodsFor: 'testing' stamp: 'KenD 5/9/2002 19:47'!isPair	^true! !!Pair methodsFor: 'testing' stamp: 'KenD 5/10/2002 08:13'!isProper 	"Proper List?"	| first rest | 	first := car.	rest  := cdr.	[(rest isPair) & ((rest == first) not)]	    whileTrue: [ first := rest.					rest  := (rest cdr) ].	^(rest == nil)! !!Pair methodsFor: 'comparison' stamp: 'KenD 5/9/2002 21:54'!= other	"equal?"	(other isPair)	  ifTrue: [		(car = (other car)) 	         ifTrue: [ ^(cdr = (other cdr)) ]	         ifFalse: [ ^false ].	  ]	  ifFalse: [ ^false ].! !!Pair methodsFor: 'comparison' stamp: 'KenD 5/9/2002 21:11'!length	"Number of elements in Pair list."	| first rest len |	first := car.	rest  := cdr.     len   := 1.	[(rest isPair) & ((rest == first) not)]	    whileTrue: 			[first := rest.			 rest  := (rest cdr).			 len   := len + 1 ].        ((rest == first) & ((first == nil) not))	    ifTrue: [ ^ Float infinity ]	    ifFalse: [ ^ len ].! !!Pair methodsFor: 'comparison' stamp: 'KenD 5/9/2002 21:12'!size	"just an alias for length"	^self length! !!Pair methodsFor: 'private' stamp: 'KenD 5/10/2002 07:43'!car: aCar cdr: aCdr	"Helper for Pair car:cdr:"	car := aCar.	cdr := aCdr.	^self! !!Pair methodsFor: 'conversion' stamp: 'KenD 5/24/2002 21:31'!asArray	^self collectArray: [ :elt | elt ].! !!Pair methodsFor: 'conversion' stamp: 'KenD 5/9/2002 21:51'!asPair	^self! !!Pair methodsFor: 'conversion' stamp: 'KenD 6/5/2002 07:55'!asRest	^self! !!Pair methodsFor: 'conversion' stamp: 'KenD 5/10/2002 07:40'!asSchemeListString	"Helper for asSchemeString"	| str thing |	str := '(' , (car asSchemeString).	thing := cdr.	[thing isPair]		whileTrue: [				str := str ,' ', ((thing car) asSchemeString).				thing := (thing cdr).			   ].	(thing == nil)	    ifTrue: [ ^ str , ')' ]	    ifFalse: [ ^ str , ' . ' , (thing asSchemeString) , ')' ].! !!Pair methodsFor: 'conversion' stamp: 'KenD 5/10/2002 13:58'!asSchemeObjListString	"Helper for asSchemeObjString"	| str thing | 	str := '(' , (car asSchemeObjString).	thing := cdr.	[thing isPair]		whileTrue: [			str := str ,' ', ((thing car) asSchemeObjString).			thing := (thing cdr).		].	(thing == nil)	    ifTrue: [ ^ str , ')' ]	    ifFalse: [ ^ str , ' . ' , (thing asSchemeObjString) , ')' ].! !!Pair methodsFor: 'conversion' stamp: 'KenD 5/10/2002 13:54'!asSchemeObjString	"Scheme print string: (write <whatever>)"	(((self cdr) isPair) ifTrue: [(self cddr) isEmptyList] ifFalse: [false])	ifTrue: [		(#quote = car)	 	ifTrue: [ ^ '''' , ((self cadr) asSchemeObjString) ]	  	ifFalse: [			(#quasiquote = car)	  		ifTrue: [ ^ '`' , ((self cadr) asSchemeObjString) ]	  		ifFalse: [				(#unquote = car)				ifTrue: [ ^( ','  , ((self cadr) asSchemeObjString) ) ]				ifFalse: [					(#'unquote-splicing' = car)	  				ifTrue: [ ^ ',@' , ((self cadr) asSchemeObjString) ]	  				ifFalse: [^self asSchemeObjListString].				].			].		].	]	ifFalse: [ ^ self asSchemeObjListString ].! !!Pair methodsFor: 'conversion' stamp: 'KenD 5/10/2002 11:18'!asSchemeString	"Scheme print string: (display <whatever>)"	((cdr isPair) ifTrue: [(self cddr) isEmptyList] ifFalse: [false])	ifTrue: [	   (#quote = car)	   ifTrue: [ ^ '''' , ((self cadr) asSchemeString) ]	   ifFalse: [ 			(#quasiquote = car)	    		  ifTrue: [ ^ '`' , ((self cadr) asSchemeString) ]	  		  ifFalse: [				(#unquote = car)	    			ifTrue: [ ^ ','  , ((self cadr) asSchemeString) ]	  			ifFalse: [ 					(#'unquote-splicing' = car)	   				ifTrue: [ ^ ',@' , ((self cadr) asSchemeString) ]	  				ifFalse: [ ^ self asSchemeListString ].				]			  ]		]	]	ifFalse: [^self asSchemeListString].! !!Pair methodsFor: 'conversion' stamp: 'KenD 5/9/2002 21:20'!asString	"Smalltalk print string"	| str thing |	((self length) isInfinite)		ifTrue: [Exception signal: 'Circulat list!!']		ifFalse: [	str := '(' , (car asString).	thing := cdr.	[thing isPair] 		whileTrue: [ str := str , ' ' , ((thing car) asString).					 thing := thing cdr.					].	(thing == nil)		ifTrue: [^( str , ')' )]		ifFalse: [^( str , ' . ' , (thing asString) , ')' )].].! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/10/2002 09:25'!append: other	"functional append -- new (copied) head"	" ^( (self copy) appendX21: other ) bummed for speed"	| p firstPair lastPair |      p := cdr.	firstPair := Pair car: car cdr: nil.  "result"     lastPair := firstPair.	[p isPair]	    whileTrue: [			lastPair setCdr: (Pair car: (p car) cdr: nil).			lastPair := lastPair cdr.              p := p cdr.		].  	lastPair setCdr: other.	^firstPair! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/10/2002 08:53'!appendX21: other	"append!! -- destructive (side effecting) append"	(self lastPair) setCdr: other.	^self! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:49'!caaaar	^(((car car) car) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:49'!caaadr	^(((cdr car) car) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:47'!caaar	^((car car) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:49'!caadar	^(((car cdr) car) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:49'!caaddr	^(((cdr cdr) car) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:47'!caadr	^((cdr car) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:46'!caar	^(car car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!cadaar	^(((car car) cdr) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!cadadr	^(((cdr car) cdr) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:48'!cadar	^((car cdr) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!caddar	^(((car cdr) cdr) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!cadddr	^(((cdr cdr) cdr) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:48'!caddr	^((cdr cdr) car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:46'!cadr	^(cdr car)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 19:45'!car	^car! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!cdaaar	^(((car car) car) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!cdaadr	^(((cdr car) car) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:48'!cdaar	^((car car) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!cdadar	^(((car cdr) car) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:50'!cdaddr	^(((cdr cdr) car) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:48'!cdadr	^((cdr car) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:47'!cdar	^(car cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:51'!cddadr	^(((cdr car) cdr) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:48'!cddar	^((car cdr) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:51'!cdddar	^(((car cdr) cdr) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:51'!cddddr	^(((cdr cdr) cdr) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:48'!cdddr	^((cdr cdr) cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 21:46'!cddr	^(cdr cdr)! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 19:45'!cdr	^cdr! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/10/2002 08:03'!copy	"shallow copy"	^( self do: [ :elt | elt ] )! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/10/2002 07:54'!lastPair	"last cons (Pair) in the list"	| p last |	p := self cdr.     last := self.	[p isPair]	    whileTrue: [			last := p.			p := p cdr.]. 	^last! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 22:06'!reverse     | new | 	new := nil.	self do: [:val | new := (Pair car: val cdr: new)].	^new! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/10/2002 07:28'!setCar: aCar	"setCar!!"	car := aCar.! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/10/2002 07:28'!setCarX21: aCar	"setCar!!"	car := aCar.! !!Pair methodsFor: 'accessing' stamp: 'KenD 5/9/2002 19:39'!setCdr: aCdr	"setCdr"	cdr := aCdr.! !!Pair methodsFor: 'enumerating' stamp: 'KenD 5/9/2002 21:39'!collect: aBlock	"map1"	| p result lastPair | 	p := self. 	result := nil.	lastPair := nil. 	[p isPair]	 whileTrue:             [ | newCons |			newCons := Pair car: (aBlock value: (p car)) cdr: nil.			(lastPair == nil)				ifTrue: [result := newCons]				ifFalse: [lastPair setCdr: newCons].	     	lastPair := newCons.             	p := p cdr.            ].  	 ^result! !!Pair methodsFor: 'enumerating' stamp: 'KenD 5/24/2002 21:30'!collectArray: aBlock	| result p index |	result := Array ofSize: (self size).	p := self.	index := 1.	[p isPair]	    whileTrue: [ 			result at: index put: (aBlock value: (p car)).			index := index + 1.			p := p cdr.		].  	^result! !!Pair methodsFor: 'enumerating' stamp: 'KenD 5/9/2002 21:41'!detect: predicateBlock	"return first match or FALSE"	| p | 	p := self.	[p isPair]	    whileTrue: [			(predicateBlock value: (p car))				ifTrue: [ ^(p car) ]                   ifFalse: [ p := p cdr. ].		].	^false   "no match"! !!Pair methodsFor: 'enumerating' stamp: 'KenD 5/10/2002 08:10'!do: aBlock	"forEach"	| p |      p := self.	[p isPair]	    whileTrue: [ aBlock value: (p car).                        p := p cdr.].  	((p == nil) not)		ifTrue: [aBlock value: p]. "else improper list. Signal an error?"! !!Pair methodsFor: 'enumerating' stamp: 'KenD 5/9/2002 21:45'!reject: predicateBlock	^self select: [:elt | ((predicateBlock value: elt) not)]! !!Pair methodsFor: 'enumerating' stamp: 'KenD 5/9/2002 21:44'!select: predicateBlock	"map1"	| p result lastPair | 	p := self. 	result := nil.	lastPair := nil. 	[p isPair]	 whileTrue: [            (predicateBlock value: (p car))	     	ifTrue: [ | newCons | 				newCons := Pair car: (p car) cdr: nil.				(lastPair == nil)		  			ifTrue: [result := newCons]		  			ifFalse: [lastPair setCdr: newCons].	        		lastPair := newCons.			].             	p := p cdr.      ].  	 ^result! !!Pair methodsFor: 'printing' stamp: 'KenD 5/24/2002 10:51'!printOn: aStream	aStream nextPutAll: (self asSchemeObjString).! !!Pair class methodsFor: 'instance creation' stamp: 'KenD 5/13/2002 17:40'!car: aCar cdr: aCdr	"Cons(tructor)   		Pair car: 2 cdr: 3.  --> (2 . 3)"	| aCons |	aCons := super new.     aCons car: aCar cdr: aCdr.	^aCons! !!Pair class methodsFor: 'instance creation' stamp: 'KenD 5/10/2002 11:16'!with: aCar	"(list one)"	| aCons |	aCons := super new initialize.     aCons car: aCar cdr: nil.	^aCons! !!Pair class methodsFor: 'instance creation' stamp: 'KenD 5/10/2002 11:16'!with: one with: two	"(list one two)"	| aCons |	aCons := super new initialize.     aCons car: one cdr: (Pair car: two cdr: nil).	^aCons! !!Pair class methodsFor: 'instance creation' stamp: 'KenD 5/10/2002 11:16'!with: one with: two with: three	"(list one two three)"	| aCons |	aCons := super new initialize.     aCons car: one cdr: (Pair car: two cdr: (Pair car: three cdr: nil)).	^aCons! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'KenD 6/18/2002 19:53'!accept 	"Inform the model of text to be accepted, and return true if OK."	| textToAccept ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection _ self selectionInterval copy.	saveScrollerOffset _ scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?') ifFalse: [^ self flash]].	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok==true ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) doIfNotNil:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	[		"During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, then		restores the cursor and scrollbar"		ok ifTrue:[ "(don't bother if there was an error during compile)"			(model isKindOf: CodeHolder) 				ifTrue:[	model updateCodePaneIfNeeded].			WorldState addDeferredUIMessage: [				World activeHand newKeyboardFocus: textMorph.				scroller offset: saveScrollerOffset.				self setScrollDeltas.				self selectFrom: saveSelection first to: saveSelection last.			].		].	] on: Error do: [].! !!Process methodsFor: 'accessing' stamp: 'KenD 5/14/2002 17:34'!dynamicVars	^dynamicVars! !!Process methodsFor: 'private' stamp: 'KenD 5/14/2002 17:34'!dynamicVars: aDict	dynamicVars := aDict.	^self! !!Process class methodsFor: 'accessing' stamp: 'KenD 5/14/2002 17:51'!activeProcess	^(ProcessorScheduler allSubInstances at: 1) activeProcess! !!Process class methodsFor: 'accessing' stamp: 'KenD 5/14/2002 17:52'!dynamicVars	^ self activeProcess dynamicVars! !!Process2 methodsFor: 'accessing' stamp: 'KenD 5/20/2002 14:26'!activeProcess	^(ProcessorScheduler allSubInstances at: 1) activeProcess! !!Process2 methodsFor: 'accessing' stamp: 'KenD 5/24/2002 10:30'!dynamicVars	(dynamicVars = nil)	ifTrue: [dynamicVars := Dictionary new].	^dynamicVars.! !!Process2 methodsFor: 'testing' stamp: 'ajh 2/14/2002 04:01'!isSuspended	"is self suspended, not waiting on a Semaphore, not queued to run, not even unwound (terminated), just hanging"	^ myList isNil and: [callStack notNil and: [callStack ~= 0]]  "If callStack were also nil then I would be terminated (not resumable, and therefore not merely suspended)"! !!Process2 methodsFor: 'printing' stamp: 'KenD 5/20/2002 14:25'!dynamicVars: newDict	dynamicVars := newDict.	^self! !!Process2 methodsFor: 'private' stamp: 'ajh 3/20/2002 17:18'!pvtSplitStackUnder: frame	"Split stack holding frame into two with frame being first on the new stack.  My behavior does not change (sender chain is maintained)."	| originalStack receiverPos newStack nextStack senderIpSpFp |	(senderIpSpFp _ frame senderIpSpFp) ifNil: [^ self].  "self is already first frame on its stack"	"Insert new stack in stack chain"	originalStack _ frame stack.	newStack _ CallStack newForInterpreter.	newStack privProcess: self.	newStack previousStack: originalStack.	(nextStack _ originalStack nextStack)		ifNil: [callStack _ newStack]		ifNotNil: [nextStack previousStack: newStack].	"Copy second half of stack to new stack"	receiverPos _ senderIpSpFp second.	receiverPos to: originalStack sp do: [:i | | obj |		newStack push: (obj _ originalStack at: i).		"Update moved active frame objects, including frame"		(obj class == MethodContext2 and: 		 [obj stack == originalStack and: 		 [obj frameIndex >= receiverPos]]) ifTrue: [			obj privStack: newStack index: obj frameIndex - receiverPos + 1].	].	newStack ip: originalStack ip.	newStack fp: originalStack fp - receiverPos + 1.	originalStack ip: senderIpSpFp first.	originalStack fp: senderIpSpFp third.	originalStack sp: receiverPos.	frame privSenderOnPreviousStack.! !!Process2 class methodsFor: 'accessing' stamp: 'KenD 5/20/2002 14:27'!activeProcess	^(ProcessorScheduler allSubInstances at: 1) activeProcess! !!Process2 class methodsFor: 'accessing' stamp: 'KenD 5/20/2002 14:27'!dynamicVars	^ self activeProcess dynamicVars! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/22/2002 19:18'!evalButtonAction	resultTextMorph setText: ''.	schemeSource := (evalTextMorph text) asString.	self evalResult: (schemeUserEnv eval: schemeSource).	resultTextMorph setText: evalResult.! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/18/2002 19:26'!evalButtonLabel	^'EVALuate'! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/18/2002 19:27'!evalButtonState        ^true! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/18/2002 19:21'!evalResult	^evalResult! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/18/2002 20:46'!evalResult: newText	evalResult := newText.! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/18/2002 19:37'!refreshWindow        "schemeSource color: Color white.        evalResult color: Color white."! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/18/2002 20:46'!schemeSource	^schemeSource! !!SchemeEvalWindow methodsFor: 'ui support' stamp: 'KenD 6/18/2002 20:46'!schemeSource: newText	schemeSource := newText.! !!SchemeEvalWindow methodsFor: 'instance creation' stamp: 'KenD 6/22/2002 11:51'!initialize	schemeUserEnv := SmallScheme newEnv.	schemeSource := '(define (fact N) ;; iterative factorial  (let loop ( (n N) (accumulator 1) )	(if (< n 2)		accumulator	    (loop (- n 1) (* n accumulator)))))'.	evalResult := ''.! !!SchemeEvalWindow methodsFor: 'instance creation' stamp: 'KenD 6/22/2002 11:55'!openAsMorph	"A Very Simple Scheme Eval Window"	"=== build the parts ... ==="	| topWindow evalButton |	Smalltalk isMorphic		ifFalse: [^ self open].	(topWindow _ SystemWindowWithButton labelled: 'SmallScheme') model: self.	evalButton _ PluggableButtonMorph				on: self				getState: #evalButtonState				action: #evalButtonAction				label: #evalButtonLabel.	evalButton onColor: (Color green) offColor: (Color green).	evalTextMorph _ PluggableTextMorph				on: self				text: #schemeSource				accept: #schemeSource:.	evalTextMorph setTextColor: Color blue.	resultTextMorph _ PluggableTextMorph				on: self				text: #evalResult				accept: nil.	"=== assemble the whole ... ==="     topWindow buttonInTitle: evalButton.	topWindow		addMorph: evalTextMorph		frame: (0.0 @ 0.0 extent: 1.0 @ 0.5).	topWindow		addMorph: resultTextMorph		frame: (0.0 @ 0.5 extent: 1.0 @ 0.5).	evalButton color: (Color green).	"=== open it ... ==="	topWindow openInWorldExtent: 400 @ 200.	self refreshWindow.	^ topWindow! !!SchemeEvalWindow class methodsFor: 'instance creation' stamp: 'KenD 6/18/2002 19:43'!open	"SchemeEvalWindow open"	| newWin |	newWin := SchemeEvalWindow new.	newWin initialize.	^newWin openAsMorph; yourself! !!SmallScheme methodsFor: 'private' stamp: 'KenD 5/26/2002 13:49'!defineOrSet: nameSymbol as: value 	"Unchecked. Used by TRACE"	userEnv at: nameSymbol put: value.	^ value! !!SmallScheme methodsFor: 'private' stamp: 'KenD 5/14/2002 18:44'!dynamicDefine: var as: val	| valueStack |	valueStack := (Process dynamicVars) at: var ifAbsent: [nil].	(valueStack isNil)	   ifTrue:  [(Process dynamicVars) at: var put: (Stack with: val).]	   ifFalse: [valueStack push: val].  "already defined"! !!SmallScheme methodsFor: 'private' stamp: 'KenD 5/14/2002 18:34'!dynamicPop: var	| valueStack | 	valueStack := (Process dynamicVars) at: var 				ifAbsent: [Error signal: 			 		  'Attempt to remove undefined dynamic variable: ' ,			 		  (var toSchemeIdentifier)].	(valueStack isEmpty)		ifTrue: [Error signal: 'Attempt to remove undefined dynamic variable: ' ,			 	   (var toSchemeIdentifier)].	^(valueStack pop)   "Note: typically ignored"! !!SmallScheme methodsFor: 'private' stamp: 'KenD 5/14/2002 18:46'!dynamicPush: var as: val	| valueStack |	valueStack := (Process dynamicVars) at: var ifAbsent: [nil].	(valueStack isNil)	   ifTrue:  [self dynamicDefine: var as: val.] "ignore the bug"	   ifFalse: [valueStack push: val].! !!SmallScheme methodsFor: 'private' stamp: 'KenD 5/14/2002 17:57'!dynamicRef: var withDefault: aBlock	| valueStack | 	"(Process dynamicVars) isNil ifTrue: [^(aBlock value)]. @@DEBUG@@"	valueStack := (Process dynamicVars) at: var 						 ifAbsent: [^(aBlock value)].	(valueStack isEmpty) ifTrue: [^(aBlock value)].	^(valueStack topValue) "last entry is most recent value".! !!SmallScheme methodsFor: 'private' stamp: 'KenD 5/14/2002 18:34'!dynamicSetX21: var as: newVal	"dynamicSet!!"	| valueStack |	valueStack := (Process dynamicVars) at: var 				ifAbsent: [Error signal: 			 		  'Attempt to access undefined dynamic variable: ' ,			 		  (var toSchemeIdentifier)].	(valueStack isEmpty)		ifTrue: [Error signal: 'Attempt to set!! undefined dynamic variable: ' ,			 	   (var toSchemeIdentifier)].	valueStack topValue: newVal.! !!SmallScheme methodsFor: 'eval' stamp: 'KenD 6/18/2002 13:38'!eval: aString	"aString is a Scheme expression"		^((self globalRef: #eval) value: aString value: self) asSchemeObjString.! !!SmallScheme methodsFor: 'accessing' stamp: 'KenD 5/28/2002 14:55'!define: nameSymbol as: value	userEnv at: nameSymbol put: value.	^value! !!SmallScheme methodsFor: 'accessing' stamp: 'KenD 5/16/2002 10:29'!globalRef: nameSymbol	^(userEnv at: nameSymbol	       ifAbsent: 		[R5RSEnv at: nameSymbol		 ifAbsent:			[Error signal: 'Undefined global name: ' , (nameSymbol asSchemeString)]])! !!SmallScheme methodsFor: 'accessing' stamp: 'KenD 5/16/2002 10:29'!setX21: nameSymbol as: value 	"Named must be DEFINEd before SET!!"	userEnv		at: nameSymbol		ifAbsent: [Error signal: 'Must DEFINE value before SET!!: ' , nameSymbol asSchemeString].	userEnv at: nameSymbol put: value.	^ value! !!SmallScheme methodsFor: 'instance creation' stamp: 'KenD 6/23/2002 16:42'!initialize	userEnv := Dictionary new.	"add tracing"	self trace. 	"add eval"	self initTranslator.	self eval.    	^self! !!SmallScheme methodsFor: 'user'!bootstrap1    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'gensym'  as: (  [ :counter |                       [ :stringX2DorX2Dsymbol |  [                 (counter := ((schemeEnv globalRef:  #'X2B')                      value: ( counter) value: ( 1))).                 ((schemeEnv globalRef:  #'stringX2DX3Esymbol')                      value: (((schemeEnv globalRef:  #'stringX2Dappend')                      value: ( (((((schemeEnv globalRef:  #'symbolX3F')                          value: ( stringX2DorX2Dsymbol))) == false) not)                     	ifTrue: [((schemeEnv globalRef:  #'symbolX2DX3Estring')                          value: ( stringX2DorX2Dsymbol))]                     	ifFalse: [ stringX2DorX2Dsymbol]) value: (((schemeEnv globalRef:  #'numberX2DX3Estring')                      value: ( counter)))))).                ] value].       ] valueWithArguments: {( 0). } ) . schemeEnv define:  #'baseX2Ddir'    "base-dir"  as: (  '/usr/local/src/Squeak/ProtoScheme/' ) . schemeEnv define:  #'sappend'  as: (  (schemeEnv globalRef:  #'stringX2Dappend')            ) . schemeEnv define:  #'scmX2Ddir'    "scm-dir"  as: ( ((schemeEnv globalRef:  #'sappend')            value: ( (schemeEnv globalRef:  #'baseX2Ddir')           ) value: ( 'scm/')) ) . schemeEnv define:  #'outX2Ddir'    "out-dir"  as: ( ((schemeEnv globalRef:  #'sappend')            value: ( (schemeEnv globalRef:  #'baseX2Ddir')           ) value: ( 'st/')) ) . schemeEnv define:  #'xlateX2DfromX2Dto'    "xlate-from-to"  as: (        [ :fileX2Dstem | ((schemeEnv globalRef:  #'xlateX2Dfile')                value: (((schemeEnv globalRef:  #'sappend')                value: ( (schemeEnv globalRef:  #'scmX2Ddir')               ) value: ( fileX2Dstem) value: ( '.scm'))) value: (((schemeEnv globalRef:  #'sappend')                value: ( (schemeEnv globalRef:  #'outX2Ddir')               ) value: ( fileX2Dstem) value: ( '.sts'))) value: ( fileX2Dstem))] ) . schemeEnv define:  #'xlateX2DlibraryX2DfromX2Dto'    "xlate-library-from-to"  as: (        [ :fileX2Dstem | ((schemeEnv globalRef:  #'xlateX2DlibraryX2Dfile')                value: (((schemeEnv globalRef:  #'sappend')                value: ( (schemeEnv globalRef:  #'scmX2Ddir')               ) value: ( fileX2Dstem) value: ( '.scm'))) value: (((schemeEnv globalRef:  #'sappend')                value: ( (schemeEnv globalRef:  #'outX2Ddir')               ) value: ( fileX2Dstem) value: ( '.sts'))) value: ( fileX2Dstem))] ) . schemeEnv define:  #'libraryX2DfileX2Dnames'    "library-file-names"  as: (  ({ 'numbers'.  'booleans'.  'lists'.  'symbols'.  'characters'.  'strings'.  'vectors'.  'control'.  'io'.  'eval'.  'ratize'.  'read'.  'string2number'.  'transcript'.  'format'.  'pretty-print'. } asRest) ) . schemeEnv define:  #'userX2DfileX2Dnames'    "user-file-names"  as: (  ({ 'trace'.  'xlate1'.  'xlate2'.  'xlate3'.  'test1'.  'test2'.  'test3'.  'test4'.  'test5'.  'test6'.  'test7'.  'test8'. } asRest) ) . schemeEnv define:  #'makeX2Dlib'    "make-lib"  as: (        [ [             ((schemeEnv globalRef:  #'forX2Deach')                  value: (             [ :baseX2Dfname |  [                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( 'Translating: ')).                   ((schemeEnv globalRef:  #'display')                        value: ( baseX2Dfname)).                   ((schemeEnv globalRef:  #'xlateX2DlibraryX2DfromX2Dto')                        value: ( baseX2Dfname)).                  ] value]) value: ( (schemeEnv globalRef:  #'libraryX2DfileX2Dnames')                 )).             ((schemeEnv globalRef:  #'newline')                  value).             ((schemeEnv globalRef:  #'display')                  value: ( '*=> Completed translating library files')).             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) . schemeEnv define:  #'makeX2Dtests'    "make-tests"  as: (        [ [             ((schemeEnv globalRef:  #'forX2Deach')                  value: (             [ :baseX2Dfname |  [                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( 'Translating: ')).                   ((schemeEnv globalRef:  #'display')                        value: ( baseX2Dfname)).                   ((schemeEnv globalRef:  #'xlateX2DfromX2Dto')                        value: ( baseX2Dfname)).                  ] value]) value: ( (schemeEnv globalRef:  #'userX2DfileX2Dnames')                 )).             ((schemeEnv globalRef:  #'newline')                  value).             ((schemeEnv globalRef:  #'display')                  value: ( '*=> Completed translating user|test files')).             ((schemeEnv globalRef:  #'newline')                  value).             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) . schemeEnv define:  #'makeX2Dall'    "make-all"  as: (        [ [             ((schemeEnv globalRef:  #'makeX2Dlib')                  value).             ((schemeEnv globalRef:  #'makeX2Dtests')                  value).            ] value] ) . schemeEnv define:  #'readX2Decho'    "read-echo"  as: (        [ :fileX2DnameX2Dstring | ((schemeEnv globalRef:  #'callX2DwithX2DinputX2Dfile')                value: ( fileX2DnameX2Dstring) value: (           [ :in |                 [ | loop |                    loop :=                    [ :form :count |                     (((((schemeEnv globalRef:  #'eofX2DobjectX3F')                            value: ( form))) == false) not)                       	ifTrue: [ #'done']                       	ifFalse: [ [                         ((schemeEnv globalRef:  #'newline')                              value).                         ((schemeEnv globalRef:  #'write')                              value: ( form)).                         (loop value: (((schemeEnv globalRef:  #'read')                              value: ( in))) value: (((schemeEnv globalRef:  #'X2B')                              value: ( count) value: ( 1)))).                        ] value]               ].               loop valueWithArguments: {                   ((schemeEnv globalRef:  #'read')                        value: ( in)).                     1. } ] value]))] ) .! !!SmallScheme methodsFor: 'user'!eval    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'eval'  as: (        [ :exp :envX2Dspec |            [ :stringX2Dport |              [ :schemeX2Dexp |                [ :stX2Dexp |                  (( ( Utilities evaluate: stX2Dexp in: nil to: nil)) value: ( envX2Dspec))               ] value: ( (((schemeEnv globalRef:  #'scheme2smalltalk')                    value: ( schemeX2Dexp) value: ( stringX2Dport)) contents))             ] value: ( (((((schemeEnv globalRef:  #'stringX3F')                      value: ( exp))) == false) not)                 	ifTrue: [ exp]                 	ifFalse: [ ( exp asSchemeObjString)])           ] value: (((schemeEnv globalRef:  #'openX2DoutputX2Dstring')                value))] ) . schemeEnv define:  #'schemeX2DreportX2Denvironment'    "scheme-report-environment"  as: (        [ :version |  ( SmallScheme newEnv)] ) . schemeEnv define:  #'nullX2Denvironment'    "null-environment"  as: (        [ :version |  ( SmallScheme newEnv)] ) . schemeEnv define:  #'interactionX2Denvironment'    "interaction-environment"  as: (        [ ( schemeEnv)] ) . schemeEnv define:  #'load'  as: (        [ :fileX2DnameX2Dstring | ((schemeEnv globalRef:  #'callX2DwithX2DinputX2Dfile')                value: ( fileX2DnameX2Dstring) value: (           [ :in |                 [ | loop |                    loop :=                    [ :form |                     (((((schemeEnv globalRef:  #'eofX2DobjectX3F')                            value: ( form))) == false) not)                       	ifTrue: [ fileX2DnameX2Dstring]                       	ifFalse: [ [                         ((schemeEnv globalRef:  #'eval')                              value: ( form) value: (((schemeEnv globalRef:  #'interactionX2Denvironment')                              value))).                         (loop value: (((schemeEnv globalRef:  #'read')                              value: ( in)))).                        ] value]               ].               loop valueWithArguments: {                   ((schemeEnv globalRef:  #'read')                        value: ( in)). } ] value]))] ) .! !!SmallScheme methodsFor: 'user' stamp: 'KenD 5/31/2002 08:41'!fileinTestSuite	"Reread library code from source files"	#( " 'test' " 'test1' 'test2' 'test3' 'test4' 'test5' 'test6' 'test7' 'test8')	do: [ :testName |		  (FileStream fileNamed: (LibraryDirPrefix , testName , '.sts')) fileIn].! !!SmallScheme methodsFor: 'user' stamp: 'KenD 6/11/2002 18:48'!fileinTranslator	"Reread xlate (Scheme->Smalltalk) code from source files"	#( 'xlate1' 'xlate2' 'xlate3')	do: [ :testName |		  (FileStream fileNamed: (LibraryDirPrefix , testName , '.sts')) fileIn].! !!SmallScheme methodsFor: 'user' stamp: 'KenD 6/11/2002 18:50'!initTranslator	"R5RS Scheme"	#( 'xlate1' 'xlate2' 'xlate3' )	do: [ :xlatePart |		  (self perform: (xlatePart asSymbol))].! !!SmallScheme methodsFor: 'user'!readTest    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'debugX2Dread'    "debug-read"  as: (        [ :fileX2DnameX2Dstring | ((schemeEnv globalRef:  #'callX2DwithX2DinputX2Dfile')                value: ( fileX2DnameX2Dstring) value: (           [ :in |  [                 ((schemeEnv globalRef:  #'newline')                      value).                 ((schemeEnv globalRef:  #'display')                      value: ( '** reading =====> ')).                 ((schemeEnv globalRef:  #'display')                      value: ( fileX2DnameX2Dstring)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' **')).                 ((schemeEnv globalRef:  #'newline')                      value).                                   [ | loop |                      loop :=                      [ :form |                       (((((schemeEnv globalRef:  #'eofX2DobjectX3F')                              value: ( form))) == false) not)                         	ifTrue: [ [                           ((schemeEnv globalRef:  #'newline')                                value).                           ((schemeEnv globalRef:  #'display')                                value: ( '** completed reading file ===== **')).                          ] value]                         	ifFalse: [ [                           ((schemeEnv globalRef:  #'newline')                                value).                           ((schemeEnv globalRef:  #'prettyX2Dprint')                                value: ( form)).                           (loop value: (((schemeEnv globalRef:  #'read')                                value: ( in)))).                          ] value]                 ].                 loop valueWithArguments: {                     ((schemeEnv globalRef:  #'read')                          value: ( in)). } ] value.                ] value]))] ) .((schemeEnv globalRef:  #'debugX2Dread')      value: ( '/usr/local/src/Squeak/ProtoScheme/scm/bootstrap.scm')).! !!SmallScheme methodsFor: 'user' stamp: 'KenD 5/31/2002 09:15'!runTestSuite	"R5RS Scheme"	Transcript open.	"self test."	#( 'test1' 'test2' 'test3' 'test4' 'test5' 'test6' 'test7' 'test8')	do: [ :testName |		  (self perform: (testName asSymbol))].	Transcript show: Character cr.! !!SmallScheme methodsFor: 'user'!test1    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 2) value: ( 1)). ({ #'X2B'.  #'X2D'.  #'X2EX2EX2E'.  #'X21X2EX2E'.  #'X24X2EX2B'.  #'X25X2EX2D'.  #'X26X2EX21'.  #'X2AX2EX3A'.  #'X2FX3AX2E'.  #'X3AX2BX2E'.  #'X3CX2DX2E'.  #'X3DX2E'.  #'X3EX2E'.  #'X3FX2E'.  #'X7EX2E'.  #'X5FX2E'.  #'X5EX2E'. } asRest).((schemeEnv globalRef:  #'section')      value: ( 3) value: ( 4)). schemeEnv define:  #'disjointX2DtypeX2Dfunctions'    "disjoint-type-functions"  as: ( ((schemeEnv globalRef:  #'list')                   valueWithArguments: {  (schemeEnv globalRef:  #'booleanX3F')           .  (schemeEnv globalRef:  #'charX3F')           .  (schemeEnv globalRef:  #'nullX3F')           .  (schemeEnv globalRef:  #'numberX3F')           .  (schemeEnv globalRef:  #'pairX3F')           .  (schemeEnv globalRef:  #'procedureX3F')           .  (schemeEnv globalRef:  #'stringX3F')           .  (schemeEnv globalRef:  #'symbolX3F')           .  (schemeEnv globalRef:  #'vectorX3F')           .}) ) . schemeEnv define:  #'typeX2Dexamples'    "type-examples"  as: ( ((schemeEnv globalRef:  #'list')                   valueWithArguments: {  true.  false.  $a.  nil.  9739.  ({ #'test'. } asRest).  (schemeEnv globalRef:  #'recordX2Derror')           .  'test'.  ''.  #'test'.  {}.  { #'a'.  #'b'.  #'c'. }.}) ) . schemeEnv define:  #'i'  as: (  1 ) .((schemeEnv globalRef:  #'forX2Deach')      value: ( [ :x |  [       ((schemeEnv globalRef:  #'display')            value: (((schemeEnv globalRef:  #'makeX2Dstring')            value: ( (schemeEnv globalRef:  #'i')           ) value: ( $ )))).       (schemeEnv setX21:  #'i' as: ((schemeEnv globalRef:  #'X2B')            value: ( 3) value: ( (schemeEnv globalRef:  #'i')           ))).       ((schemeEnv globalRef:  #'write')            value: ( x)).       ((schemeEnv globalRef:  #'newline')            value).      ] value]) value: ( (schemeEnv globalRef:  #'disjointX2DtypeX2Dfunctions')     )). schemeEnv define:  #'typeX2Dmatrix'    "type-matrix"  as: ( ((schemeEnv globalRef:  #'map')            value: (       [ :x |  [ :t |                 [                 ((schemeEnv globalRef:  #'write')                      value: ( t)).                 ((schemeEnv globalRef:  #'write')                      value: ( x)).                 ((schemeEnv globalRef:  #'newline')                      value).                  t.                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'map')                    value: (               [ :f | (f value: ( x))]) value: ( (schemeEnv globalRef:  #'disjointX2DtypeX2Dfunctions')                   ))). }]) value: ( (schemeEnv globalRef:  #'typeX2Dexamples')           )) ) .((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 1) value: ( 2)).((schemeEnv globalRef:  #'test')      value: ( ({ #'quote'.  #'a'. } asRest)) value: ( #'quote') value: ( ({ #'quote'.  #'a'. } asRest))).((schemeEnv globalRef:  #'test')      value: ( ({ #'quote'.  #'a'. } asRest)) value: ( #'quote') value: ( ({ #'quote'.  #'a'. } asRest))).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 1) value: ( 3)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  12.  ((( false) == false) not)     	ifTrue: [ (schemeEnv globalRef:  #'X2B')         ]     	ifFalse: [ (schemeEnv globalRef:  #'X2A')         ].  3.  4.}).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 1) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( 8) value: ( [ :x | ((schemeEnv globalRef:  #'X2B')          value: ( x) value: ( x))]) value: ( 4)). schemeEnv define:  #'reverseX2Dsubtract'    "reverse-subtract"  as: (        [ :x :y | ((schemeEnv globalRef:  #'X2D')                value: ( y) value: ( x))] ) .((schemeEnv globalRef:  #'test')       valueWithArguments: {  3.  (schemeEnv globalRef:  #'reverseX2Dsubtract')     .  7.  10.}). schemeEnv define:  #'add4'  as: (  [ :x |                       [ :y | ((schemeEnv globalRef:  #'X2B')                    value: ( x) value: ( y))].       ] valueWithArguments: {( 4). } ) .((schemeEnv globalRef:  #'test')      value: ( 10) value: ( (schemeEnv globalRef:  #'add4')     ) value: ( 6)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ 3.  4.  5.  6. } asRest).  [ :x |      x := x asRest.      x] withLastArgRest .  3.  4.  5.  6.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ 5.  6. } asRest).  [ :x :y :z |      z := z asRest.      z] withLastArgRest .  3.  4.  5.  6.}).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 1) value: ( 5)).((schemeEnv globalRef:  #'test')      value: ( #'yes') value: ( #'if') value: ( (((((schemeEnv globalRef:  #'X3E')          value: ( 3) value: ( 2))) == false) not)     	ifTrue: [ #'yes']     	ifFalse: [ #'no'])).((schemeEnv globalRef:  #'test')      value: ( #'no') value: ( #'if') value: ( (((((schemeEnv globalRef:  #'X3E')          value: ( 2) value: ( 3))) == false) not)     	ifTrue: [ #'yes']     	ifFalse: [ #'no'])).((schemeEnv globalRef:  #'test')      value: ( 1) value: ( #'if') value: ( (((((schemeEnv globalRef:  #'X3E')          value: ( 3) value: ( 2))) == false) not)     	ifTrue: [((schemeEnv globalRef:  #'X2D')          value: ( 3) value: ( 2))]     	ifFalse: [((schemeEnv globalRef:  #'X2B')          value: ( 3) value: ( 2))])).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 1) value: ( 6)). schemeEnv define:  #'x'  as: (  2 ) .((schemeEnv globalRef:  #'test')      value: ( 3) value: ( #'define') value: (((schemeEnv globalRef:  #'X2B')      value: ( (schemeEnv globalRef:  #'x')     ) value: ( 1)))).(schemeEnv setX21:  #'x' as:  4).((schemeEnv globalRef:  #'test')      value: ( 5) value: ( #'setX21') value: (((schemeEnv globalRef:  #'X2B')      value: ( (schemeEnv globalRef:  #'x')     ) value: ( 1)))).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 2) value: ( 1)).((schemeEnv globalRef:  #'test')      value: ( #'greater') value: ( #'cond') value: ( (((((schemeEnv globalRef:  #'X3E')          value: ( 3) value: ( 2))) == false) not)     	ifTrue: [ #'greater']     	ifFalse: [ (((((schemeEnv globalRef:  #'X3C')              value: ( 3) value: ( 2))) == false) not)         	ifTrue: [ #'less']         	ifFalse: [ 'Unspecified']])).((schemeEnv globalRef:  #'test')      value: ( #'equal') value: ( #'cond') value: ( (((((schemeEnv globalRef:  #'X3E')          value: ( 3) value: ( 3))) == false) not)     	ifTrue: [ #'greater']     	ifFalse: [ (((((schemeEnv globalRef:  #'X3C')              value: ( 3) value: ( 3))) == false) not)         	ifTrue: [ #'less']         	ifFalse: [ #'equal']])).((schemeEnv globalRef:  #'test')      value: ( 2) value: ( #'cond') value: ( [ :result96 |       ((( result96) == false) not)         	ifTrue: [((schemeEnv globalRef:  #'cadr')              value: ( result96))]         	ifFalse: [ false]. ] valueWithArguments: {(((schemeEnv globalRef:  #'assv')          value: ( #'b') value: ( ({ ({ #'a'.  1. } asRest).  ({ #'b'.  2. } asRest). } asRest)))). })).((schemeEnv globalRef:  #'test')      value: ( #'composite') value: ( #'case') value: ( [ :key97 |       (((((schemeEnv globalRef:  #'memv')              value: ( key97) value: ( ({ 2.  3.  5.  7. } asRest)))) == false) not)         	ifTrue: [ #'prime']         	ifFalse: [ [ :key98 |               (((((schemeEnv globalRef:  #'memv')                      value: ( key98) value: ( ({ 1.  4.  6.  8.  9. } asRest)))) == false) not)                 	ifTrue: [ #'composite']                 	ifFalse: [ key98].         ] valueWithArguments: {( key97). }]. ] valueWithArguments: {(((schemeEnv globalRef:  #'X2A')          value: ( 2) value: ( 3))). })).((schemeEnv globalRef:  #'test')      value: ( #'consonant') value: ( #'case') value: ( [ :key99 |       (((((schemeEnv globalRef:  #'memv')              value: ( key99) value: ( ({ #'a'.  #'e'.  #'i'.  #'o'.  #'u'. } asRest)))) == false) not)         	ifTrue: [ #'vowel']         	ifFalse: [ [ :key100 |               (((((schemeEnv globalRef:  #'memv')                      value: ( key100) value: ( ({ #'w'.  #'y'. } asRest)))) == false) not)                 	ifTrue: [ #'semivowel']                 	ifFalse: [ [                    key100.                    #'consonant'.                  ] value].         ] valueWithArguments: {( key99). }]. ] valueWithArguments: {(((schemeEnv globalRef:  #'car')          value: ( ({ #'c'.  #'d'. } asRest)))). })).((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'and') value: ( (((((schemeEnv globalRef:  #'X3D')          value: ( 2) value: ( 2))) == false) not)     	ifTrue: [((schemeEnv globalRef:  #'X3E')          value: ( 2) value: ( 1))]     	ifFalse: [ false])).((schemeEnv globalRef:  #'test')      value: ( false) value: ( #'and') value: ( (((((schemeEnv globalRef:  #'X3D')          value: ( 2) value: ( 2))) == false) not)     	ifTrue: [((schemeEnv globalRef:  #'X3C')          value: ( 2) value: ( 1))]     	ifFalse: [ false])).((schemeEnv globalRef:  #'test')      value: ( ({ #'f'.  #'g'. } asRest)) value: ( #'and') value: ( ((( 1) == false) not)     	ifTrue: [ ((( 2) == false) not)         	ifTrue: [ ((( #'c') == false) not)             	ifTrue: [ ({ #'f'.  #'g'. } asRest)]             	ifFalse: [ false]]         	ifFalse: [ false]]     	ifFalse: [ false])).((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'and') value: ( true)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'or') value: ( [ :temp101 |       ((( temp101) == false) not)         	ifTrue: [ temp101]         	ifFalse: [((schemeEnv globalRef:  #'X3E')              value: ( 2) value: ( 1))]. ] valueWithArguments: {(((schemeEnv globalRef:  #'X3D')          value: ( 2) value: ( 2))). })).((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'or') value: ( [ :temp102 |       ((( temp102) == false) not)         	ifTrue: [ temp102]         	ifFalse: [((schemeEnv globalRef:  #'X3C')              value: ( 2) value: ( 1))]. ] valueWithArguments: {(((schemeEnv globalRef:  #'X3D')          value: ( 2) value: ( 2))). })).((schemeEnv globalRef:  #'test')      value: ( false) value: ( #'or') value: ( [ :temp103 |       ((( temp103) == false) not)         	ifTrue: [ temp103]         	ifFalse: [ [ :temp104 |               ((( temp104) == false) not)                 	ifTrue: [ temp104]                 	ifFalse: [ false].         ] valueWithArguments: {( false). }]. ] valueWithArguments: {( false). })).((schemeEnv globalRef:  #'test')      value: ( false) value: ( #'or') value: ( false)).((schemeEnv globalRef:  #'test')      value: ( ({ #'b'.  #'c'. } asRest)) value: ( #'or') value: ( [ :temp105 |       ((( temp105) == false) not)         	ifTrue: [ temp105]         	ifFalse: [((schemeEnv globalRef:  #'X2B')              value: ( 3) value: ( 00))]. ] valueWithArguments: {(((schemeEnv globalRef:  #'memq')          value: ( #'b') value: ( ({ #'a'.  #'b'.  #'c'. } asRest)))). })).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 2) value: ( 2)).((schemeEnv globalRef:  #'test')      value: ( 6) value: ( #'let') value: ( [ :x :y |      ((schemeEnv globalRef:  #'X2A')          value: ( x) value: ( y)). ] valueWithArguments: {( 2). ( 3). })).((schemeEnv globalRef:  #'test')      value: ( 35) value: ( #'let') value: ( [ :x :y |       [ :x :z |          ((schemeEnv globalRef:  #'X2A')              value: ( z) value: ( x)).     ] valueWithArguments: {( 7). (((schemeEnv globalRef:  #'X2B')              value: ( x) value: ( y))). }. ] valueWithArguments: {( 2). ( 3). })).((schemeEnv globalRef:  #'test')      value: ( 70) value: ( #'letX2A') value: ( [ :x :y |           [ :x |        [ :z |          ((schemeEnv globalRef:  #'X2A')              value: ( z) value: ( x))       ] value: (((schemeEnv globalRef:  #'X2B')            value: ( x) value: ( y)))     ] value: ( 7). ] valueWithArguments: {( 2). ( 3). })).((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'letrec') value: (  [ | evenX3F oddX3F |     evenX3F := (   [ :n |  (((((schemeEnv globalRef:  #'zeroX3F')                value: ( n))) == false) not)           	ifTrue: [ true]           	ifFalse: [(oddX3F value: (((schemeEnv globalRef:  #'X2D')                value: ( n) value: ( 1))))]]).    oddX3F := (   [ :n |  (((((schemeEnv globalRef:  #'zeroX3F')                value: ( n))) == false) not)           	ifTrue: [ false]           	ifFalse: [(evenX3F value: (((schemeEnv globalRef:  #'X2D')                value: ( n) value: ( 1))))]]).     (evenX3F value: ( 88)). ] value)). schemeEnv define:  #'x'  as: (  34 ) .((schemeEnv globalRef:  #'test')      value: ( 5) value: ( #'let') value: ( [ :x |            [ | x |             x := ( 5).          x.     ] value. ] valueWithArguments: {( 3). })).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'let') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'test')      value: ( 6) value: ( #'let') value: ( [           [ | x |             x := ( 6).          x.     ] value. ] value)).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'let') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'test')      value: ( 7) value: ( #'letX2A') value: ( [ :x |        [ | x |         x := ( 7).        x.   ] value ] value: ( 3))).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'letX2A') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'test')      value: ( 8) value: ( #'letX2A') value: (   [ | x |     x := ( 8).      x. ] value)).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'letX2A') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'test')      value: ( 9) value: ( #'letrec') value: (  [ | |            [ | x |             x := ( 9).          x.     ] value. ] value)).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'letrec') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'test')      value: ( 10) value: ( #'letrec') value: (  [ | x |     x := ( 3).           [ | x |             x := ( 10).          x.     ] value. ] value)).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'letrec') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'reportX2Derrs')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!test2    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 2) value: ( 3)). schemeEnv define:  #'x'  as: (  00 ) .((schemeEnv globalRef:  #'test')      value: ( 6) value: ( #'begin') value: ( [   (schemeEnv setX21:  #'x' as:  5).   ((schemeEnv globalRef:  #'X2B')        value: ( (schemeEnv globalRef:  #'x')       ) value: ( 1)).  ] value)).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 2) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( { 00.  1.  2.  3.  4. }) value: ( #'do') value: (  [ | doX2Dloop106 |      doX2Dloop106 :=      [ :vec :i |       (((((schemeEnv globalRef:  #'X3D')              value: ( i) value: ( 5))) == false) not)         	ifTrue: [ vec]         	ifFalse: [ [           ((schemeEnv globalRef:  #'vectorX2DsetX21')                value: ( vec) value: ( i) value: ( i)).           (doX2Dloop106 value: ( vec) value: (((schemeEnv globalRef:  #'X2B')                value: ( i) value: ( 1)))).          ] value] ]. doX2Dloop106 valueWithArguments: {     ((schemeEnv globalRef:  #'makeX2Dvector')          value: ( 5)).       00. } ] value)).((schemeEnv globalRef:  #'test')      value: ( 25) value: ( #'do') value: ( [ :x |            [ | doX2Dloop107 |          doX2Dloop107 :=          [ :x :sum |           (((((schemeEnv globalRef:  #'nullX3F')                  value: ( x))) == false) not)             	ifTrue: [ sum]             	ifFalse: [(doX2Dloop107 value: (((schemeEnv globalRef:  #'cdr')                  value: ( x))) value: (((schemeEnv globalRef:  #'X2B')                  value: ( sum) value: (((schemeEnv globalRef:  #'car')                  value: ( x))))))]     ].     doX2Dloop107 valueWithArguments: {          x.           00. } ] value. ] valueWithArguments: {( ({ 1.  3.  5.  7.  9. } asRest)). })).((schemeEnv globalRef:  #'test')      value: ( 1) value: ( #'let') value: (  [ | foo |      foo :=      [      1 ]. foo valueWithArguments: {} ] value)).((schemeEnv globalRef:  #'test')      value: ( ({ ({ 6.  1.  3. } asRest).  ({ -5.  -2. } asRest). } asRest)) value: ( #'let') value: (  [ | loop |      loop :=      [ :numbers :nonneg :neg |       (((((schemeEnv globalRef:  #'nullX3F')              value: ( numbers))) == false) not)         	ifTrue: [((schemeEnv globalRef:  #'list')              value: ( nonneg) value: ( neg))]         	ifFalse: [ (((((schemeEnv globalRef:  #'negativeX3F')                  value: (((schemeEnv globalRef:  #'car')                  value: ( numbers))))) == false) not)             	ifTrue: [(loop value: (((schemeEnv globalRef:  #'cdr')                  value: ( numbers))) value: ( nonneg) value: (((schemeEnv globalRef:  #'cons')                  value: (((schemeEnv globalRef:  #'car')                  value: ( numbers))) value: ( neg))))]             	ifFalse: [(loop value: (((schemeEnv globalRef:  #'cdr')                  value: ( numbers))) value: (((schemeEnv globalRef:  #'cons')                  value: (((schemeEnv globalRef:  #'car')                  value: ( numbers))) value: ( nonneg))) value: ( neg))]] ]. loop valueWithArguments: {      ({ 3.  -2.  1.  6.  -5. } asRest).       nil.       nil. } ] value)).((schemeEnv globalRef:  #'section')      value: ( 4) value: ( 2) value: ( 6)).((schemeEnv globalRef:  #'test')      value: ( ({ #'list'.  3.  4. } asRest)) value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'cons')      value: ( #'list') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'X2B')      value: ( 1) value: ( 2))) value: (((schemeEnv globalRef:  #'cons')      value: ( 4) value: ( nil)))))))).((schemeEnv globalRef:  #'test')      value: ( ({ #'list'.  #'a'.  ({ #'quote'.  #'a'. } asRest). } asRest)) value: ( #'quasiquote') value: ( [ :name |      ((schemeEnv globalRef:  #'cons')          value: ( #'list') value: (((schemeEnv globalRef:  #'cons')          value: ( name) value: (((schemeEnv globalRef:  #'cons')          value: (((schemeEnv globalRef:  #'cons')          value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')          value: ( name) value: ( nil))))) value: ( nil)))))). ] valueWithArguments: {( #'a'). })).((schemeEnv globalRef:  #'test')      value: ( ({ #'a'.  3.  4.  5.  6.  #'b'. } asRest)) value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'cons')      value: ( #'a') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'X2B')      value: ( 1) value: ( 2))) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')      value: (((schemeEnv globalRef:  #'map')      value: ( (schemeEnv globalRef:  #'abs')     ) value: ( ({ 4.  -5.  6. } asRest)))) value: (((schemeEnv globalRef:  #'cons')      value: ( #'b') value: ( nil)))))))))).((schemeEnv globalRef:  #'test')      value: ( (Pair car:  ({ #'foo'.  7. } asRest) cdr:  #'cons')) value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'cons')      value: ( #'foo') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'X2D')      value: ( 10) value: ( 3))) value: ( nil))))) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')      value: (((schemeEnv globalRef:  #'cdr')      value: ( ({ #'c'. } asRest)))) value: (((schemeEnv globalRef:  #'car')      value: ( ({ #'cons'. } asRest))))))))). schemeEnv define:  #'sqt'  as: (        [ :x |             [ | doX2Dloop108 |                doX2Dloop108 :=                [ :i |                 (((((schemeEnv globalRef:  #'X3E')                        value: (((schemeEnv globalRef:  #'X2A')                        value: ( i) value: ( i))) value: ( x))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'X2D')                        value: ( i) value: ( 1))]                   	ifFalse: [(doX2Dloop108 value: (((schemeEnv globalRef:  #'X2B')                        value: ( i) value: ( 1))))]           ].           doX2Dloop108 valueWithArguments: {                00. } ] value] ) .((schemeEnv globalRef:  #'test')      value: ( { 10.  5.  2.  4.  3.  8. }) value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'listX2DX3Evector')      value: (((schemeEnv globalRef:  #'cons')      value: ( 10) value: (((schemeEnv globalRef:  #'cons')      value: ( 5) value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'sqt')      value: ( 4))) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')      value: (((schemeEnv globalRef:  #'map')      value: ( (schemeEnv globalRef:  #'sqt')     ) value: ( ({ 16.  9. } asRest)))) value: (((schemeEnv globalRef:  #'cons')      value: ( 8) value: ( nil)))))))))))))).((schemeEnv globalRef:  #'test')      value: ( 5) value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'X2B')      value: ( 2) value: ( 3)))).((schemeEnv globalRef:  #'test')      value: ( ({ #'a'.  ({ #'quasiquote'.  ({ #'b'.  ({ #'unquote'.  ({ #'X2B'.  1.  2. } asRest). } asRest).  ({ #'unquote'.  ({ #'foo'.  4.  #'d'. } asRest). } asRest).  #'e'. } asRest). } asRest).  #'f'. } asRest)) value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'cons')      value: ( #'a') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'cons')      value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'cons')      value: ( #'b') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'cons')      value: ( #'unquote') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'cons')      value: ( #'X2B') value: (((schemeEnv globalRef:  #'cons')      value: ( 1) value: (((schemeEnv globalRef:  #'cons')      value: ( 2) value: ( nil))))))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'cons')      value: ( #'unquote') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'cons')      value: ( #'foo') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'X2B')      value: ( 1) value: ( 3))) value: (((schemeEnv globalRef:  #'cons')      value: ( #'d') value: ( nil))))))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')      value: ( #'e') value: ( nil))))))))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')      value: ( #'f') value: ( nil)))))))).((schemeEnv globalRef:  #'test')      value: ( ({ #'a'.  ({ #'quasiquote'.  ({ #'b'.  ({ #'unquote'.  #'x'. } asRest).  ({ #'unquote'.  ({ #'quote'.  #'y'. } asRest). } asRest).  #'d'. } asRest). } asRest).  #'e'. } asRest)) value: ( #'quasiquote') value: ( [ :name1 :name2 |      ((schemeEnv globalRef:  #'cons')          value: ( #'a') value: (((schemeEnv globalRef:  #'cons')          value: (((schemeEnv globalRef:  #'cons')          value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'cons')          value: (((schemeEnv globalRef:  #'cons')          value: ( #'b') value: (((schemeEnv globalRef:  #'cons')          value: (((schemeEnv globalRef:  #'cons')          value: ( #'unquote') value: (((schemeEnv globalRef:  #'cons')          value: ( name1) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')          value: (((schemeEnv globalRef:  #'cons')          value: ( #'unquote') value: (((schemeEnv globalRef:  #'cons')          value: (((schemeEnv globalRef:  #'cons')          value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')          value: ( name2) value: ( nil))))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')          value: ( #'d') value: ( nil))))))))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')          value: ( #'e') value: ( nil)))))). ] valueWithArguments: {( #'x'). ( #'y'). })).((schemeEnv globalRef:  #'test')      value: ( ({ #'list'.  3.  4. } asRest)) value: ( #'quasiquote') value: (((schemeEnv globalRef:  #'cons')      value: ( #'list') value: (((schemeEnv globalRef:  #'cons')      value: (((schemeEnv globalRef:  #'X2B')      value: ( 1) value: ( 2))) value: (((schemeEnv globalRef:  #'cons')      value: ( 4) value: ( nil)))))))).((schemeEnv globalRef:  #'test')      value: ( ({ #'quasiquote'.  ({ #'list'.  ({ #'unquote'.  ({ #'X2B'.  1.  2. } asRest). } asRest).  4. } asRest). } asRest)) value: ( #'quasiquote') value: ( ({ #'quasiquote'.  ({ #'list'.  ({ #'unquote'.  ({ #'X2B'.  1.  2. } asRest). } asRest).  4. } asRest). } asRest))).((schemeEnv globalRef:  #'section')      value: ( 5) value: ( 2) value: ( 1)). schemeEnv define:  #'add3'  as: (        [ :x | ((schemeEnv globalRef:  #'X2B')                value: ( x) value: ( 3))] ) .((schemeEnv globalRef:  #'test')      value: ( 6) value: ( #'define') value: (((schemeEnv globalRef:  #'add3')      value: ( 3)))). schemeEnv define:  #'first'  as: (  (schemeEnv globalRef:  #'car')            ) .((schemeEnv globalRef:  #'test')      value: ( 1) value: ( #'define') value: (((schemeEnv globalRef:  #'first')      value: ( ({ 1.  2. } asRest))))).((schemeEnv globalRef:  #'section')      value: ( 5) value: ( 2) value: ( 2)).((schemeEnv globalRef:  #'test')      value: ( 45) value: ( #'define') value: ( [ :x |            [ | foo bar |             foo := (       [ :y | (bar value: ( x) value: ( y))]).        bar := (       [ :a :b | ((schemeEnv globalRef:  #'X2B')                value: (((schemeEnv globalRef:  #'X2A')                value: ( a) value: ( b))) value: ( a))]).         (foo value: (((schemeEnv globalRef:  #'X2B')              value: ( x) value: ( 3)))).     ] value. ] valueWithArguments: {( 5). })). schemeEnv define:  #'x'  as: (  34 ) . schemeEnv define:  #'foo'  as: (        [            [ | x |                         x := ( 5).                x.           ] value] ) .((schemeEnv globalRef:  #'test')      value: ( 5) value: ( (schemeEnv globalRef:  #'foo')     )).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'define') value: ( (schemeEnv globalRef:  #'x')     )). schemeEnv define:  #'foo'  as: (        [            [ | x |                         x := ( 5).                x.           ] value] ) .((schemeEnv globalRef:  #'test')      value: ( 5) value: ( (schemeEnv globalRef:  #'foo')     )).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'define') value: ( (schemeEnv globalRef:  #'x')     )). schemeEnv define:  #'foo'  as: (        [ :x |  [             ((             [                  [ | x |                                     x := ( 5).                      x.                 ] value]) value).              x.            ] value] ) .((schemeEnv globalRef:  #'test')      value: ( 88) value: ( (schemeEnv globalRef:  #'foo')     ) value: ( 88)).((schemeEnv globalRef:  #'test')      value: ( 4) value: ( (schemeEnv globalRef:  #'foo')     ) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( 34) value: ( #'define') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'reportX2Derrs')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!test3    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 1)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'not')     ) value: ( true)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'not')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'not')     ) value: (((schemeEnv globalRef:  #'list')      value: ( 3)))).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'not')     ) value: ( false)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'not')     ) value: ( nil)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'not')     ) value: (((schemeEnv globalRef:  #'list')      value))).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'not')     ) value: ( #'nil')).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'booleanX3F')     ) value: ( false)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'booleanX3F')     ) value: ( 00)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'booleanX3F')     ) value: ( nil)).((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 2)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')     .  #'a'.  #'a'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'eqvX3F')     .  #'a'.  #'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')     .  2.  2.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')     .  nil.  nil.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')     .  10000.  10000.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'eqvX3F')     . ((schemeEnv globalRef:  #'cons')      value: ( 1) value: ( 2)). ((schemeEnv globalRef:  #'cons')      value: ( 1) value: ( 2)).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'eqvX3F')     .  [ 1].  [ 2].}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'eqvX3F')     .  false.  #'nil'.}). [ :p |      ((schemeEnv globalRef:  #'test')               valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')         .  p.  p.}). ] valueWithArguments: {(     [ :x |  x]). }. schemeEnv define:  #'genX2Dcounter'    "gen-counter"  as: (        [ [ :n |                               [ [                     (n := ((schemeEnv globalRef:  #'X2B')                          value: ( n) value: ( 1))).                      n.                    ] value].           ] valueWithArguments: {( 00). }] ) . [ :g |      ((schemeEnv globalRef:  #'test')               valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')         .  g.  g.}). ] valueWithArguments: {(((schemeEnv globalRef:  #'genX2Dcounter')          value)). }.((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'eqvX3F')     . ((schemeEnv globalRef:  #'genX2Dcounter')      value). ((schemeEnv globalRef:  #'genX2Dcounter')      value).}).  [ | f g |     f := (   [ (((((schemeEnv globalRef:  #'eqvX3F')                value: ( f) value: ( g))) == false) not)           	ifTrue: [ #'f']           	ifFalse: [ #'both']]).    g := (   [ (((((schemeEnv globalRef:  #'eqvX3F')                value: ( f) value: ( g))) == false) not)           	ifTrue: [ #'g']           	ifFalse: [ #'both']]).     ((schemeEnv globalRef:  #'test')               valueWithArguments: {  false.  (schemeEnv globalRef:  #'eqvX3F')         .  f.  g.}). ] value.((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqX3F')     .  #'a'.  #'a'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'eqX3F')     . ((schemeEnv globalRef:  #'list')      value: ( #'a')). ((schemeEnv globalRef:  #'list')      value: ( #'a')).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqX3F')     .  nil.  nil.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqX3F')     .  (schemeEnv globalRef:  #'car')     .  (schemeEnv globalRef:  #'car')     .}). [ :x |      ((schemeEnv globalRef:  #'test')               valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqX3F')         .  x.  x.}). ] valueWithArguments: {( ({ #'a'. } asRest)). }. [ :x |      ((schemeEnv globalRef:  #'test')               valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqX3F')         .  x.  x.}). ] valueWithArguments: {( {}). }. [ :x |      ((schemeEnv globalRef:  #'test')               valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqX3F')         .  x.  x.}). ] valueWithArguments: {(     [ :x |  x]). }.((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'equalX3F')     .  #'a'.  #'a'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'equalX3F')     .  ({ #'a'. } asRest).  ({ #'a'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'equalX3F')     .  ({ #'a'.  ({ #'b'. } asRest).  #'c'. } asRest).  ({ #'a'.  ({ #'b'. } asRest).  #'c'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'equalX3F')     .  'abc'.  'abc'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'equalX3F')     .  2.  2.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'equalX3F')     . ((schemeEnv globalRef:  #'makeX2Dvector')      value: ( 5) value: ( #'a')). ((schemeEnv globalRef:  #'makeX2Dvector')      value: ( 5) value: ( #'a')).}).((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( ({ #'a'.  #'b'.  #'c'.  #'d'.  #'e'. } asRest)) value: ( #'dot') value: ( ({ #'a'.  #'b'.  #'c'.  #'d'.  #'e'. } asRest))). schemeEnv define:  #'x'  as: ( ((schemeEnv globalRef:  #'list')            value: ( #'a') value: ( #'b') value: ( #'c')) ) . schemeEnv define:  #'y'  as: (  (schemeEnv globalRef:  #'x')            ) . ((( (schemeEnv globalRef:  #'listX3F')         ) == false) not)     	ifTrue: [((schemeEnv globalRef:  #'test')          value: ( true) value: ( (schemeEnv globalRef:  #'listX3F')         ) value: ( (schemeEnv globalRef:  #'y')         ))]     	ifFalse: [ false].((schemeEnv globalRef:  #'setX2DcdrX21')      value: ( (schemeEnv globalRef:  #'x')     ) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( (Pair car:  #'a' cdr:  4)) value: ( #'setX2DcdrX21') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')     .  (schemeEnv globalRef:  #'x')     .  (schemeEnv globalRef:  #'y')     .}).((schemeEnv globalRef:  #'test')      value: ( (Pair car:  #'a' cdr:  (Pair car:  #'b' cdr:  (Pair car:  #'c' cdr:  #'d')))) value: ( #'dot') value: ( (Pair car:  #'a' cdr:  (Pair car:  #'b' cdr:  (Pair car:  #'c' cdr:  #'d'))))). ((( (schemeEnv globalRef:  #'listX3F')         ) == false) not)     	ifTrue: [((schemeEnv globalRef:  #'test')          value: ( false) value: ( (schemeEnv globalRef:  #'listX3F')         ) value: ( (schemeEnv globalRef:  #'y')         ))]     	ifFalse: [ false]. ((( (schemeEnv globalRef:  #'listX3F')         ) == false) not)     	ifTrue: [ [ :x |           [           ((schemeEnv globalRef:  #'setX2DcdrX21')                value: ( x) value: ( x)).           ((schemeEnv globalRef:  #'test')                value: ( false) value: ( #'listX3F') value: (((schemeEnv globalRef:  #'listX3F')                value: ( x)))).          ] value.     ] valueWithArguments: {(((schemeEnv globalRef:  #'list')              value: ( #'a'))). }]     	ifFalse: [ false].((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'pairX3F')     ) value: ( (Pair car:  #'a' cdr:  #'b'))).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'pairX3F')     ) value: ( (Pair car:  #'a' cdr:  1))).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'pairX3F')     ) value: ( ({ #'a'.  #'b'.  #'c'. } asRest))).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'pairX3F')     ) value: ( nil)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'pairX3F')     ) value: ( { #'a'.  #'b'. })).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'a'. } asRest).  (schemeEnv globalRef:  #'cons')     .  #'a'.  nil.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ ({ #'a'. } asRest).  #'b'.  #'c'.  #'d'. } asRest).  (schemeEnv globalRef:  #'cons')     .  ({ #'a'. } asRest).  ({ #'b'.  #'c'.  #'d'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ 'a'.  #'b'.  #'c'. } asRest).  (schemeEnv globalRef:  #'cons')     .  'a'.  ({ #'b'.  #'c'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  (Pair car:  #'a' cdr:  3).  (schemeEnv globalRef:  #'cons')     .  #'a'.  3.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  (Pair car:  ({ #'a'.  #'b'. } asRest) cdr:  #'c').  (schemeEnv globalRef:  #'cons')     .  ({ #'a'.  #'b'. } asRest).  #'c'.}).((schemeEnv globalRef:  #'test')      value: ( #'a') value: ( (schemeEnv globalRef:  #'car')     ) value: ( ({ #'a'.  #'b'.  #'c'. } asRest))).((schemeEnv globalRef:  #'test')      value: ( ({ #'a'. } asRest)) value: ( (schemeEnv globalRef:  #'car')     ) value: ( ({ ({ #'a'. } asRest).  #'b'.  #'c'.  #'d'. } asRest))).((schemeEnv globalRef:  #'test')      value: ( 1) value: ( (schemeEnv globalRef:  #'car')     ) value: ( (Pair car:  1 cdr:  2))).((schemeEnv globalRef:  #'test')      value: ( ({ #'b'.  #'c'.  #'d'. } asRest)) value: ( (schemeEnv globalRef:  #'cdr')     ) value: ( ({ ({ #'a'. } asRest).  #'b'.  #'c'.  #'d'. } asRest))).((schemeEnv globalRef:  #'test')      value: ( 2) value: ( (schemeEnv globalRef:  #'cdr')     ) value: ( (Pair car:  1 cdr:  2))).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'a'.  7.  #'c'. } asRest).  (schemeEnv globalRef:  #'list')     .  #'a'. ((schemeEnv globalRef:  #'X2B')      value: ( 3) value: ( 4)).  #'c'.}).((schemeEnv globalRef:  #'test')      value: ( nil) value: ( (schemeEnv globalRef:  #'list')     )).((schemeEnv globalRef:  #'test')      value: ( 3) value: ( (schemeEnv globalRef:  #'length')     ) value: ( ({ #'a'.  #'b'.  #'c'. } asRest))).((schemeEnv globalRef:  #'test')      value: ( 3) value: ( (schemeEnv globalRef:  #'length')     ) value: ( ({ #'a'.  ({ #'b'. } asRest).  ({ #'c'.  #'d'.  #'e'. } asRest). } asRest))).((schemeEnv globalRef:  #'test')      value: ( 00) value: ( (schemeEnv globalRef:  #'length')     ) value: ( nil)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'x'.  #'y'. } asRest).  (schemeEnv globalRef:  #'append')     .  ({ #'x'. } asRest).  ({ #'y'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'a'.  #'b'.  #'c'.  #'d'. } asRest).  (schemeEnv globalRef:  #'append')     .  ({ #'a'. } asRest).  ({ #'b'.  #'c'.  #'d'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'a'.  ({ #'b'. } asRest).  ({ #'c'. } asRest). } asRest).  (schemeEnv globalRef:  #'append')     .  ({ #'a'.  ({ #'b'. } asRest). } asRest).  ({ ({ #'c'. } asRest). } asRest).}).((schemeEnv globalRef:  #'test')      value: ( nil) value: ( (schemeEnv globalRef:  #'append')     )).((schemeEnv globalRef:  #'test')       valueWithArguments: {  (Pair car:  #'a' cdr:  (Pair car:  #'b' cdr:  (Pair car:  #'c' cdr:  #'d'))).  (schemeEnv globalRef:  #'append')     .  ({ #'a'.  #'b'. } asRest).  (Pair car:  #'c' cdr:  #'d').}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  #'a'.  (schemeEnv globalRef:  #'append')     .  nil.  #'a'.}).((schemeEnv globalRef:  #'test')      value: ( ({ #'c'.  #'b'.  #'a'. } asRest)) value: ( (schemeEnv globalRef:  #'reverse')     ) value: ( ({ #'a'.  #'b'.  #'c'. } asRest))).((schemeEnv globalRef:  #'test')      value: ( ({ ({ #'e'.  ({ #'f'. } asRest). } asRest).  #'d'.  ({ #'b'.  #'c'. } asRest).  #'a'. } asRest)) value: ( (schemeEnv globalRef:  #'reverse')     ) value: ( ({ #'a'.  ({ #'b'.  #'c'. } asRest).  #'d'.  ({ #'e'.  ({ #'f'. } asRest). } asRest). } asRest))).((schemeEnv globalRef:  #'test')       valueWithArguments: {  #'c'.  (schemeEnv globalRef:  #'listX2Dref')     .  ({ #'a'.  #'b'.  #'c'.  #'d'. } asRest).  2.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'a'.  #'b'.  #'c'. } asRest).  (schemeEnv globalRef:  #'memq')     .  #'a'.  ({ #'a'.  #'b'.  #'c'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'b'.  #'c'. } asRest).  (schemeEnv globalRef:  #'memq')     .  #'b'.  ({ #'a'.  #'b'.  #'c'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'memq')     .  #'a'.  ({ #'b'.  #'c'.  #'d'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'memq')     . ((schemeEnv globalRef:  #'list')      value: ( #'a')).  ({ #'b'.  ({ #'a'. } asRest).  #'c'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ ({ #'a'. } asRest).  #'c'. } asRest).  (schemeEnv globalRef:  #'member')     . ((schemeEnv globalRef:  #'list')      value: ( #'a')).  ({ #'b'.  ({ #'a'. } asRest).  #'c'. } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ 101.  102. } asRest).  (schemeEnv globalRef:  #'memv')     .  101.  ({ 100.  101.  102. } asRest).}). schemeEnv define:  #'e'  as: (  ({ ({ #'a'.  1. } asRest).  ({ #'b'.  2. } asRest).  ({ #'c'.  3. } asRest). } asRest) ) .((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'a'.  1. } asRest).  (schemeEnv globalRef:  #'assq')     .  #'a'.  (schemeEnv globalRef:  #'e')     .}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'b'.  2. } asRest).  (schemeEnv globalRef:  #'assq')     .  #'b'.  (schemeEnv globalRef:  #'e')     .}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'assq')     .  #'d'.  (schemeEnv globalRef:  #'e')     .}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'assq')     . ((schemeEnv globalRef:  #'list')      value: ( #'a')).  ({ ({ ({ #'a'. } asRest). } asRest).  ({ ({ #'b'. } asRest). } asRest).  ({ ({ #'c'. } asRest). } asRest). } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ ({ #'a'. } asRest). } asRest).  (schemeEnv globalRef:  #'assoc')     . ((schemeEnv globalRef:  #'list')      value: ( #'a')).  ({ ({ ({ #'a'. } asRest). } asRest).  ({ ({ #'b'. } asRest). } asRest).  ({ ({ #'c'. } asRest). } asRest). } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ 5.  7. } asRest).  (schemeEnv globalRef:  #'assv')     .  5.  ({ ({ 2.  3. } asRest).  ({ 5.  7. } asRest).  ({ 11.  13. } asRest). } asRest).}).((schemeEnv globalRef:  #'reportX2Derrs')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!test4    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'symbolX3F')     ) value: ( #'foo')).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'symbolX3F')     ) value: (((schemeEnv globalRef:  #'car')      value: ( ({ #'a'.  #'b'. } asRest))))).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'symbolX3F')     ) value: ( 'bar')).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'symbolX3F')     ) value: ( #'nil')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'symbolX3F')     ) value: ( nil)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'symbolX3F')     ) value: ( false)). schemeEnv define:  #'charX2DstandardX2Dcase'    "char-standard-case"  as: (  (schemeEnv globalRef:  #'charX2Dupcase')            ) . (((((schemeEnv globalRef:  #'stringX3DX3F')          value: (((schemeEnv globalRef:  #'symbolX2DX3Estring')          value: ( #'a'))) value: ( 'a'))) == false) not)     	ifTrue: [(schemeEnv setX21:  #'charX2DstandardX2Dcase' as:  (schemeEnv globalRef:  #'charX2Ddowncase')         )].((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'standardX2Dcase') value: (((schemeEnv globalRef:  #'stringX3DX3F')      value: (((schemeEnv globalRef:  #'symbolX2DX3Estring')      value: ( #'a'))) value: (((schemeEnv globalRef:  #'symbolX2DX3Estring')      value: ( #'a')))))).((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'standardX2Dcase') value: ( [ :temp109 |       ((( temp109) == false) not)         	ifTrue: [ temp109]         	ifFalse: [((schemeEnv globalRef:  #'stringX3DX3F')              value: (((schemeEnv globalRef:  #'symbolX2DX3Estring')              value: ( #'a'))) value: ( 'a'))]. ] valueWithArguments: {(((schemeEnv globalRef:  #'stringX3DX3F')          value: (((schemeEnv globalRef:  #'symbolX2DX3Estring')          value: ( #'a'))) value: ( 'A'))). })). schemeEnv define:  #'strX2Dcopy'    "str-copy"  as: (        [ :s |  [ :v |                                [ | doX2Dloop110 |                    doX2Dloop110 :=                    [ :i |                     (((((schemeEnv globalRef:  #'X3C')                            value: ( i) value: ( 00))) == false) not)                       	ifTrue: [ v]                       	ifFalse: [ [                         ((schemeEnv globalRef:  #'stringX2DsetX21')                              value: ( v) value: ( i) value: (((schemeEnv globalRef:  #'stringX2Dref')                              value: ( s) value: ( i)))).                         (doX2Dloop110 value: (((schemeEnv globalRef:  #'X2D')                              value: ( i) value: ( 1)))).                        ] value]               ].               doX2Dloop110 valueWithArguments: {                   ((schemeEnv globalRef:  #'X2D')                        value: (((schemeEnv globalRef:  #'stringX2Dlength')                        value: ( v))) value: ( 1)). } ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'makeX2Dstring')                    value: (((schemeEnv globalRef:  #'stringX2Dlength')                    value: ( s))))). }] ) . schemeEnv define:  #'stringX2DstandardX2Dcase'    "string-standard-case"  as: (        [ :s |  [             (s := ((schemeEnv globalRef:  #'strX2Dcopy')                  value: ( s))).                           [ | doX2Dloop111 |                  doX2Dloop111 :=                  [ :i :sl |                   (((((schemeEnv globalRef:  #'X3EX3D')                          value: ( i) value: ( sl))) == false) not)                     	ifTrue: [ s]                     	ifFalse: [ [                       ((schemeEnv globalRef:  #'stringX2DsetX21')                            value: ( s) value: ( i) value: (((schemeEnv globalRef:  #'charX2DstandardX2Dcase')                            value: (((schemeEnv globalRef:  #'stringX2Dref')                            value: ( s) value: ( i)))))).                       (doX2Dloop111 value: (((schemeEnv globalRef:  #'X2B')                            value: ( 1) value: ( i))) value: ( sl)).                      ] value]             ].             doX2Dloop111 valueWithArguments: {                  00.                  ((schemeEnv globalRef:  #'stringX2Dlength')                      value: ( s)). } ] value.            ] value] ) .((schemeEnv globalRef:  #'test')      value: (((schemeEnv globalRef:  #'stringX2DstandardX2Dcase')      value: ( 'flying-fish'))) value: ( (schemeEnv globalRef:  #'symbolX2DX3Estring')     ) value: ( #'flyingX2Dfish')).((schemeEnv globalRef:  #'test')      value: (((schemeEnv globalRef:  #'stringX2DstandardX2Dcase')      value: ( 'martin'))) value: ( (schemeEnv globalRef:  #'symbolX2DX3Estring')     ) value: ( #'martin')).((schemeEnv globalRef:  #'test')      value: ( 'Malvina') value: ( (schemeEnv globalRef:  #'symbolX2DX3Estring')     ) value: (((schemeEnv globalRef:  #'stringX2DX3Esymbol')      value: ( 'Malvina')))).((schemeEnv globalRef:  #'test')      value: ( true) value: ( #'standardX2Dcase') value: (((schemeEnv globalRef:  #'eqX3F')      value: ( #'a') value: ( #'a')))). schemeEnv define:  #'x'  as: ( ((schemeEnv globalRef:  #'listX2DX3Estring')            value: (((schemeEnv globalRef:  #'list')            value: ( $a) value: ( $b)))) ) . schemeEnv define:  #'y'  as: ( ((schemeEnv globalRef:  #'stringX2DX3Esymbol')            value: ( (schemeEnv globalRef:  #'x')           )) ) .((schemeEnv globalRef:  #'stringX2DsetX21')      value: ( (schemeEnv globalRef:  #'x')     ) value: ( 00) value: ( $c)).((schemeEnv globalRef:  #'test')      value: ( 'cb') value: ( #'stringX2DsetX21') value: ( (schemeEnv globalRef:  #'x')     )).((schemeEnv globalRef:  #'test')      value: ( 'ab') value: ( (schemeEnv globalRef:  #'symbolX2DX3Estring')     ) value: ( (schemeEnv globalRef:  #'y')     )).((schemeEnv globalRef:  #'test')      value: ( (schemeEnv globalRef:  #'y')     ) value: ( (schemeEnv globalRef:  #'stringX2DX3Esymbol')     ) value: ( 'ab')).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqX3F')     .  #'mississippi'.  #'mississippi'.}).((schemeEnv globalRef:  #'test')      value: ( false) value: ( #'stringX2DX3Esymbol') value: (((schemeEnv globalRef:  #'eqX3F')      value: ( #'bitblt') value: (((schemeEnv globalRef:  #'stringX2DX3Esymbol')      value: ( 'bitBlt')))))).((schemeEnv globalRef:  #'test')      value: ( #'jollywog') value: ( (schemeEnv globalRef:  #'stringX2DX3Esymbol')     ) value: (((schemeEnv globalRef:  #'symbolX2DX3Estring')      value: ( #'jollywog')))).((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 5) value: ( 5)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'numberX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'complexX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'realX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'rationalX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'reportX2Derrs')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!test5    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 5) value: ( 5)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'numberX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'complexX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'realX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'rationalX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'integerX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'exactX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'inexactX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3D')     .  22.  22.  22.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3D')     .  22.  22.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'X3D')     .  34.  34.  35.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'X3D')     .  34.  35.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3E')     .  3.  -6246.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'X3E')     .  9.  9.  -2424.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3EX3D')     .  3.  -4.  -6246.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3EX3D')     .  9.  9.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'X3EX3D')     .  8.  9.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3C')     .  -1.  2.  3.  4.  5.  6.  7.  8.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'X3C')     .  -1.  2.  3.  4.  4.  5.  6.  7.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3CX3D')     .  -1.  2.  3.  4.  5.  6.  7.  8.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'X3CX3D')     .  -1.  2.  3.  4.  4.  5.  6.  7.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'X3C')     .  1.  3.  2.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'X3EX3D')     .  1.  3.  2.}).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'zeroX3F')     ) value: ( 00)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'zeroX3F')     ) value: ( 1)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'zeroX3F')     ) value: ( -1)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'zeroX3F')     ) value: ( -100)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'positiveX3F')     ) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'positiveX3F')     ) value: ( -4)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'positiveX3F')     ) value: ( 00)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'negativeX3F')     ) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'negativeX3F')     ) value: ( -4)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'negativeX3F')     ) value: ( 00)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'oddX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'oddX3F')     ) value: ( 2)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'oddX3F')     ) value: ( -4)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'oddX3F')     ) value: ( -1)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'evenX3F')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'evenX3F')     ) value: ( 2)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'evenX3F')     ) value: ( -4)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'evenX3F')     ) value: ( -1)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  38.  (schemeEnv globalRef:  #'max')     .  34.  5.  7.  38.  6.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -24.  (schemeEnv globalRef:  #'min')     .  3.  5.  5.  330.  4.  -24.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  7.  (schemeEnv globalRef:  #'X2B')     .  3.  4.}).((schemeEnv globalRef:  #'test')      value: ( 3) value: ( (schemeEnv globalRef:  #'X2B')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( 00) value: ( (schemeEnv globalRef:  #'X2B')     )).((schemeEnv globalRef:  #'test')      value: ( 4) value: ( (schemeEnv globalRef:  #'X2A')     ) value: ( 4)).((schemeEnv globalRef:  #'test')      value: ( 1) value: ( (schemeEnv globalRef:  #'X2A')     )).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -1.  (schemeEnv globalRef:  #'X2D')     .  3.  4.}).((schemeEnv globalRef:  #'test')      value: ( -3) value: ( (schemeEnv globalRef:  #'X2D')     ) value: ( 3)).((schemeEnv globalRef:  #'test')      value: ( 7) value: ( (schemeEnv globalRef:  #'abs')     ) value: ( -7)).((schemeEnv globalRef:  #'test')      value: ( 7) value: ( (schemeEnv globalRef:  #'abs')     ) value: ( 7)).((schemeEnv globalRef:  #'test')      value: ( 00) value: ( (schemeEnv globalRef:  #'abs')     ) value: ( 00)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  5.  (schemeEnv globalRef:  #'quotient')     .  35.  7.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -5.  (schemeEnv globalRef:  #'quotient')     .  -35.  7.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -5.  (schemeEnv globalRef:  #'quotient')     .  35.  -7.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  5.  (schemeEnv globalRef:  #'quotient')     .  -35.  -7.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  1.  (schemeEnv globalRef:  #'modulo')     .  13.  4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  1.  (schemeEnv globalRef:  #'remainder')     .  13.  4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  3.  (schemeEnv globalRef:  #'modulo')     .  -13.  4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -1.  (schemeEnv globalRef:  #'remainder')     .  -13.  4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -3.  (schemeEnv globalRef:  #'modulo')     .  13.  -4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  1.  (schemeEnv globalRef:  #'remainder')     .  13.  -4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -1.  (schemeEnv globalRef:  #'modulo')     .  -13.  -4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  -1.  (schemeEnv globalRef:  #'remainder')     .  -13.  -4.}). schemeEnv define:  #'divtest'  as: (        [ :n1 :n2 | ((schemeEnv globalRef:  #'X3D')                value: ( n1) value: (((schemeEnv globalRef:  #'X2B')                value: (((schemeEnv globalRef:  #'X2A')                value: ( n2) value: (((schemeEnv globalRef:  #'quotient')                value: ( n1) value: ( n2))))) value: (((schemeEnv globalRef:  #'remainder')                value: ( n1) value: ( n2))))))] ) .((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'divtest')     .  238.  9.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'divtest')     .  -238.  9.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'divtest')     .  238.  -9.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'divtest')     .  -238.  -9.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  4.  (schemeEnv globalRef:  #'gcd')     .  00.  4.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  4.  (schemeEnv globalRef:  #'gcd')     .  -4.  00.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  4.  (schemeEnv globalRef:  #'gcd')     .  32.  -36.}).((schemeEnv globalRef:  #'test')      value: ( 00) value: ( (schemeEnv globalRef:  #'gcd')     )).((schemeEnv globalRef:  #'test')       valueWithArguments: {  288.  (schemeEnv globalRef:  #'lcm')     .  32.  -36.}).((schemeEnv globalRef:  #'test')      value: ( 1) value: ( (schemeEnv globalRef:  #'lcm')     )). schemeEnv define:  #'testX2Dinexact'    "test-inexact"  as: (        [            [ | f3X2E9 f4X2E0 fX2D3X2E25 fX2E25 f4X2E5 f3X2E5 f0X2E0 f0X2E8 f1X2E0 wto dto lto |                         f3X2E9 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '3.9'))).              f4X2E0 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '4.0'))).              fX2D3X2E25 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '-3.25'))).              fX2E25 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '.25'))).              f4X2E5 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '4.5'))).              f3X2E5 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '3.5'))).              f0X2E0 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '0.0'))).              f0X2E8 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '0.8'))).              f1X2E0 := (((schemeEnv globalRef:  #'stringX2DX3Enumber')                  value: ( '1.0'))).              wto := ( (schemeEnv globalRef:  #'writeX2DtestX2Dobj')                 ).              dto := ( (schemeEnv globalRef:  #'displayX2DtestX2Dobj')                 ).              lto := ( (schemeEnv globalRef:  #'loadX2DtestX2Dobj')                 ).                [                 ((schemeEnv globalRef:  #'newline')                      value).                 ((schemeEnv globalRef:  #'display')                      value: ( ';testing inexact numbers; ')).                 ((schemeEnv globalRef:  #'newline')                      value).                 ((schemeEnv globalRef:  #'section')                      value: ( 6) value: ( 5) value: ( 5)).                 ((schemeEnv globalRef:  #'test')                      value: ( true) value: ( (schemeEnv globalRef:  #'inexactX3F')                     ) value: ( f3X2E9)).                 ((schemeEnv globalRef:  #'test')                      value: ( true) value: ( #'inexactX3F') value: (((schemeEnv globalRef:  #'inexactX3F')                      value: (((schemeEnv globalRef:  #'max')                      value: ( f3X2E9) value: ( 4)))))).                 ((schemeEnv globalRef:  #'test')                      value: ( f4X2E0) value: ( #'max') value: (((schemeEnv globalRef:  #'max')                      value: ( f3X2E9) value: ( 4)))).                 ((schemeEnv globalRef:  #'test')                      value: ( f4X2E0) value: ( #'exactX2DX3Einexact') value: (((schemeEnv globalRef:  #'exactX2DX3Einexact')                      value: ( 4)))).                 ((schemeEnv globalRef:  #'test')                      value: (((schemeEnv globalRef:  #'X2D')                      value: ( f4X2E0))) value: ( (schemeEnv globalRef:  #'round')                     ) value: (((schemeEnv globalRef:  #'X2D')                      value: ( f4X2E5)))).                 ((schemeEnv globalRef:  #'test')                      value: (((schemeEnv globalRef:  #'X2D')                      value: ( f4X2E0))) value: ( (schemeEnv globalRef:  #'round')                     ) value: (((schemeEnv globalRef:  #'X2D')                      value: ( f3X2E5)))).                 ((schemeEnv globalRef:  #'test')                      value: (((schemeEnv globalRef:  #'X2D')                      value: ( f4X2E0))) value: ( (schemeEnv globalRef:  #'round')                     ) value: (((schemeEnv globalRef:  #'X2D')                      value: ( f3X2E9)))).                 ((schemeEnv globalRef:  #'test')                      value: ( f0X2E0) value: ( (schemeEnv globalRef:  #'round')                     ) value: ( f0X2E0)).                 ((schemeEnv globalRef:  #'test')                      value: ( f0X2E0) value: ( (schemeEnv globalRef:  #'round')                     ) value: ( fX2E25)).                 ((schemeEnv globalRef:  #'test')                      value: ( f1X2E0) value: ( (schemeEnv globalRef:  #'round')                     ) value: ( f0X2E8)).                 ((schemeEnv globalRef:  #'test')                      value: ( f4X2E0) value: ( (schemeEnv globalRef:  #'round')                     ) value: ( f3X2E5)).                 ((schemeEnv globalRef:  #'test')                      value: ( f4X2E0) value: ( (schemeEnv globalRef:  #'round')                     ) value: ( f4X2E5)).                 (schemeEnv setX21:  #'writeX2DtestX2Dobj' as: ((schemeEnv globalRef:  #'list')                      value: ( fX2E25) value: ( fX2D3X2E25))).                 (schemeEnv setX21:  #'displayX2DtestX2Dobj' as: ((schemeEnv globalRef:  #'list')                      value: ( fX2E25) value: ( fX2D3X2E25))).                 (schemeEnv setX21:  #'loadX2DtestX2Dobj' as: ((schemeEnv globalRef:  #'list')                      value: ( #'define') value: ( #'foo') value: (((schemeEnv globalRef:  #'list')                      value: ( #'quote') value: ( (schemeEnv globalRef:  #'writeX2DtestX2Dobj')                     ))))).                 ((schemeEnv globalRef:  #'test')                                       valueWithArguments: {  true.  (schemeEnv globalRef:  #'callX2DwithX2DoutputX2Dfile')                     .  'tmp3'.                  [ :testX2Dfile |  [                       ((schemeEnv globalRef:  #'writeX2Dchar')                            value: ( $;) value: ( testX2Dfile)).                       ((schemeEnv globalRef:  #'display')                            value: ( (schemeEnv globalRef:  #'writeX2DtestX2Dobj')                           ) value: ( testX2Dfile)).                       ((schemeEnv globalRef:  #'newline')                            value: ( testX2Dfile)).                       ((schemeEnv globalRef:  #'write')                            value: ( (schemeEnv globalRef:  #'loadX2DtestX2Dobj')                           ) value: ( testX2Dfile)).                       ((schemeEnv globalRef:  #'outputX2DportX3F')                            value: ( testX2Dfile)).                      ] value].}).                 ((schemeEnv globalRef:  #'checkX2DtestX2Dfile')                      value: ( 'tmp3')).                 (schemeEnv setX21:  #'writeX2DtestX2Dobj' as:  wto).                 (schemeEnv setX21:  #'displayX2DtestX2Dobj' as:  dto).                 (schemeEnv setX21:  #'loadX2DtestX2Dobj' as:  lto).                  [ :x :y |                      ((schemeEnv globalRef:  #'test')                          value: ( true) value: ( #'pentiumX2DfdivX2Dbug') value: (((schemeEnv globalRef:  #'X3E')                          value: ( f1X2E0) value: (((schemeEnv globalRef:  #'X2D')                          value: ( x) value: (((schemeEnv globalRef:  #'X2A')                          value: (((schemeEnv globalRef:  #'X2F')                          value: ( x) value: ( y))) value: ( y)))))))).                 ] valueWithArguments: {(((schemeEnv globalRef:  #'stringX2DX3Enumber')                          value: ( '4195835.0'))). (((schemeEnv globalRef:  #'stringX2DX3Enumber')                          value: ( '3145727.0'))). }.                 ((schemeEnv globalRef:  #'reportX2Derrs')                      value).                ] value.           ] value] ) . schemeEnv define:  #'testX2Dbignum'    "test-bignum"  as: (        [            [ | tb |                         tb := (             [ :n1 :n2 | ((schemeEnv globalRef:  #'X3D')                      value: ( n1) value: (((schemeEnv globalRef:  #'X2B')                      value: (((schemeEnv globalRef:  #'X2A')                      value: ( n2) value: (((schemeEnv globalRef:  #'quotient')                      value: ( n1) value: ( n2))))) value: (((schemeEnv globalRef:  #'remainder')                      value: ( n1) value: ( n2))))))]).                [                 ((schemeEnv globalRef:  #'newline')                      value).                 ((schemeEnv globalRef:  #'display')                      value: ( ';testing bignums; ')).                 ((schemeEnv globalRef:  #'newline')                      value).                 ((schemeEnv globalRef:  #'section')                      value: ( 6) value: ( 5) value: ( 5)).                 ((schemeEnv globalRef:  #'test')                                       valueWithArguments: {  00.  (schemeEnv globalRef:  #'modulo')                     .  -2177452800.  86400.}).                 ((schemeEnv globalRef:  #'test')                                       valueWithArguments: {  00.  (schemeEnv globalRef:  #'modulo')                     .  2177452800.  -86400.}).                 ((schemeEnv globalRef:  #'test')                                       valueWithArguments: {  00.  (schemeEnv globalRef:  #'modulo')                     .  2177452800.  86400.}).                 ((schemeEnv globalRef:  #'test')                                       valueWithArguments: {  00.  (schemeEnv globalRef:  #'modulo')                     .  -2177452800.  -86400.}).                 ((schemeEnv globalRef:  #'test')                      value: ( true) value: ( #'remainder') value: ((tb value: ( 281474976710655) value: ( 65535)))).                 ((schemeEnv globalRef:  #'test')                      value: ( true) value: ( #'remainder') value: ((tb value: ( 281474976710654) value: ( 65535)))).                 ((schemeEnv globalRef:  #'section')                      value: ( 6) value: ( 5) value: ( 6)).                 ((schemeEnv globalRef:  #'test')                      value: ( 281474976710655) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')                     ) value: ( '281474976710655')).                 ((schemeEnv globalRef:  #'test')                      value: ( '281474976710655') value: ( (schemeEnv globalRef:  #'numberX2DX3Estring')                     ) value: ( 281474976710655)).                 ((schemeEnv globalRef:  #'reportX2Derrs')                      value).                ] value.           ] value] ) .((schemeEnv globalRef:  #'reportX2Derrs')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!test6    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 5) value: ( 6)).((schemeEnv globalRef:  #'test')      value: ( '0') value: ( (schemeEnv globalRef:  #'numberX2DX3Estring')     ) value: ( 00)).((schemeEnv globalRef:  #'test')      value: ( '100') value: ( (schemeEnv globalRef:  #'numberX2DX3Estring')     ) value: ( 100)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  '100'.  (schemeEnv globalRef:  #'numberX2DX3Estring')     .  256.  16.}).((schemeEnv globalRef:  #'test')      value: ( 100) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '100')).((schemeEnv globalRef:  #'test')       valueWithArguments: {  256.  (schemeEnv globalRef:  #'stringX2DX3Enumber')     .  '100'.  16.}).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '.')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( 'd')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( 'D')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( 'i')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( 'I')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '3i')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '3I')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '33i')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '33I')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '3.3i')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '3.3I')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '-')).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'stringX2DX3Enumber')     ) value: ( '+')).((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 6)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')     .  $ .  $ .}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'eqvX3F')     .  $ .  $ .}).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX3F')     ) value: ( $a)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX3F')     ) value: ( $()).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX3F')     ) value: ( $ )).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX3F')     ) value: ((Character cr))).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3DX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3DX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3DX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3DX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3CX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3CX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3CX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3CX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3EX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3EX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3EX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3EX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3CX3DX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3CX3DX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3CX3DX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3CX3DX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3EX3DX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX3EX3DX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3EX3DX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX3EX3DX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3DX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3DX3F')     .  $a.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3DX3F')     .  $A.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3DX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3DX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3DX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3DX3F')     .  $A.  $a.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3F')     .  $a.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3F')     .  $A.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3CX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3CX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3CX3F')     .  $A.  $a.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3F')     .  $a.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3F')     .  $A.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3EX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3F')     .  $A.  $a.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3DX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3DX3F')     .  $a.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3DX3F')     .  $A.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3DX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3CX3DX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3DX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3CX3DX3F')     .  $A.  $a.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3DX3F')     .  $A.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3DX3F')     .  $a.  $B.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3DX3F')     .  $A.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'charX2DciX3EX3DX3F')     .  $a.  $b.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3EX3DX3F')     .  $9.  $0.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3EX3DX3F')     .  $A.  $A.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'charX2DciX3EX3DX3F')     .  $A.  $a.}).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $a)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $A)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $z)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $Z)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $0)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $9)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $ )).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DalphabeticX3F')     ) value: ( $;)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $a)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $A)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $z)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $Z)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $0)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $9)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $ )).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DnumericX3F')     ) value: ( $;)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $a)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $A)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $z)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $Z)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $0)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $9)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $ )).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DwhitespaceX3F')     ) value: ( $;)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DupperX2DcaseX3F')     ) value: ( $0)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DupperX2DcaseX3F')     ) value: ( $9)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DupperX2DcaseX3F')     ) value: ( $ )).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DupperX2DcaseX3F')     ) value: ( $;)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DlowerX2DcaseX3F')     ) value: ( $0)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DlowerX2DcaseX3F')     ) value: ( $9)).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DlowerX2DcaseX3F')     ) value: ( $ )).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'charX2DlowerX2DcaseX3F')     ) value: ( $;)).((schemeEnv globalRef:  #'test')      value: ( $.) value: ( (schemeEnv globalRef:  #'integerX2DX3Echar')     ) value: (((schemeEnv globalRef:  #'charX2DX3Einteger')      value: ( $.)))).((schemeEnv globalRef:  #'test')      value: ( $A) value: ( (schemeEnv globalRef:  #'integerX2DX3Echar')     ) value: (((schemeEnv globalRef:  #'charX2DX3Einteger')      value: ( $A)))).((schemeEnv globalRef:  #'test')      value: ( $a) value: ( (schemeEnv globalRef:  #'integerX2DX3Echar')     ) value: (((schemeEnv globalRef:  #'charX2DX3Einteger')      value: ( $a)))).((schemeEnv globalRef:  #'test')      value: ( $A) value: ( (schemeEnv globalRef:  #'charX2Dupcase')     ) value: ( $A)).((schemeEnv globalRef:  #'test')      value: ( $A) value: ( (schemeEnv globalRef:  #'charX2Dupcase')     ) value: ( $a)).((schemeEnv globalRef:  #'test')      value: ( $a) value: ( (schemeEnv globalRef:  #'charX2Ddowncase')     ) value: ( $A)).((schemeEnv globalRef:  #'test')      value: ( $a) value: ( (schemeEnv globalRef:  #'charX2Ddowncase')     ) value: ( $a)).((schemeEnv globalRef:  #'reportX2Derrs')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!test7    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 7)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'stringX3F')     ) value: ( 'The word "recursion\" has many meanings.')).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'stringX3F')     ) value: ( '')). schemeEnv define:  #'f'  as: ( ((schemeEnv globalRef:  #'makeX2Dstring')            value: ( 3) value: ( $*)) ) .((schemeEnv globalRef:  #'test')      value: ( '?**') value: ( #'stringX2DsetX21') value: ( [   ((schemeEnv globalRef:  #'stringX2DsetX21')        value: ( (schemeEnv globalRef:  #'f')       ) value: ( 00) value: ( $?)).    (schemeEnv globalRef:  #'f')       .  ] value)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  'abc'.  (schemeEnv globalRef:  #'string')     .  $a.  $b.  $c.}).((schemeEnv globalRef:  #'test')      value: ( '') value: ( (schemeEnv globalRef:  #'string')     )).((schemeEnv globalRef:  #'test')      value: ( 3) value: ( (schemeEnv globalRef:  #'stringX2Dlength')     ) value: ( 'abc')).((schemeEnv globalRef:  #'test')       valueWithArguments: {  $a.  (schemeEnv globalRef:  #'stringX2Dref')     .  'abc'.  00.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  $c.  (schemeEnv globalRef:  #'stringX2Dref')     .  'abc'.  2.}).((schemeEnv globalRef:  #'test')      value: ( 00) value: ( (schemeEnv globalRef:  #'stringX2Dlength')     ) value: ( '')).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ''.  (schemeEnv globalRef:  #'substring')     .  'ab'.  00.  00.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ''.  (schemeEnv globalRef:  #'substring')     .  'ab'.  1.  1.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ''.  (schemeEnv globalRef:  #'substring')     .  'ab'.  2.  2.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  'a'.  (schemeEnv globalRef:  #'substring')     .  'ab'.  00.  1.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  'b'.  (schemeEnv globalRef:  #'substring')     .  'ab'.  1.  2.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  'ab'.  (schemeEnv globalRef:  #'substring')     .  'ab'.  00.  2.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  'foobar'.  (schemeEnv globalRef:  #'stringX2Dappend')     .  'foo'.  'bar'.}).((schemeEnv globalRef:  #'test')      value: ( 'foo') value: ( (schemeEnv globalRef:  #'stringX2Dappend')     ) value: ( 'foo')).((schemeEnv globalRef:  #'test')       valueWithArguments: {  'foo'.  (schemeEnv globalRef:  #'stringX2Dappend')     .  'foo'.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  'foo'.  (schemeEnv globalRef:  #'stringX2Dappend')     .  ''.  'foo'.}).((schemeEnv globalRef:  #'test')      value: ( '') value: ( (schemeEnv globalRef:  #'stringX2Dappend')     )).((schemeEnv globalRef:  #'test')      value: ( '') value: ( (schemeEnv globalRef:  #'makeX2Dstring')     ) value: ( 00)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3DX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3CX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3EX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3CX3DX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3EX3DX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  ''.  ''.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3DX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3DX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3DX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3DX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3CX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3CX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3CX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3CX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3EX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3EX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3EX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3EX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3CX3DX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3CX3DX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3CX3DX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3CX3DX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3EX3DX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX3EX3DX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3EX3DX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX3EX3DX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  'a'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  'A'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3DX3F')     .  'A'.  'a'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  'a'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  'A'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3CX3F')     .  'A'.  'a'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  'a'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  'A'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3F')     .  'A'.  'a'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  'a'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  'A'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3CX3DX3F')     .  'A'.  'a'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  'A'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  'a'.  'B'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  'A'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  false.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  'a'.  'b'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  '9'.  '0'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  'A'.  'A'.}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'stringX2DciX3EX3DX3F')     .  'A'.  'a'.}).((schemeEnv globalRef:  #'reportX2Derrs')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!test8    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'curX2Dsection'    "cur-section"  as: (  nil ) . schemeEnv define:  #'errs'  as: (  nil ) . schemeEnv define:  #'section'  as: (        [ :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'display')                  value: ( 'SECTION')).             ((schemeEnv globalRef:  #'write')                  value: ( args)).             ((schemeEnv globalRef:  #'newline')                  value).             (schemeEnv setX21:  #'curX2Dsection' as:  args).              true.            ] value] withLastArgRest  ) . schemeEnv define:  #'recordX2Derror'    "record-error"  as: (        [ :e | (schemeEnv setX21:  #'errs' as: ((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'list')                value: ( (schemeEnv globalRef:  #'curX2Dsection')               ) value: ( e))) value: ( (schemeEnv globalRef:  #'errs')               )))] ) . schemeEnv define:  #'test'  as: (        [ :expect :fun :args |            args := args asRest.            [             ((schemeEnv globalRef:  #'write')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( fun) value: ( args)))).             ((schemeEnv globalRef:  #'display')                  value: ( '  ==> ')).             ((             [ :res |  [                   ((schemeEnv globalRef:  #'write')                        value: ( res)).                   ((schemeEnv globalRef:  #'newline')                        value).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( expect) value: ( res))))) == false) not)                       	ifTrue: [ [                         ((schemeEnv globalRef:  #'recordX2Derror')                              value: (((schemeEnv globalRef:  #'list')                              value: ( res) value: ( expect) value: (((schemeEnv globalRef:  #'cons')                              value: ( fun) value: ( args)))))).                         ((schemeEnv globalRef:  #'display')                              value: ( ' BUT EXPECTED ')).                         ((schemeEnv globalRef:  #'write')                              value: ( expect)).                         ((schemeEnv globalRef:  #'newline')                              value).                          false.                        ] value]                       	ifFalse: [ true].                  ] value]) value: ( (((((schemeEnv globalRef:  #'procedureX3F')                      value: ( fun))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'apply')                      value: ( fun) value: ( args))]                 	ifFalse: [((schemeEnv globalRef:  #'car')                      value: ( args))])).            ] value] withLastArgRest  ) . schemeEnv define:  #'reportX2Derrs'    "report-errs"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).              (((((schemeEnv globalRef:  #'nullX3F')                      value: ( (schemeEnv globalRef:  #'errs')                     ))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( 'Passed all tests'))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'display')                        value: ( 'errors were:')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'display')                        value: ( '(SECTION (got expected (call)))')).                   ((schemeEnv globalRef:  #'newline')                        value).                   ((schemeEnv globalRef:  #'forX2Deach')                        value: (                   [ :l |  [                         ((schemeEnv globalRef:  #'write')                              value: ( l)).                         ((schemeEnv globalRef:  #'newline')                              value).                        ] value]) value: ( (schemeEnv globalRef:  #'errs')                       )).                  ] value].             ((schemeEnv globalRef:  #'newline')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 8)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'vectorX3F')     ) value: ( { 00.  ({ 2.  2.  2.  2. } asRest).  'Anna'. })).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'vectorX3F')     ) value: ( {})).((schemeEnv globalRef:  #'test')       valueWithArguments: {  { #'a'.  #'b'.  #'c'. }.  (schemeEnv globalRef:  #'vector')     .  #'a'.  #'b'.  #'c'.}).((schemeEnv globalRef:  #'test')      value: ( {}) value: ( (schemeEnv globalRef:  #'vector')     )).((schemeEnv globalRef:  #'test')      value: ( 3) value: ( (schemeEnv globalRef:  #'vectorX2Dlength')     ) value: ( { 00.  ({ 2.  2.  2.  2. } asRest).  'Anna'. })).((schemeEnv globalRef:  #'test')      value: ( 00) value: ( (schemeEnv globalRef:  #'vectorX2Dlength')     ) value: ( {})).((schemeEnv globalRef:  #'test')       valueWithArguments: {  8.  (schemeEnv globalRef:  #'vectorX2Dref')     .  { 1.  1.  2.  3.  5.  8.  13.  21. }.  5.}).((schemeEnv globalRef:  #'test')      value: ( { 00.  ({ 'Sue'.  'Sue'. } asRest).  'Anna'. }) value: ( #'vectorX2Dset') value: ( [ :vec |       [       ((schemeEnv globalRef:  #'vectorX2DsetX21')            value: ( vec) value: ( 1) value: ( ({ 'Sue'.  'Sue'. } asRest))).        vec.      ] value. ] valueWithArguments: {(((schemeEnv globalRef:  #'listX2DX3Evector')          value: (((schemeEnv globalRef:  #'list')          value: ( 00) value: ( ({ 2.  2.  2.  2. } asRest)) value: ( 'Anna'))))). })).((schemeEnv globalRef:  #'test')       valueWithArguments: {  { #'hi'.  #'hi'. }.  (schemeEnv globalRef:  #'makeX2Dvector')     .  2.  #'hi'.}).((schemeEnv globalRef:  #'test')      value: ( {}) value: ( (schemeEnv globalRef:  #'makeX2Dvector')     ) value: ( 00)).((schemeEnv globalRef:  #'test')       valueWithArguments: {  {}.  (schemeEnv globalRef:  #'makeX2Dvector')     .  00.  #'a'.}).((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 9)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'procedureX3F')     ) value: ( (schemeEnv globalRef:  #'car')     )).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'procedureX3F')     ) value: ( #'car')).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'procedureX3F')     ) value: ( [ :x | ((schemeEnv globalRef:  #'X2A')          value: ( x) value: ( x))])).((schemeEnv globalRef:  #'test')      value: ( false) value: ( (schemeEnv globalRef:  #'procedureX3F')     ) value: ( ({ #'lambda'.  ({ #'x'. } asRest).  ({ #'X2A'.  #'x'.  #'x'. } asRest). } asRest))).((schemeEnv globalRef:  #'test')       valueWithArguments: {  7.  (schemeEnv globalRef:  #'apply')     .  (schemeEnv globalRef:  #'X2B')     . ((schemeEnv globalRef:  #'list')      value: ( 3) value: ( 4)).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  7.  (schemeEnv globalRef:  #'apply')     .  [ :a :b | ((schemeEnv globalRef:  #'X2B')          value: ( a) value: ( b))]. ((schemeEnv globalRef:  #'list')      value: ( 3) value: ( 4)).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  17.  (schemeEnv globalRef:  #'apply')     .  (schemeEnv globalRef:  #'X2B')     .  10. ((schemeEnv globalRef:  #'list')      value: ( 3) value: ( 4)).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  nil.  (schemeEnv globalRef:  #'apply')     .  (schemeEnv globalRef:  #'list')     .  nil.}). schemeEnv define:  #'compose'  as: (        [ :f :g |            [ :args |                args := args asRest.               (f value: (((schemeEnv globalRef:  #'apply')                    value: ( g) value: ( args))))] withLastArgRest ] ) . schemeEnv define:  #'sqt'  as: (        [ :x |             [ | doX2Dloop112 |                doX2Dloop112 :=                [ :i |                 (((((schemeEnv globalRef:  #'X3E')                        value: (((schemeEnv globalRef:  #'X2A')                        value: ( i) value: ( i))) value: ( x))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'X2D')                        value: ( i) value: ( 1))]                   	ifFalse: [(doX2Dloop112 value: (((schemeEnv globalRef:  #'X2B')                        value: ( i) value: ( 1))))]           ].           doX2Dloop112 valueWithArguments: {                00. } ] value] ) .((schemeEnv globalRef:  #'test')       valueWithArguments: {  30. ((schemeEnv globalRef:  #'compose')      value: ( (schemeEnv globalRef:  #'sqt')     ) value: ( (schemeEnv globalRef:  #'X2A')     )).  12.  75.}). schemeEnv define:  #'sqt'  as: (        [ :x |             [ | doX2Dloop113 |                doX2Dloop113 :=                [ :i |                 (((((schemeEnv globalRef:  #'X3E')                        value: (((schemeEnv globalRef:  #'X2A')                        value: ( i) value: ( i))) value: ( x))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'X2D')                        value: ( i) value: ( 1))]                   	ifFalse: [(doX2Dloop113 value: (((schemeEnv globalRef:  #'X2B')                        value: ( i) value: ( 1))))]           ].           doX2Dloop113 valueWithArguments: {                00. } ] value] ) .((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ #'b'.  #'e'.  #'h'. } asRest).  (schemeEnv globalRef:  #'map')     .  (schemeEnv globalRef:  #'cadr')     .  ({ ({ #'a'.  #'b'. } asRest).  ({ #'d'.  #'e'. } asRest).  ({ #'g'.  #'h'. } asRest). } asRest).}).((schemeEnv globalRef:  #'test')       valueWithArguments: {  ({ 5.  7.  9. } asRest).  (schemeEnv globalRef:  #'map')     .  (schemeEnv globalRef:  #'X2B')     .  ({ 1.  2.  3. } asRest).  ({ 4.  5.  6. } asRest).}).((schemeEnv globalRef:  #'test')      value: ( { 00.  1.  4.  9.  16. }) value: ( #'forX2Deach') value: ( [ :v |       [       ((schemeEnv globalRef:  #'forX2Deach')            value: (       [ :i | ((schemeEnv globalRef:  #'vectorX2DsetX21')                value: ( v) value: ( i) value: (((schemeEnv globalRef:  #'X2A')                value: ( i) value: ( i))))]) value: ( ({ 00.  1.  2.  3.  4. } asRest))).        v.      ] value. ] valueWithArguments: {(((schemeEnv globalRef:  #'makeX2Dvector')          value: ( 5))). })).((schemeEnv globalRef:  #'test')       valueWithArguments: {  nil.  (schemeEnv globalRef:  #'map')     .  (schemeEnv globalRef:  #'cadr')     .  nil.}). schemeEnv define:  #'testX2Ddelay'    "test-delay"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).             ((schemeEnv globalRef:  #'display')                  value: ( ';testing DELAY and FORCE; ')).             ((schemeEnv globalRef:  #'newline')                  value).             ((schemeEnv globalRef:  #'section')                  value: ( 6) value: ( 9)).             ((schemeEnv globalRef:  #'test')                  value: ( 3) value: ( #'delay') value: (((schemeEnv globalRef:  #'force')                  value: (((schemeEnv globalRef:  #'makeX2Dpromise')                  value: (             [((schemeEnv globalRef:  #'X2B')                      value: ( 1) value: ( 2))])))))).             ((schemeEnv globalRef:  #'test')                  value: ( ({ 3.  3. } asRest)) value: ( #'delay') value: ( [ :p |                  ((schemeEnv globalRef:  #'list')                      value: (((schemeEnv globalRef:  #'force')                      value: ( p))) value: (((schemeEnv globalRef:  #'force')                      value: ( p)))).             ] valueWithArguments: {(((schemeEnv globalRef:  #'makeX2Dpromise')                      value: (                 [((schemeEnv globalRef:  #'X2B')                          value: ( 1) value: ( 2))]))). })).             ((schemeEnv globalRef:  #'test')                  value: ( 2) value: ( #'delay') value: (              [ | aX2Dstream head tail |                             aX2Dstream := (                [ | next |                                 next := (                 [ :n | ((schemeEnv globalRef:  #'cons')                          value: ( n) value: (((schemeEnv globalRef:  #'makeX2Dpromise')                          value: (                     [(next value: (((schemeEnv globalRef:  #'X2B')                              value: ( n) value: ( 1))))]))))]).                   (next value: ( 00)).               ] value).                head := ( (schemeEnv globalRef:  #'car')                   ).                tail := (               [ :stream | ((schemeEnv globalRef:  #'force')                        value: (((schemeEnv globalRef:  #'cdr')                        value: ( stream))))]).                 (head value: ((tail value: ((tail value: ( aX2Dstream)))))).             ] value)).                           [ | count p x |                             count := ( 00).                p := (((schemeEnv globalRef:  #'makeX2Dpromise')                    value: (               [ [                     (count := ((schemeEnv globalRef:  #'X2B')                          value: ( count) value: ( 1))).                      (((((schemeEnv globalRef:  #'X3E')                              value: ( count) value: ( x))) == false) not)                         	ifTrue: [ count]                         	ifFalse: [((schemeEnv globalRef:  #'force')                              value: ( p))].                    ] value]))).                x := ( 5).                  [                   ((schemeEnv globalRef:  #'test')                        value: ( 6) value: ( (schemeEnv globalRef:  #'force')                       ) value: ( p)).                   (x :=  10).                   ((schemeEnv globalRef:  #'test')                        value: ( 6) value: ( (schemeEnv globalRef:  #'force')                       ) value: ( p)).                  ] value.             ] value.             ((schemeEnv globalRef:  #'test')                  value: ( 3) value: ( #'force') value: (              [ | p c |                             p := (((schemeEnv globalRef:  #'makeX2Dpromise')                    value: (               [ ((( c) == false) not)                       	ifTrue: [ 3]                       	ifFalse: [ [                         (c :=  true).                         ((schemeEnv globalRef:  #'X2B')                              value: (((schemeEnv globalRef:  #'force')                              value: ( p))) value: ( 1)).                        ] value]]))).                c := ( false).                 ((schemeEnv globalRef:  #'force')                      value: ( p)).             ] value)).             ((schemeEnv globalRef:  #'reportX2Derrs')                  value).            ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 10) value: ( 1)).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'outputX2DportX3F')     ) value: (((schemeEnv globalRef:  #'currentX2DoutputX2Dport')      value))).((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'callX2DwithX2DinputX2Dfile')     .  'test.scm'.  (schemeEnv globalRef:  #'inputX2DportX3F')     .}). schemeEnv define:  #'thisX2Dfile'    "this-file"  as: ( ((schemeEnv globalRef:  #'openX2DinputX2Dfile')            value: ( 'test.scm')) ) .((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'inputX2DportX3F')     ) value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )).((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 10) value: ( 2)).((schemeEnv globalRef:  #'test')      value: ( $;) value: ( (schemeEnv globalRef:  #'peekX2Dchar')     ) value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )).((schemeEnv globalRef:  #'test')      value: ( $;) value: ( (schemeEnv globalRef:  #'readX2Dchar')     ) value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )).((schemeEnv globalRef:  #'test')      value: ( ({ #'define'.  #'curX2Dsection'.  ({ #'quote'.  nil. } asRest). } asRest)) value: ( (schemeEnv globalRef:  #'read')     ) value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )).((schemeEnv globalRef:  #'test')      value: ( $() value: ( (schemeEnv globalRef:  #'peekX2Dchar')     ) value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )).((schemeEnv globalRef:  #'test')      value: ( ({ #'define'.  #'errs'.  ({ #'quote'.  nil. } asRest). } asRest)) value: ( (schemeEnv globalRef:  #'read')     ) value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )).((schemeEnv globalRef:  #'closeX2DinputX2Dport')      value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )).((schemeEnv globalRef:  #'closeX2DinputX2Dport')      value: ( (schemeEnv globalRef:  #'thisX2Dfile')     )). schemeEnv define:  #'checkX2DtestX2Dfile'    "check-test-file"  as: (        [ :name |             [ | testX2Dfile |                         testX2Dfile := (((schemeEnv globalRef:  #'openX2DinputX2Dfile')                  value: ( name))).                [                 ((schemeEnv globalRef:  #'test')                      value: ( true) value: ( #'inputX2DportX3F') value: (((schemeEnv globalRef:  #'callX2DwithX2DinputX2Dfile')                      value: ( name) value: (                 [ :testX2Dfile |  [                       ((schemeEnv globalRef:  #'test')                            value: ( (schemeEnv globalRef:  #'loadX2DtestX2Dobj')                           ) value: ( (schemeEnv globalRef:  #'read')                           ) value: ( testX2Dfile)).                       ((schemeEnv globalRef:  #'test')                            value: ( true) value: ( (schemeEnv globalRef:  #'eofX2DobjectX3F')                           ) value: (((schemeEnv globalRef:  #'peekX2Dchar')                            value: ( testX2Dfile)))).                       ((schemeEnv globalRef:  #'test')                            value: ( true) value: ( (schemeEnv globalRef:  #'eofX2DobjectX3F')                           ) value: (((schemeEnv globalRef:  #'readX2Dchar')                            value: ( testX2Dfile)))).                       ((schemeEnv globalRef:  #'inputX2DportX3F')                            value: ( testX2Dfile)).                      ] value])))).                 ((schemeEnv globalRef:  #'test')                      value: ( $;) value: ( (schemeEnv globalRef:  #'readX2Dchar')                     ) value: ( testX2Dfile)).                 ((schemeEnv globalRef:  #'test')                      value: ( (schemeEnv globalRef:  #'displayX2DtestX2Dobj')                     ) value: ( (schemeEnv globalRef:  #'read')                     ) value: ( testX2Dfile)).                 ((schemeEnv globalRef:  #'test')                      value: ( (schemeEnv globalRef:  #'loadX2DtestX2Dobj')                     ) value: ( (schemeEnv globalRef:  #'read')                     ) value: ( testX2Dfile)).                 ((schemeEnv globalRef:  #'closeX2DinputX2Dport')                      value: ( testX2Dfile)).                ] value.           ] value] ) .((schemeEnv globalRef:  #'section')      value: ( 6) value: ( 10) value: ( 3)). schemeEnv define:  #'writeX2DtestX2Dobj'    "write-test-obj"  as: (  (Pair car:  true cdr:  (Pair car:  false cdr:  (Pair car:  $a cdr:  (Pair car:  nil cdr:  (Pair car:  9739 cdr:  (Pair car:  -3 cdr:  { ({ #'test'. } asRest).  'te " " st'.  ''.  #'test'.  {}.  #'b'.  #'c'. })))))) ) . schemeEnv define:  #'displayX2DtestX2Dobj'    "display-test-obj"  as: (  (Pair car:  true cdr:  (Pair car:  false cdr:  (Pair car:  #'a' cdr:  (Pair car:  nil cdr:  (Pair car:  9739 cdr:  (Pair car:  -3 cdr:  { ({ #'test'. } asRest).  #'te'.  ' '.  #'st'.  #'test'.  {}.  #'b'.  #'c'. })))))) ) . schemeEnv define:  #'loadX2DtestX2Dobj'    "load-test-obj"  as: ( ((schemeEnv globalRef:  #'list')            value: ( #'define') value: ( #'foo') value: (((schemeEnv globalRef:  #'list')            value: ( #'quote') value: ( (schemeEnv globalRef:  #'writeX2DtestX2Dobj')           )))) ) .((schemeEnv globalRef:  #'test')       valueWithArguments: {  true.  (schemeEnv globalRef:  #'callX2DwithX2DoutputX2Dfile')     .  'tmp1'.  [ :testX2Dfile |  [       ((schemeEnv globalRef:  #'writeX2Dchar')            value: ( $;) value: ( testX2Dfile)).       ((schemeEnv globalRef:  #'display')            value: ( (schemeEnv globalRef:  #'writeX2DtestX2Dobj')           ) value: ( testX2Dfile)).       ((schemeEnv globalRef:  #'newline')            value: ( testX2Dfile)).       ((schemeEnv globalRef:  #'write')            value: ( (schemeEnv globalRef:  #'loadX2DtestX2Dobj')           ) value: ( testX2Dfile)).       ((schemeEnv globalRef:  #'outputX2DportX3F')            value: ( testX2Dfile)).      ] value].}).((schemeEnv globalRef:  #'checkX2DtestX2Dfile')      value: ( 'tmp1')). schemeEnv define:  #'testX2Dfile'    "test-file"  as: ( ((schemeEnv globalRef:  #'openX2DoutputX2Dfile')            value: ( 'tmp2')) ) .((schemeEnv globalRef:  #'writeX2Dchar')      value: ( $;) value: ( (schemeEnv globalRef:  #'testX2Dfile')     )).((schemeEnv globalRef:  #'display')      value: ( (schemeEnv globalRef:  #'writeX2DtestX2Dobj')     ) value: ( (schemeEnv globalRef:  #'testX2Dfile')     )).((schemeEnv globalRef:  #'newline')      value: ( (schemeEnv globalRef:  #'testX2Dfile')     )).((schemeEnv globalRef:  #'write')      value: ( (schemeEnv globalRef:  #'loadX2DtestX2Dobj')     ) value: ( (schemeEnv globalRef:  #'testX2Dfile')     )).((schemeEnv globalRef:  #'test')      value: ( true) value: ( (schemeEnv globalRef:  #'outputX2DportX3F')     ) value: ( (schemeEnv globalRef:  #'testX2Dfile')     )).((schemeEnv globalRef:  #'closeX2DoutputX2Dport')      value: ( (schemeEnv globalRef:  #'testX2Dfile')     )).((schemeEnv globalRef:  #'checkX2DtestX2Dfile')      value: ( 'tmp2')). schemeEnv define:  #'testX2Dsc4'    "test-sc4"  as: (        [ [             ((schemeEnv globalRef:  #'newline')                  value).             ((schemeEnv globalRef:  #'display')                  value: ( ';testing scheme 4 functions; ')).             ((schemeEnv globalRef:  #'newline')                  value).             ((schemeEnv globalRef:  #'section')                  value: ( 6) value: ( 7)).             ((schemeEnv globalRef:  #'test')                  value: ( ({ $P.  $ .  $l. } asRest)) value: ( (schemeEnv globalRef:  #'stringX2DX3Elist')                 ) value: ( 'P l')).             ((schemeEnv globalRef:  #'test')                  value: ( nil) value: ( (schemeEnv globalRef:  #'stringX2DX3Elist')                 ) value: ( '')).             ((schemeEnv globalRef:  #'test')                  value: ( '1\"') value: ( (schemeEnv globalRef:  #'listX2DX3Estring')                 ) value: ( ({ $1.  $\.  $". } asRest))).             ((schemeEnv globalRef:  #'test')                  value: ( '') value: ( (schemeEnv globalRef:  #'listX2DX3Estring')                 ) value: ( nil)).             ((schemeEnv globalRef:  #'section')                  value: ( 6) value: ( 8)).             ((schemeEnv globalRef:  #'test')                  value: ( ({ #'dah'.  #'dah'.  #'didah'. } asRest)) value: ( (schemeEnv globalRef:  #'vectorX2DX3Elist')                 ) value: ( { #'dah'.  #'dah'.  #'didah'. })).             ((schemeEnv globalRef:  #'test')                  value: ( nil) value: ( (schemeEnv globalRef:  #'vectorX2DX3Elist')                 ) value: ( {})).             ((schemeEnv globalRef:  #'test')                  value: ( { #'dididit'.  #'dah'. }) value: ( (schemeEnv globalRef:  #'listX2DX3Evector')                 ) value: ( ({ #'dididit'.  #'dah'. } asRest))).             ((schemeEnv globalRef:  #'test')                  value: ( {}) value: ( (schemeEnv globalRef:  #'listX2DX3Evector')                 ) value: ( nil)).             ((schemeEnv globalRef:  #'section')                  value: ( 6) value: ( 10) value: ( 4)).             ((schemeEnv globalRef:  #'load')                  value: ( 'tmp1')).             ((schemeEnv globalRef:  #'test')                  value: ( (schemeEnv globalRef:  #'writeX2DtestX2Dobj')                 ) value: ( #'load') value: ( (schemeEnv globalRef:  #'foo')                 )).             ((schemeEnv globalRef:  #'reportX2Derrs')                  value).            ] value] ) .((schemeEnv globalRef:  #'reportX2Derrs')      value). ((( (((((schemeEnv globalRef:  #'stringX2DX3Enumber')              value: ( '0.0'))) == false) not)         	ifTrue: [((schemeEnv globalRef:  #'inexactX3F')              value: (((schemeEnv globalRef:  #'stringX2DX3Enumber')              value: ( '0.0'))))]         	ifFalse: [ false]) == false) not)     	ifTrue: [((schemeEnv globalRef:  #'testX2Dinexact')          value)]. [ :n |       ((( ((( n) == false) not)             	ifTrue: [((schemeEnv globalRef:  #'exactX3F')                  value: ( n))]             	ifFalse: [ false]) == false) not)         	ifTrue: [((schemeEnv globalRef:  #'testX2Dbignum')              value)]. ] valueWithArguments: {(((schemeEnv globalRef:  #'stringX2DX3Enumber')          value: ( '281474976710655'))). }.((schemeEnv globalRef:  #'newline')      value).((schemeEnv globalRef:  #'testX2Dsc4')      value).((schemeEnv globalRef:  #'testX2Ddelay')      value).((schemeEnv globalRef:  #'newline')      value). 'last item in file'.! !!SmallScheme methodsFor: 'user'!trace    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'X2AtracedX2A'    "*traced*"  as: (  nil ) . schemeEnv define:  #'trace'  as: (        [ :fname |  [ :fval |                 [                  [ :result87 |                       ((( result87) == false) not)                         	ifTrue: [((                         [ :bucket | ((schemeEnv globalRef:  #'setX2DcdrX21')                                  value: ( bucket) value: ( fval))]) value: ( result87))]                         	ifFalse: [(schemeEnv setX21:  #'X2AtracedX2A' as: ((schemeEnv globalRef:  #'cons')                              value: (((schemeEnv globalRef:  #'cons')                              value: ( fname) value: ( fval))) value: ( (schemeEnv globalRef:  #'X2AtracedX2A')                             )))].                 ] valueWithArguments: {(((schemeEnv globalRef:  #'assq')                          value: ( fname) value: ( (schemeEnv globalRef:  #'X2AtracedX2A')                         ))). }.                  [ :tracedX2Dfun |                       [                        ( self defineOrSet: fname as: tracedX2Dfun).                       ((schemeEnv globalRef:  #'map')                            value: ( (schemeEnv globalRef:  #'car')                           ) value: ( (schemeEnv globalRef:  #'X2AtracedX2A')                           )).                      ] value.                 ] valueWithArguments: {(                     [ :args |                          args := args asRest.                          [                           ((schemeEnv globalRef:  #'newline')                                value).                           ((schemeEnv globalRef:  #'display')                                value: ( '**entering** ')).                           ((schemeEnv globalRef:  #'write')                                value: ( fname)).                           ((schemeEnv globalRef:  #'display')                                value: ( ' < ')).                           ((schemeEnv globalRef:  #'write')                                value: ( args)).                            [ :result |                                 [                                 ((schemeEnv globalRef:  #'newline')                                      value).                                 ((schemeEnv globalRef:  #'display')                                      value: ( '***leaving** ')).                                 ((schemeEnv globalRef:  #'write')                                      value: ( fname)).                                 ((schemeEnv globalRef:  #'display')                                      value: ( ' > ')).                                 ((schemeEnv globalRef:  #'write')                                      value: ( result)).                                 ((schemeEnv globalRef:  #'newline')                                      value).                                  result.                                ] value.                           ] valueWithArguments: {(((schemeEnv globalRef:  #'apply')                                    value: ( fval) value: ( args))). }.                          ] value] withLastArgRest ). }.                ] value.           ] valueWithArguments: {( ( self globalRef: fname)). }] ) . schemeEnv define:  #'untrace'  as: (        [ :fname |  [              [ :result88 |                   ((( result88) == false) not)                     	ifTrue: [((                     [ :bucket | (schemeEnv setX21: fname as: ((schemeEnv globalRef:  #'cdr')                              value: ( bucket)))]) value: ( result88))]                     	ifFalse: [ 'Unspecified'].             ] valueWithArguments: {(((schemeEnv globalRef:  #'assq')                      value: ( fname) value: ( (schemeEnv globalRef:  #'X2AtracedX2A')                     ))). }.             ((schemeEnv globalRef:  #'map')                  value: ( (schemeEnv globalRef:  #'car')                 ) value: ( (schemeEnv globalRef:  #'X2AtracedX2A')                 )).            ] value] ) . schemeEnv define:  #'untraceX2Dall'    "untrace-all"  as: (        [((schemeEnv globalRef:  #'map')                value: (           [ :fname | ((schemeEnv globalRef:  #'untrace')                    value: ( fname))]) value: ( (schemeEnv globalRef:  #'X2AtracedX2A')               ))] ) .! !!SmallScheme methodsFor: 'user'!xlate1    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'lineX2Ddelimiter'    "line-delimiter"  as: ( ((schemeEnv globalRef:  #'integerX2DX3Echar')            value: ( 13)) ) . schemeEnv define:  #'endline'  as: (        [ :port | ((schemeEnv globalRef:  #'display')                value: ( (schemeEnv globalRef:  #'lineX2Ddelimiter')               ) value: ( port))] ) . schemeEnv define:  #'libraryX2DgenX2Dheader'    "library-gen-header"  as: (        [ :auxX2Dstring :initX2Dname :port |  [             (schemeEnv setX21:  #'globalX2DenvX2Dstr' as:  'SmallScheme ').             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '''# This file is encoded in ASCII') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '# line delimitor is CR.') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( 'SmallScheme') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( 'SmallScheme code for Squeak 3.0') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( auxX2Dstring) value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '''!!') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '!!SmallScheme class methodsFor: ''initialization''!!') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( initX2Dname) value: ( port)).            ] value] ) . schemeEnv define:  #'userX2DgenX2Dheader'    "user-gen-header"  as: (        [ :auxX2Dstring :initX2Dname :port |  [             (schemeEnv setX21:  #'globalX2DenvX2Dstr' as:  'schemeEnv ').             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '''# This file is encoded in ASCII') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '# line delimitor is CR.') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( 'SmallScheme') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( 'SmallScheme code for Squeak 3.0') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( auxX2Dstring) value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '''!!') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '!!SmallScheme methodsFor: ''user''!!') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( initX2Dname) value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '    "Capture self as env for use by nested block code"') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '    | schemeEnv | schemeEnv := self. ') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).            ] value] ) . schemeEnv define:  #'genX2Dtrailer'    "gen-trailer"  as: (        [ :port |  [             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( '!! !!') value: ( port)).             ((schemeEnv globalRef:  #'endline')                  value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2DfromX2Dfile'    "xlate-from-file"  as: (        [ :infileX2Dname :initX2Dname :genX2Dheader :genX2Dtrailer :outport |            outport := outport asRest.            [ :out |                ((schemeEnv globalRef:  #'callX2DwithX2DinputX2Dfile')                    value: ( infileX2Dname) value: (               [ :in |  [                     (genX2Dheader value: (((schemeEnv globalRef:  #'stringX2Dappend')                          value: ( 'Translated from file ') value: ( infileX2Dname))) value: ( initX2Dname) value: ( out)).                                           [ | loop |                          loop :=                          [ :form |                           (((((schemeEnv globalRef:  #'eofX2DobjectX3F')                                  value: ( form))) == false) not)                             	ifTrue: [ #'done']                             	ifFalse: [ [                               ((schemeEnv globalRef:  #'translate')                                    value: ( form) value: ( out)).                               (loop value: (((schemeEnv globalRef:  #'read')                                    value: ( in)))).                              ] value]                     ].                     loop valueWithArguments: {                         ((schemeEnv globalRef:  #'read')                              value: ( in)). } ] value.                     (genX2Dtrailer value: ( out)).                    ] value])).           ] valueWithArguments: {(((schemeEnv globalRef:  #'X3Aoptional')                    value: ( outport) value: (((schemeEnv globalRef:  #'currentX2DoutputX2Dport')                    value)))). }] withLastArgRest  ) . schemeEnv define:  #'makeX2DinitX2Dname'    "make-init-name"  as: (        [ :stem |  [ :bashable |                 [                 ((schemeEnv globalRef:  #'stringX2DsetX21')                      value: ( bashable) value: ( 00) value: (((schemeEnv globalRef:  #'charX2Dupcase')                      value: (((schemeEnv globalRef:  #'stringX2Dref')                      value: ( bashable) value: ( 00)))))).                 ((schemeEnv globalRef:  #'stringX2Dappend')                      value: ( 'init') value: ( bashable)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'symbolX2DX3Estring')                    value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                    value: ( stem))))). }] ) . schemeEnv define:  #'xlateX2DlibraryX2Dfile'    "xlate-library-file"  as: (        [ :infileX2Dname :outfileX2Dname :stem | ((schemeEnv globalRef:  #'callX2DwithX2DoutputX2Dfile')                value: ( outfileX2Dname) value: (           [ :out | ((schemeEnv globalRef:  #'xlateX2DfromX2Dfile')                                   valueWithArguments: {  infileX2Dname. ((schemeEnv globalRef:  #'makeX2DinitX2Dname')                    value: ( stem)).  (schemeEnv globalRef:  #'libraryX2DgenX2Dheader')                   .  (schemeEnv globalRef:  #'genX2Dtrailer')                   .  out.})]))] ) . schemeEnv define:  #'makeX2DinstanceX2Dname'    "make-instance-name"  as: (        [ :stem |  stem] ) . schemeEnv define:  #'xlateX2Dfile'    "xlate-file"  as: (        [ :infileX2Dname :outfileX2Dname :stem | ((schemeEnv globalRef:  #'callX2DwithX2DoutputX2Dfile')                value: ( outfileX2Dname) value: (           [ :out | ((schemeEnv globalRef:  #'xlateX2DfromX2Dfile')                                   valueWithArguments: {  infileX2Dname. ((schemeEnv globalRef:  #'makeX2DinstanceX2Dname')                    value: ( stem)).  (schemeEnv globalRef:  #'userX2DgenX2Dheader')                   .  (schemeEnv globalRef:  #'genX2Dtrailer')                   .  out.})]))] ) . schemeEnv define:  #'scheme2smalltalk'  as: (        [ :schemeX2DcodeX2Dstring :outputX2Dport |  [ :inputX2Dport |                 [                 (schemeEnv setX21:  #'globalX2DenvX2Dstr' as:  'schemeEnv ').                 ((schemeEnv globalRef:  #'display')                      value: ( '[ :schemeEnv | ') value: ( outputX2Dport)).                 ((schemeEnv globalRef:  #'translate')                      value: (((schemeEnv globalRef:  #'read')                      value: ( inputX2Dport))) value: ( outputX2Dport)).                 ((schemeEnv globalRef:  #'display')                      value: ( ']') value: ( outputX2Dport)).                 ((schemeEnv globalRef:  #'endline')                      value: ( outputX2Dport)).                  outputX2Dport.                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'openX2DinputX2Dstring')                    value: ( schemeX2DcodeX2Dstring))). }] ) . schemeEnv define:  #'translate'  as: (        [ :schemeX2Dexp :port |            port := port asRest.            [ :outport |                 [                 ((schemeEnv globalRef:  #'endline')                      value: ( outport)).                 ((schemeEnv globalRef:  #'xlate')                                       valueWithArguments: { ((schemeEnv globalRef:  #'desugar')                      value: ( schemeX2Dexp) value: ( 00)). ((schemeEnv globalRef:  #'makeX2DemptyX2Denv')                      value).  00.  outport.}).                 ((schemeEnv globalRef:  #'display')                      value: ( '.') value: ( outport)).                 ((schemeEnv globalRef:  #'endline')                      value: ( outport)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'X3Aoptional')                    value: ( port) value: (((schemeEnv globalRef:  #'currentX2DoutputX2Dport')                    value)))). }] withLastArgRest  ) . schemeEnv define:  #'globalX2DenvX2Dstr'    "global-env-str"  as: (  'SmallScheme ' ) . schemeEnv define:  #'global'  as: (        [ :preX2Dstr :postX2Dstr | ((schemeEnv globalRef:  #'stringX2Dappend')                value: ( preX2Dstr) value: ( (schemeEnv globalRef:  #'globalX2DenvX2Dstr')               ) value: ( postX2Dstr))] ) . schemeEnv define:  #'makeX2DemptyX2Denv'    "make-empty-env"  as: (        [ nil] ) . schemeEnv define:  #'extendX2Denv'    "extend-env"  as: (        [ :newX2Dvars :env | ((schemeEnv globalRef:  #'append')                value: ( newX2Dvars) value: ( env))] ) . schemeEnv define:  #'isX2DglobalX3F'    "is-global?"  as: (        [ :sym :localsX2Denv | ((schemeEnv globalRef:  #'not')                value: (((schemeEnv globalRef:  #'memq')                value: ( sym) value: ( localsX2Denv))))] ) . schemeEnv define:  #'xlate'  as: (        [ :exp :ctX2Denv :offset :port |  (((((schemeEnv globalRef:  #'emptyX2DlistX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'xlateX2DemptyX2Dlist')                    value: ( exp) value: ( port))]               	ifFalse: [ (((((schemeEnv globalRef:  #'numberX3F')                        value: ( exp))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dnumber')                        value: ( exp) value: ( port))]                   	ifFalse: [ (((((schemeEnv globalRef:  #'booleanX3F')                            value: ( exp))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dboolean')                            value: ( exp) value: ( port))]                       	ifFalse: [ (((((schemeEnv globalRef:  #'stringX3F')                                value: ( exp))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dstring')                                value: ( exp) value: ( port))]                           	ifFalse: [ (((((schemeEnv globalRef:  #'charX3F')                                    value: ( exp))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dchar')                                    value: ( exp) value: ( port))]                               	ifFalse: [ (((((schemeEnv globalRef:  #'quoteX3F')                                        value: ( exp))) == false) not)                                   	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dquote')                                        value: (((schemeEnv globalRef:  #'cadr')                                        value: ( exp))) value: ( offset) value: ( port))]                                   	ifFalse: [ (((((schemeEnv globalRef:  #'variableX3F')                                            value: ( exp))) == false) not)                                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dvariable')                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                       	ifFalse: [ (((((schemeEnv globalRef:  #'lambdaX3F')                                                value: ( exp))) == false) not)                                           	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dlambda')                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                           	ifFalse: [ (((((schemeEnv globalRef:  #'defineX3F')                                                    value: ( exp))) == false) not)                                               	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Ddefine')                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                               	ifFalse: [ (((((schemeEnv globalRef:  #'ifX3F')                                                        value: ( exp))) == false) not)                                                   	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dif')                                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                   	ifFalse: [ (((((schemeEnv globalRef:  #'beginX3F')                                                            value: ( exp))) == false) not)                                                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dbegin')                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                       	ifFalse: [ (((((schemeEnv globalRef:  #'setX21X3F')                                                                value: ( exp))) == false) not)                                                           	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DsetX21')                                                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                           	ifFalse: [ (((((schemeEnv globalRef:  #'namedX2DletX3F')                                                                    value: ( exp))) == false) not)                                                               	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DnamedX2Dlet')                                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                               	ifFalse: [ (((((schemeEnv globalRef:  #'letX3F')                                                                        value: ( exp))) == false) not)                                                                   	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dlet')                                                                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                   	ifFalse: [ (((((schemeEnv globalRef:  #'letX2AX3F')                                                                            value: ( exp))) == false) not)                                                                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DletX2A')                                                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                       	ifFalse: [ (((((schemeEnv globalRef:  #'letrecX3F')                                                                                value: ( exp))) == false) not)                                                                           	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dletrec')                                                                                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                           	ifFalse: [ (((((schemeEnv globalRef:  #'dynamicX2DletX3F')                                                                                    value: ( exp))) == false) not)                                                                               	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DdynamicX2Dlet')                                                                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                               	ifFalse: [ (((((schemeEnv globalRef:  #'dynamicX2DdefineX3F')                                                                                        value: ( exp))) == false) not)                                                                                   	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DdynamicX2Ddefine')                                                                                                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                                   	ifFalse: [ (((((schemeEnv globalRef:  #'dynamicX2DrefX2DwithX2DdefaultX3F')                                                                                            value: ( exp))) == false) not)                                                                                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DdynamicX2Drwd')                                                                                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                                       	ifFalse: [ (((((schemeEnv globalRef:  #'dynamicX2DrefX3F')                                                                                                value: ( exp))) == false) not)                                                                                           	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DdynamicX2Dref')                                                                                                                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                                           	ifFalse: [ (((((schemeEnv globalRef:  #'dynamicX2DsetX21X3F')                                                                                                    value: ( exp))) == false) not)                                                                                               	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2DdynamicX2DsetX21')                                                                                                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                                               	ifFalse: [ (((((schemeEnv globalRef:  #'valuesX3F')                                                                                                        value: ( exp))) == false) not)                                                                                                   	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dvalues')                                                                                                                                                                                                           valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                                                   	ifFalse: [ (((((schemeEnv globalRef:  #'magicX3F')                                                                                                            value: ( exp))) == false) not)                                                                                                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dmagically')                                                                                                                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                                                       	ifFalse: [ (((((schemeEnv globalRef:  #'smalltalkX2DrefX3F')                                                                                                                value: ( exp))) == false) not)                                                                                                           	ifTrue: [((schemeEnv globalRef:  #'emitX2DssX2Dref')                                                                                                                value: ( exp) value: ( port))]                                                                                                           	ifFalse: [ (((((schemeEnv globalRef:  #'applicationX3F')                                                                                                                    value: ( exp))) == false) not)                                                                                                               	ifTrue: [((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dapplication')                                                                                                                                                                                                                                   valueWithArguments: {  exp.  ctX2Denv.  offset.  port.})]                                                                                                               	ifFalse: [((schemeEnv globalRef:  #'error')                                                                                                                    value: ( 'unknown expression type') value: ( exp))]]]]]]]]]]]]]]]]]]]]]]]]]] ) . schemeEnv define:  #'X3Aoptional'    ":optional"  as: (        [ :exp :default |  (((((schemeEnv globalRef:  #'nullX3F')                    value: ( exp))) == false) not)               	ifTrue: [ default]               	ifFalse: [((schemeEnv globalRef:  #'car')                    value: ( exp))]] ) . schemeEnv define:  #'spaces'  as: (        [ :n :port |             [ | loop |                loop :=                [ :count |                 [                 ((schemeEnv globalRef:  #'display')                      value: ( $ ) value: ( port)).                  (((((schemeEnv globalRef:  #'X3E')                          value: ( n) value: ( 00))) == false) not)                     	ifTrue: [((schemeEnv globalRef:  #'spaces')                          value: (((schemeEnv globalRef:  #'X2D')                          value: ( count) value: ( 1))) value: ( port))].                ] value           ].           loop valueWithArguments: {                n. } ] value] ) . schemeEnv define:  #'endlineX2DandX2Dspaces'    "endline-and-spaces"  as: (        [ :n :port |  [             ((schemeEnv globalRef:  #'endline')                  value: ( port)).             ((schemeEnv globalRef:  #'spaces')                  value: ( n) value: ( port)).            ] value] ) . schemeEnv define:  #'lambdaX2DbodyX2Dindent'    "lambda-body-indent"  as: (  4 ) . schemeEnv define:  #'emitX2DbuildX2DrestX2Dargs'    "emit-build-rest-args"  as: (        [ :restX2Dname :offset :port |  [             ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                  value: ( offset) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                  value: ( restX2Dname))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( ' := ') value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                  value: ( restX2Dname))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( ' asRest.') value: ( port)).             ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                  value: ( offset) value: ( port)).            ] value] ) . schemeEnv define:  #'lambdaX2DhasX2DrestX3F'    "lambda-has-rest?"  as: (        [ :exp | ((schemeEnv globalRef:  #'not')                value: (((schemeEnv globalRef:  #'listX3F')                value: (((schemeEnv globalRef:  #'lambdaX2Dformals')                value: ( exp))))))] ) . schemeEnv define:  #'lambdaX2DrestX2DandX2DotherX2Dformals'    "lambda-rest-and-other-formals"  as: (        [ :exp |  [ :formals |                 (((((schemeEnv globalRef:  #'symbolX3F')                        value: ( formals))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'cons')                        value: ( formals) value: ( nil))]                   	ifFalse: [                    [ | loop |                        loop :=                        [ :list :others |                         (((((schemeEnv globalRef:  #'nullX3F')                                value: ( list))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'cons')                                value: ( nil) value: (((schemeEnv globalRef:  #'reverse')                                value: ( others))))]                           	ifFalse: [ (((((schemeEnv globalRef:  #'not')                                    value: (((schemeEnv globalRef:  #'pairX3F')                                    value: (((schemeEnv globalRef:  #'cdr')                                    value: ( list))))))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cdr')                                    value: ( list))) value: (((schemeEnv globalRef:  #'reverse')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'car')                                    value: ( list))) value: ( others))))))]                               	ifFalse: [(loop value: (((schemeEnv globalRef:  #'cdr')                                    value: ( list))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'car')                                    value: ( list))) value: ( others))))]]                   ].                   loop valueWithArguments: {                        formals.                         nil. } ] value].           ] valueWithArguments: {(((schemeEnv globalRef:  #'lambdaX2Dformals')                    value: ( exp))). }] ) . schemeEnv define:  #'xlateX2DX3EstsX2Dlambda'    "xlate->sts-lambda"  as: (        [ :exp :ctX2Denv :offset :port |            [ :restX3F |              [ :restX2DandX2Dothers |                [ :restX2Dformal |                  [ :nonX2DrestX2Dformals |                    [ :envX2Dformals |                      [ :bodyX2Doffset |                         [                         ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                              value: ( offset) value: ( port)).                         ((schemeEnv globalRef:  #'display')                              value: ( $[) value: ( port)).                          ((( restX3F) == false) not)                             	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dformals')                                  value: (((schemeEnv globalRef:  #'append')                                  value: ( nonX2DrestX2Dformals) value: (((schemeEnv globalRef:  #'list')                                  value: ( restX2Dformal))))) value: ( port))]                             	ifFalse: [((schemeEnv globalRef:  #'xlateX2Dformals')                                  value: ( nonX2DrestX2Dformals) value: ( port))].                          ((( restX3F) == false) not)                             	ifTrue: [((schemeEnv globalRef:  #'emitX2DbuildX2DrestX2Dargs')                                  value: ( restX2Dformal) value: ( bodyX2Doffset) value: ( port))].                         ((schemeEnv globalRef:  #'map')                              value: (                         [ :bodyX2Dexp | ((schemeEnv globalRef:  #'xlate')                                                               valueWithArguments: {  bodyX2Dexp. ((schemeEnv globalRef:  #'extendX2Denv')                                  value: ( envX2Dformals) value: ( ctX2Denv)).  bodyX2Doffset.  port.})]) value: (((schemeEnv globalRef:  #'lambdaX2Dbody')                              value: ( exp)))).                         ((schemeEnv globalRef:  #'display')                              value: ( $]) value: ( port)).                          ((( restX3F) == false) not)                             	ifTrue: [((schemeEnv globalRef:  #'display')                                  value: ( ' withLastArgRest ') value: ( port))].                        ] value                     ] value: (((schemeEnv globalRef:  #'X2B')                          value: ( offset) value: ( (schemeEnv globalRef:  #'lambdaX2DbodyX2Dindent')                         )))                   ] value: ( ((( restX3F) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'cons')                            value: ( restX2Dformal) value: ( nonX2DrestX2Dformals))]                       	ifFalse: [ nonX2DrestX2Dformals])                 ] value: (((schemeEnv globalRef:  #'cdr')                      value: ( restX2DandX2Dothers)))               ] value: (((schemeEnv globalRef:  #'car')                    value: ( restX2DandX2Dothers)))             ] value: (((schemeEnv globalRef:  #'lambdaX2DrestX2DandX2DotherX2Dformals')                  value: ( exp)))           ] value: (((schemeEnv globalRef:  #'lambdaX2DhasX2DrestX3F')                value: ( exp)))] ) . schemeEnv define:  #'caseX2Darity'    "case-arity"  as: (        [ :form |             [ | loop |                loop :=                [ :args :len |                 (((((schemeEnv globalRef:  #'nullX3F')                        value: ( args))) == false) not)                   	ifTrue: [ len]                   	ifFalse: [ (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'pairX3F')                            value: ( args))))) == false) not)                       	ifTrue: [ (((((schemeEnv globalRef:  #'zeroX3F')                                value: ( len))) == false) not)                           	ifTrue: [ #'nary']                           	ifFalse: [((schemeEnv globalRef:  #'X2D')                                value: ( len))]]                       	ifFalse: [(loop value: (((schemeEnv globalRef:  #'cdr')                            value: ( args))) value: (((schemeEnv globalRef:  #'X2B')                            value: ( len) value: ( 1))))]]           ].           loop valueWithArguments: {               ((schemeEnv globalRef:  #'car')                    value: ( form)).                 00. } ] value] ) . schemeEnv define:  #'xlateX2DX3EstsX2DcaseX2Dlambda'    "xlate->sts-case-lambda"  as: (        [ :exp :ctX2Denv :offset :port |  [ :caseX2Doffset :argsX2Dname |                 [                 ((schemeEnv globalRef:  #'display')                      value: ( '[ | ') value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( argsX2Dname) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' | := (varArgList asList).') value: ( port)).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' (Switch new)') value: ( port)).                                   [ | loop |                      loop :=                      [ :nargsX2Dseen :forms |                       (((((schemeEnv globalRef:  #'nullX3F')                              value: ( forms))) == false) not)                         	ifTrue: [ (((((schemeEnv globalRef:  #'not')                                  value: (((schemeEnv globalRef:  #'memv')                                  value: ( #'nary') value: ( nargsX2Dseen))))) == false) not)                             	ifTrue: [ [                               ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                    value: ( offset) value: ( port)).                               ((schemeEnv globalRef:  #'display')                                    value: ( 'default: ((R5RS.Scheme globalRef: #''error'') ') value: ( port)).                               ((schemeEnv globalRef:  #'display')                                    value: ( 'value: ''case-lambda: no matching case'' value: ') value: ( port)).                               ((schemeEnv globalRef:  #'display')                                    value: ( argsX2Dname) value: ( port)).                               ((schemeEnv globalRef:  #'display')                                    value: ( ');') value: ( port)).                              ] value]]                         	ifFalse: [ [ :form |                               [                               ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                    value: ( offset) value: ( port)).                                [ :arity |                                     [                                      ((( [ :temp89 |                                               ((( temp89) == false) not)                                                 	ifTrue: [ temp89]                                                 	ifFalse: [ (((((schemeEnv globalRef:  #'numberX3F')                                                          value: ( arity))) == false) not)                                                     	ifTrue: [ (((((schemeEnv globalRef:  #'negativeX3F')                                                              value: ( arity))) == false) not)                                                         	ifTrue: [((schemeEnv globalRef:  #'memv')                                                              value: ( #'nary') value: ( nargsX2Dseen))]                                                         	ifFalse: [ false]]                                                     	ifFalse: [ false]].                                         ] valueWithArguments: {(((schemeEnv globalRef:  #'memv')                                                  value: ( arity) value: ( nargsX2Dseen))). }) == false) not)                                         	ifTrue: [((schemeEnv globalRef:  #'error')                                              value: ( 'case-lambda: arguments counts must be distinct') value: ( exp))].                                      (((((schemeEnv globalRef:  #'eqX3F')                                              value: ( arity) value: ( #'nary'))) == false) not)                                         	ifTrue: [ [                                           ((schemeEnv globalRef:  #'display')                                                value: ( ' default: (') value: ( port)).                                           ((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dlambda')                                                                                           valueWithArguments: { ((schemeEnv globalRef:  #'cons')                                                value: ( #'lambda') value: (((schemeEnv globalRef:  #'cons')                                                value: (((schemeEnv globalRef:  #'list')                                                value: (((schemeEnv globalRef:  #'car')                                                value: ( form))))) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                                value: (((schemeEnv globalRef:  #'cdr')                                                value: ( form))) value: ( nil)))))).  ctX2Denv.  caseX2Doffset.  port.}).                                           ((schemeEnv globalRef:  #'display')                                                value: ( ' value: (') value: ( port)).                                           ((schemeEnv globalRef:  #'display')                                                value: ( argsX2Dname) value: ( port)).                                           ((schemeEnv globalRef:  #'display')                                                value: ( ' asRest));') value: ( port)).                                           (loop value: (((schemeEnv globalRef:  #'cons')                                                value: ( arity) value: ( nargsX2Dseen))) value: (((schemeEnv globalRef:  #'cdr')                                                value: ( forms)))).                                          ] value]                                         	ifFalse: [ (((((schemeEnv globalRef:  #'negativeX3F')                                                  value: ( arity))) == false) not)                                             	ifTrue: [ [                                               ((schemeEnv globalRef:  #'display')                                                    value: ( ' default: (') value: ( port)).                                               ((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dlambda')                                                                                                   valueWithArguments: { ((schemeEnv globalRef:  #'cons')                                                    value: ( #'lambda') value: ( form)).  ctX2Denv.  caseX2Doffset.  port.}).                                               ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                                    value: ( caseX2Doffset) value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( ' valueWithArguments: ') value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( argsX2Dname) value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( ' );') value: ( port)).                                               (loop value: (((schemeEnv globalRef:  #'cons')                                                    value: ( arity) value: (((schemeEnv globalRef:  #'cons')                                                    value: ( #'nary') value: ( nargsX2Dseen))))) value: (((schemeEnv globalRef:  #'cdr')                                                    value: ( forms)))).                                              ] value]                                             	ifFalse: [ [                                               ((schemeEnv globalRef:  #'display')                                                    value: ( ' case: ') value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( arity) value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( ' do: (') value: ( port)).                                               ((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dlambda')                                                                                                   valueWithArguments: { ((schemeEnv globalRef:  #'cons')                                                    value: ( #'lambda') value: ( form)).  ctX2Denv.  caseX2Doffset.  port.}).                                               ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                                    value: ( caseX2Doffset) value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( ' valueWithArguments: ') value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( argsX2Dname) value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( ' );') value: ( port)).                                               (loop value: (((schemeEnv globalRef:  #'cons')                                                    value: ( arity) value: ( nargsX2Dseen))) value: (((schemeEnv globalRef:  #'cdr')                                                    value: ( forms)))).                                              ] value]].                                    ] value.                               ] valueWithArguments: {(((schemeEnv globalRef:  #'caseX2Darity')                                        value: ( form))). }.                              ] value.                         ] valueWithArguments: {(((schemeEnv globalRef:  #'car')                                  value: ( forms))). }]                 ].                 loop valueWithArguments: {                      nil.                      ((schemeEnv globalRef:  #'cdr')                          value: ( exp)). } ] value.                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( 'on: (varArgList.size)]') value: ( port)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'X2B')                    value: ( 10) value: ( offset))). (((schemeEnv globalRef:  #'gensym')                    value: ( 'args'))). }] ) .! !!SmallScheme methodsFor: 'user'!xlate2    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'defineX2Dindent'    "define-indent"  as: (  6 ) . schemeEnv define:  #'xlateX2DX3EstsX2Ddefine'    "xlate->sts-define"  as: (        [ :exp :ctX2Denv :offset :port |  [             ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                  value: ( offset) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'global')                  value: ( '') value: ( 'define: '))) value: ( port)).              [ :defX2Dname |                   [                   ((schemeEnv globalRef:  #'xlateX2Dsymbol')                        value: ( defX2Dname) value: ( port)).                    (((((schemeEnv globalRef:  #'not')                            value: (((schemeEnv globalRef:  #'equalX3F')                            value: ( defX2Dname) value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                            value: ( defX2Dname))))))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2DsymbolX2DasX2DstX2Dcomment')                            value: ( defX2Dname) value: ( port))].                   ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                        value: ( offset) value: ( port)).                   ((schemeEnv globalRef:  #'display')                        value: ( ' as: ( ') value: ( port)).                   ((schemeEnv globalRef:  #'xlate')                                           valueWithArguments: { ((schemeEnv globalRef:  #'definitionX2Dbody')                        value: ( exp)).  ctX2Denv. ((schemeEnv globalRef:  #'X2B')                        value: ( offset) value: ( (schemeEnv globalRef:  #'defineX2Dindent')                       )).  port.}).                   ((schemeEnv globalRef:  #'display')                        value: ( ' )') value: ( port)).                   ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                        value: ( offset) value: ( port)).                  ] value.             ] valueWithArguments: {(((schemeEnv globalRef:  #'definitionX2Dname')                      value: ( exp))). }.            ] value] ) . schemeEnv define:  #'xlateX2DX3EstsX2Dvariable'    "xlate->sts-variable"  as: (        [ :variableX2Dname :ctX2Denv :offset :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( $ ) value: ( port)).              (((((schemeEnv globalRef:  #'not')                      value: (((schemeEnv globalRef:  #'isX2DglobalX3F')                      value: ( variableX2Dname) value: ( ctX2Denv))))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                      value: ( variableX2Dname))) value: ( port))]                 	ifFalse: [ [                   ((schemeEnv globalRef:  #'xlateX2DglobalX2Dref')                        value: ( variableX2Dname) value: ( port)).                   ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                        value: (((schemeEnv globalRef:  #'X2B')                        value: ( 4) value: ( offset))) value: ( port)).                  ] value].            ] value] ) . schemeEnv define:  #'xlateX2DsymbolX2DasX2DstX2Dcomment'    "xlate-symbol-as-st-comment"  as: (        [ :sym :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( '    "') value: ( port)).             ((schemeEnv globalRef:  #'forX2Deach')                  value: (             [ :char |  [                   ((schemeEnv globalRef:  #'display')                        value: ( char) value: ( port)).                    (((((schemeEnv globalRef:  #'charX3DX3F')                            value: ( char) value: ( $!!))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'display')                            value: ( char) value: ( port))].                  ] value]) value: (((schemeEnv globalRef:  #'stringX2DX3Elist')                  value: (((schemeEnv globalRef:  #'symbolX2DX3Estring')                  value: ( sym)))))).             ((schemeEnv globalRef:  #'display')                  value: ( '"') value: ( port)).            ] value] ) . schemeEnv define:  #'schemeX2DX3EsmalltalkX2Didentifier'    "scheme->smalltalk-identifier"  as: (  [ :specials |                       [ :name |                 [ | loop |                    loop :=                    [ :result :chars |                     (((((schemeEnv globalRef:  #'nullX3F')                            value: ( chars))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'stringX2DX3Esymbol')                            value: (((schemeEnv globalRef:  #'listX2DX3Estring')                            value: (((schemeEnv globalRef:  #'reverse')                            value: ( result))))))]                       	ifFalse: [ [ :char |                             (((((schemeEnv globalRef:  #'memq')                                    value: ( char) value: ( specials))) == false) not)                               	ifTrue: [(loop value: (((schemeEnv globalRef:  #'addX2DreverseX2DhexX2Dchars')                                    value: ( char) value: ( result))) value: (((schemeEnv globalRef:  #'cdr')                                    value: ( chars))))]                               	ifFalse: [ (((((schemeEnv globalRef:  #'charX3DX3F')                                        value: ( char) value: ( $X))) == false) not)                                   	ifTrue: [(loop value: (((schemeEnv globalRef:  #'cons')                                        value: ( $X) value: (((schemeEnv globalRef:  #'cons')                                        value: ( $X) value: ( result))))) value: (((schemeEnv globalRef:  #'cdr')                                        value: ( chars))))]                                   	ifFalse: [(loop value: (((schemeEnv globalRef:  #'cons')                                        value: ( char) value: ( result))) value: (((schemeEnv globalRef:  #'cdr')                                        value: ( chars))))]].                       ] valueWithArguments: {(((schemeEnv globalRef:  #'car')                                value: ( chars))). }]               ].               loop valueWithArguments: {                    nil.                    ((schemeEnv globalRef:  #'stringX2DX3Elist')                        value: ( (((((schemeEnv globalRef:  #'symbolX3F')                            value: ( name))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'symbolX2DX3Estring')                            value: ( name))]                       	ifFalse: [ name])). } ] value].       ] valueWithArguments: {( ({ $!!.  $$.  $%.  $&.  $*.  $+.  $-.  $..  $/.  $:.  $<.  $=.  $>.  $?.  $@.  $^.  $_.  $~. } asRest)). } ) . schemeEnv define:  #'addX2DreverseX2DhexX2Dchars'    "add-reverse-hex-chars"  as: (        [ :char :result |            [ :chars |              ((schemeEnv globalRef:  #'append')                  value: (((schemeEnv globalRef:  #'reverse')                  value: (((schemeEnv globalRef:  #'cons')                  value: ( $X) value: ( chars))))) value: ( result))           ] value: (((schemeEnv globalRef:  #'stringX2DX3Elist')                value: (((schemeEnv globalRef:  #'numberX2DX3Estring')                value: (((schemeEnv globalRef:  #'charX2DX3Einteger')                value: ( char))) value: ( 16)))))] ) . schemeEnv define:  #'xlateX2Dnumber'    "xlate-number"  as: (        [ :number :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( $ ) value: ( port)).              (((((schemeEnv globalRef:  #'X3C')                      value: (((schemeEnv globalRef:  #'abs')                      value: ( number))) value: ( 1))) == false) not)                 	ifTrue: [((schemeEnv globalRef:  #'display')                      value: ( '0') value: ( port))].             ((schemeEnv globalRef:  #'display')                  value: ( number) value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2Dstring'    "xlate-string"  as: (        [ :string :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( ' ''') value: ( port)).             ((schemeEnv globalRef:  #'forX2Deach')                  value: (             [ :char |  [                   ((schemeEnv globalRef:  #'display')                        value: ( char) value: ( port)).                    (((((schemeEnv globalRef:  #'charX3DX3F')                            value: ( char) value: ( $'))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'display')                            value: ( char) value: ( port))]                       	ifFalse: [ (((((schemeEnv globalRef:  #'charX3DX3F')                                value: ( char) value: ( $`))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'display')                                value: ( char) value: ( port))]                           	ifFalse: [ (((((schemeEnv globalRef:  #'charX3DX3F')                                    value: ( char) value: ( $!!))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'display')                                    value: ( char) value: ( port))]]].                  ] value]) value: (((schemeEnv globalRef:  #'stringX2DX3Elist')                  value: ( string)))).             ((schemeEnv globalRef:  #'display')                  value: ( '''') value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2Dchar'    "xlate-char"  as: (        [ :char :port |  (((((schemeEnv globalRef:  #'eqX3F')                    value: ( char) value: ((Character cr)))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'display')                    value: ( '(Character cr)') value: ( port))]               	ifFalse: [ [                 ((schemeEnv globalRef:  #'display')                      value: ( ' $') value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( char) value: ( port)).                  (((((schemeEnv globalRef:  #'charX3DX3F')                          value: ( char) value: ( $!!))) == false) not)                     	ifTrue: [((schemeEnv globalRef:  #'display')                          value: ( char) value: ( port))].                ] value]] ) . schemeEnv define:  #'xlateX2Dboolean'    "xlate-boolean"  as: (        [ :boolean :port |  ((( boolean) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'display')                    value: ( ' true') value: ( port))]               	ifFalse: [((schemeEnv globalRef:  #'display')                    value: ( ' false') value: ( port))]] ) . schemeEnv define:  #'xlateX2DemptyX2Dlist'    "xlate-empty-list"  as: (        [ :exp :port | ((schemeEnv globalRef:  #'display')                value: ( ' nil') value: ( port))] ) . schemeEnv define:  #'xlateX2Dsymbol'    "xlate-symbol"  as: (        [ :sym :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( ' #''') value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                  value: ( sym))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( $') value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2DglobalX2Dref'    "xlate-global-ref"  as: (        [ :name :port |  [             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'global')                  value: ( '(') value: ( 'globalRef: '))) value: ( port)).             ((schemeEnv globalRef:  #'xlateX2Dsymbol')                  value: ( name) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( ')') value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2Dformals'    "xlate-formals"  as: (        [ :formals :port |  (((((schemeEnv globalRef:  #'X3E')                    value: (((schemeEnv globalRef:  #'length')                    value: ( formals))) value: ( 00))) == false) not)               	ifTrue: [ [                 ((schemeEnv globalRef:  #'forX2Deach')                      value: (                 [ :name |  [                       ((schemeEnv globalRef:  #'display')                            value: ( ' :') value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                            value: ( name))) value: ( port)).                      ] value]) value: ( formals)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' | ') value: ( port)).                ] value]] ) . schemeEnv define:  #'xlateX2Dquote'    "xlate-quote"  as: (        [ :exp :offset :port |  (((((schemeEnv globalRef:  #'symbolX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dsymbol')                    value: ( exp) value: ( port))]               	ifFalse: [ (((((schemeEnv globalRef:  #'numberX3F')                        value: ( exp))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dnumber')                        value: ( exp) value: ( port))]                   	ifFalse: [ (((((schemeEnv globalRef:  #'booleanX3F')                            value: ( exp))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dboolean')                            value: ( exp) value: ( port))]                       	ifFalse: [ (((((schemeEnv globalRef:  #'stringX3F')                                value: ( exp))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dstring')                                value: ( exp) value: ( port))]                           	ifFalse: [ (((((schemeEnv globalRef:  #'charX3F')                                    value: ( exp))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'xlateX2Dchar')                                    value: ( exp) value: ( port))]                               	ifFalse: [ (((((schemeEnv globalRef:  #'emptyX2DlistX3F')                                        value: ( exp))) == false) not)                                   	ifTrue: [((schemeEnv globalRef:  #'display')                                        value: ( ' nil') value: ( port))]                                   	ifFalse: [ (((((schemeEnv globalRef:  #'listX3F')                                            value: ( exp))) == false) not)                                       	ifTrue: [ [                                         ((schemeEnv globalRef:  #'display')                                              value: ( ' ({') value: ( port)).                                         ((schemeEnv globalRef:  #'forX2Deach')                                              value: (                                         [ :thing |  [                                               ((schemeEnv globalRef:  #'xlateX2Dquote')                                                    value: ( thing) value: ( offset) value: ( port)).                                               ((schemeEnv globalRef:  #'display')                                                    value: ( '. ') value: ( port)).                                              ] value]) value: ( exp)).                                         ((schemeEnv globalRef:  #'display')                                              value: ( '} asRest)') value: ( port)).                                        ] value]                                       	ifFalse: [ (((((schemeEnv globalRef:  #'pairX3F')                                                value: ( exp))) == false) not)                                           	ifTrue: [ [                                             ((schemeEnv globalRef:  #'display')                                                  value: ( ' (Pair car: ') value: ( port)).                                             ((schemeEnv globalRef:  #'xlateX2Dquote')                                                  value: (((schemeEnv globalRef:  #'car')                                                  value: ( exp))) value: ( offset) value: ( port)).                                             ((schemeEnv globalRef:  #'display')                                                  value: ( ' cdr: ') value: ( port)).                                             ((schemeEnv globalRef:  #'xlateX2Dquote')                                                  value: (((schemeEnv globalRef:  #'cdr')                                                  value: ( exp))) value: ( offset) value: ( port)).                                             ((schemeEnv globalRef:  #'display')                                                  value: ( ')') value: ( port)).                                            ] value]                                           	ifFalse: [ (((((schemeEnv globalRef:  #'vectorX3F')                                                    value: ( exp))) == false) not)                                               	ifTrue: [ [                                                 ((schemeEnv globalRef:  #'display')                                                      value: ( ' {') value: ( port)).                                                 ((schemeEnv globalRef:  #'forX2Deach')                                                      value: (                                                 [ :thing |  [                                                       ((schemeEnv globalRef:  #'xlateX2Dquote')                                                            value: ( thing) value: ( offset) value: ( port)).                                                       ((schemeEnv globalRef:  #'display')                                                            value: ( '. ') value: ( port)).                                                      ] value]) value: (((schemeEnv globalRef:  #'vectorX2DX3Elist')                                                      value: ( exp)))).                                                 ((schemeEnv globalRef:  #'display')                                                      value: ( '}') value: ( port)).                                                ] value]                                               	ifFalse: [((schemeEnv globalRef:  #'error')                                                    value: ( 'unknown quoted expression type') value: ( exp))]]]]]]]]]] ) . schemeEnv define:  #'ifX2Dindent'    "if-indent"  as: (  4 ) . schemeEnv define:  #'xlateX2DX3EstsX2Dif'    "xlate->sts-if"  as: (        [ :exp :ctX2Denv :offset :port |  [ :ifX2Doffset |                 [                 ((schemeEnv globalRef:  #'display')                      value: ( ' (((') value: ( port)).                 ((schemeEnv globalRef:  #'xlate')                                       valueWithArguments: { ((schemeEnv globalRef:  #'ifX2Dpredicate')                      value: ( exp)).  ctX2Denv.  ifX2Doffset.  port.}).                 ((schemeEnv globalRef:  #'display')                      value: ( ') == false) not)') value: ( port)).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( ifX2Doffset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( '	ifTrue: [') value: ( port)).                 ((schemeEnv globalRef:  #'xlate')                                       valueWithArguments: { ((schemeEnv globalRef:  #'ifX2Dconsequent')                      value: ( exp)).  ctX2Denv.  ifX2Doffset.  port.}).                 ((schemeEnv globalRef:  #'display')                      value: ( $]) value: ( port)).                  (((((schemeEnv globalRef:  #'ifX2DhasX2DalternateX3F')                          value: ( exp))) == false) not)                     	ifTrue: [ [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( ifX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: ( '	ifFalse: [') value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: { ((schemeEnv globalRef:  #'ifX2Dalternate')                            value: ( exp)).  ctX2Denv.  ifX2Doffset.  port.}).                       ((schemeEnv globalRef:  #'display')                            value: ( $]) value: ( port)).                      ] value].                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'X2B')                    value: ( offset) value: ( (schemeEnv globalRef:  #'ifX2Dindent')                   ))). }] ) . schemeEnv define:  #'beginX2Dindent'    "begin-indent"  as: (  2 ) . schemeEnv define:  #'xlateX2DX3EstsX2Dbegin'    "xlate->sts-begin"  as: (        [ :exp :ctX2Denv :offset :port |  [ :newX2Doffset |                 [                 ((schemeEnv globalRef:  #'display')                      value: ( ' [') value: ( port)).                 ((schemeEnv globalRef:  #'map')                      value: (                 [ :exp |  [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( newX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: {  exp.  ctX2Denv.  newX2Doffset.  port.}).                       ((schemeEnv globalRef:  #'display')                            value: ( $.) value: ( port)).                      ] value]) value: (((schemeEnv globalRef:  #'beginX2Dsubexpressions')                      value: ( exp)))).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' ] value') value: ( port)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'X2B')                    value: ( offset) value: ( (schemeEnv globalRef:  #'beginX2Dindent')                   ))). }] ) . schemeEnv define:  #'setX21X2Dvar'    "set!!-var"  as: (  (schemeEnv globalRef:  #'cadr')            ) . schemeEnv define:  #'setX21X2Dval'    "set!!-val"  as: (  (schemeEnv globalRef:  #'caddr')            ) . schemeEnv define:  #'xlateX2DX3EstsX2DsetX21'    "xlate->sts-set!!"  as: (        [ :exp :ctX2Denv :offset :port |  [ :var :val |                 [                  ((( (((((schemeEnv globalRef:  #'pairX3F')                              value: ( var))) == false) not)                         	ifTrue: [((schemeEnv globalRef:  #'eqX3F')                              value: (((schemeEnv globalRef:  #'car')                              value: ( var))) value: ( #'X24'))]                         	ifFalse: [ false]) == false) not)                     	ifTrue: [ [                       ((schemeEnv globalRef:  #'display')                            value: (((schemeEnv globalRef:  #'global')                            value: ( '(') value: ( 'setX21: '))) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: (((schemeEnv globalRef:  #'cadr')                            value: ( var))) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: ( ' as: ') value: ( port)).                      ] value]                     	ifFalse: [ (((((schemeEnv globalRef:  #'isX2DglobalX3F')                              value: ( var) value: ( ctX2Denv))) == false) not)                         	ifTrue: [ [                           ((schemeEnv globalRef:  #'display')                                value: (((schemeEnv globalRef:  #'global')                                value: ( '(') value: ( 'setX21: '))) value: ( port)).                           ((schemeEnv globalRef:  #'xlateX2Dsymbol')                                value: ( var) value: ( port)).                           ((schemeEnv globalRef:  #'display')                                value: ( ' as: ') value: ( port)).                          ] value]                         	ifFalse: [ [                           ((schemeEnv globalRef:  #'display')                                value: ( '(') value: ( port)).                           ((schemeEnv globalRef:  #'display')                                value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                                value: ( var))) value: ( port)).                           ((schemeEnv globalRef:  #'display')                                value: ( ' := ') value: ( port)).                          ] value]].                 ((schemeEnv globalRef:  #'xlate')                                       valueWithArguments: {  val.  ctX2Denv.  offset.  port.}).                 ((schemeEnv globalRef:  #'display')                      value: ( ')') value: ( port)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'setX21X2Dvar')                    value: ( exp))). (((schemeEnv globalRef:  #'setX21X2Dval')                    value: ( exp))). }] ) . schemeEnv define:  #'letX2Dbindings'    "let-bindings"  as: (        [ :exp |  (((((schemeEnv globalRef:  #'namedX2DletX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'caddr')                    value: ( exp))]               	ifFalse: [((schemeEnv globalRef:  #'cadr')                    value: ( exp))]] ) . schemeEnv define:  #'letX2Dbody'    "let-body"  as: (        [ :exp |  (((((schemeEnv globalRef:  #'namedX2DletX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'cdddr')                    value: ( exp))]               	ifFalse: [((schemeEnv globalRef:  #'cddr')                    value: ( exp))]] ) . schemeEnv define:  #'letX2Dformal'    "let-formal"  as: (  (schemeEnv globalRef:  #'car')            ) . schemeEnv define:  #'letX2Dinit'    "let-init"  as: (  (schemeEnv globalRef:  #'cadr')            ) . schemeEnv define:  #'letX2Dformals'    "let-formals"  as: (        [ :exp | ((schemeEnv globalRef:  #'map')                value: ( (schemeEnv globalRef:  #'letX2Dformal')               ) value: (((schemeEnv globalRef:  #'letX2Dbindings')                value: ( exp))))] ) . schemeEnv define:  #'letX2Dinits'    "let-inits"  as: (        [ :exp | ((schemeEnv globalRef:  #'map')                value: ( (schemeEnv globalRef:  #'letX2Dinit')               ) value: (((schemeEnv globalRef:  #'letX2Dbindings')                value: ( exp))))] ) . schemeEnv define:  #'letX2Dname'    "let-name"  as: (  (schemeEnv globalRef:  #'cadr')            ) . schemeEnv define:  #'letX2DbodyX2Dindent'    "let-body-indent"  as: (  4 ) . schemeEnv define:  #'letX2Dindent'    "let-indent"  as: (  2 ) . schemeEnv define:  #'xlateX2DX3EstsX2Dlet'    "xlate->sts-let"  as: (        [ :exp :ctX2Denv :offset :port |  [ :bodyX2Doffset :formals :inits |                 [                 ((schemeEnv globalRef:  #'display')                      value: ( ' [') value: ( port)).                 ((schemeEnv globalRef:  #'xlateX2Dformals')                      value: ( formals) value: ( port)).                 ((schemeEnv globalRef:  #'map')                      value: (                 [ :bodyX2Dexp |  [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( bodyX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: {  bodyX2Dexp. ((schemeEnv globalRef:  #'extendX2Denv')                            value: ( formals) value: ( ctX2Denv)).  bodyX2Doffset.  port.}).                       ((schemeEnv globalRef:  #'display')                            value: ( $.) value: ( port)).                      ] value]) value: (((schemeEnv globalRef:  #'letX2Dbody')                      value: ( exp)))).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( '] ') value: ( port)).                  (((((schemeEnv globalRef:  #'nullX3F')                          value: ( inits))) == false) not)                     	ifTrue: [((schemeEnv globalRef:  #'display')                          value: ( 'value') value: ( port))]                     	ifFalse: [ [                       ((schemeEnv globalRef:  #'display')                            value: ( 'valueWithArguments: {') value: ( port)).                       ((schemeEnv globalRef:  #'map')                            value: (                       [ :init |  [                             ((schemeEnv globalRef:  #'display')                                  value: ( '(') value: ( port)).                             ((schemeEnv globalRef:  #'xlate')                                                               valueWithArguments: {  init.  ctX2Denv.  bodyX2Doffset.  port.}).                             ((schemeEnv globalRef:  #'display')                                  value: ( '). ') value: ( port)).                            ] value]) value: ( inits)).                       ((schemeEnv globalRef:  #'display')                            value: ( '}') value: ( port)).                      ] value].                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'X2B')                    value: ( offset) value: ( (schemeEnv globalRef:  #'letX2DbodyX2Dindent')                   ))). (((schemeEnv globalRef:  #'letX2Dformals')                    value: ( exp))). (((schemeEnv globalRef:  #'letX2Dinits')                    value: ( exp))). }] ) . schemeEnv define:  #'namedX2DletX2Dindent'    "named-let-indent"  as: (  4 ) . schemeEnv define:  #'xlateX2DX3EstsX2DnamedX2Dlet'    "xlate->sts-named-let"  as: (        [ :exp :ctX2Denv :offset :port |  [ :newX2Doffset :newX2Denv :tagX2Dname |                 [                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' [ | ') value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( tagX2Dname) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' | ') value: ( port)).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: (((schemeEnv globalRef:  #'X2B')                      value: ( offset) value: ( 4))) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( tagX2Dname) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' := ') value: ( port)).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( newX2Doffset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( '[') value: ( port)).                 ((schemeEnv globalRef:  #'xlateX2Dformals')                      value: (((schemeEnv globalRef:  #'letX2Dformals')                      value: ( exp))) value: ( port)).                 ((schemeEnv globalRef:  #'forX2Deach')                      value: (                 [ :bodyX2Dexp |  [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( newX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: {  bodyX2Dexp.  newX2Denv.  newX2Doffset.  port.}).                      ] value]) value: (((schemeEnv globalRef:  #'letX2Dbody')                      value: ( exp)))).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( '].') value: ( port)).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( tagX2Dname) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' valueWithArguments: {') value: ( port)).                 ((schemeEnv globalRef:  #'forX2Deach')                      value: (                 [ :init |  [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( newX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: {  init.  newX2Denv.  newX2Doffset.  port.}).                       ((schemeEnv globalRef:  #'display')                            value: ( '. ') value: ( port)).                      ] value]) value: (((schemeEnv globalRef:  #'letX2Dinits')                      value: ( exp)))).                 ((schemeEnv globalRef:  #'display')                      value: ( '} ] value') value: ( port)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'X2B')                    value: ( offset) value: ( (schemeEnv globalRef:  #'namedX2DletX2Dindent')                   ))). (((schemeEnv globalRef:  #'extendX2Denv')                    value: (((schemeEnv globalRef:  #'cons')                    value: (((schemeEnv globalRef:  #'letX2Dname')                    value: ( exp))) value: (((schemeEnv globalRef:  #'letX2Dformals')                    value: ( exp))))) value: ( ctX2Denv))). (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                    value: (((schemeEnv globalRef:  #'letX2Dname')                    value: ( exp))))). }] ) . schemeEnv define:  #'xlateX2DX3EstsX2DletX2A'    "xlate->sts-let*"  as: (        [ :exp :ctX2Denv :offset :port |             [ | loop |                loop :=                [ :formals :inits :bodyX2Doffset :env |                 (((((schemeEnv globalRef:  #'nullX3F')                        value: ( formals))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'map')                        value: (                   [ :bodyX2Dexp |  [                         ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                              value: ( bodyX2Doffset) value: ( port)).                         ((schemeEnv globalRef:  #'xlate')                                                       valueWithArguments: {  bodyX2Dexp.  env.  bodyX2Doffset.  port.}).                        ] value]) value: (((schemeEnv globalRef:  #'letX2Dbody')                        value: ( exp))))]                   	ifFalse: [ [ :formal :init |                         [                         ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                              value: ( bodyX2Doffset) value: ( port)).                         ((schemeEnv globalRef:  #'display')                              value: ( '[') value: ( port)).                         ((schemeEnv globalRef:  #'xlateX2Dformals')                              value: ( formal) value: ( port)).                         (loop                          valueWithArguments: { ((schemeEnv globalRef:  #'cdr')                              value: ( formals)). ((schemeEnv globalRef:  #'cdr')                              value: ( inits)). ((schemeEnv globalRef:  #'X2B')                              value: ( bodyX2Doffset) value: ( (schemeEnv globalRef:  #'letX2Dindent')                             )). ((schemeEnv globalRef:  #'extendX2Denv')                              value: ( formal) value: ( env)).}).                         ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                              value: ( bodyX2Doffset) value: ( port)).                         ((schemeEnv globalRef:  #'display')                              value: ( '] value: (') value: ( port)).                         ((schemeEnv globalRef:  #'xlate')                                                       valueWithArguments: {  init.  env.  bodyX2Doffset.  port.}).                         ((schemeEnv globalRef:  #'display')                              value: ( ')') value: ( port)).                        ] value.                   ] valueWithArguments: {(((schemeEnv globalRef:  #'list')                            value: (((schemeEnv globalRef:  #'car')                            value: ( formals))))). (((schemeEnv globalRef:  #'car')                            value: ( inits))). }]           ].           loop valueWithArguments: {               ((schemeEnv globalRef:  #'letX2Dformals')                    value: ( exp)).                ((schemeEnv globalRef:  #'letX2Dinits')                    value: ( exp)).                 offset.                 ctX2Denv. } ] value] ) . schemeEnv define:  #'xlateX2DX3EstsX2Dletrec'    "xlate->sts-letrec"  as: (        [ :exp :ctX2Denv :offset :port |            [ :bodyX2Doffset |              [ :initX2Doffset |                [ :formals |                  [ :inits |                    [ :newX2Denv |                       [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( offset) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: ( ' [ |') value: ( port)).                       ((schemeEnv globalRef:  #'forX2Deach')                            value: (                       [ :formal |  [                             ((schemeEnv globalRef:  #'display')                                  value: ( ' ') value: ( port)).                             ((schemeEnv globalRef:  #'display')                                  value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                                  value: ( formal))) value: ( port)).                            ] value]) value: ( formals)).                       ((schemeEnv globalRef:  #'display')                            value: ( ' |') value: ( port)).                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( offset) value: ( port)).                       ((schemeEnv globalRef:  #'map')                            value: (                       [ :name :init |  [                             ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                  value: ( initX2Doffset) value: ( port)).                             ((schemeEnv globalRef:  #'xlateX2DX3EstsX2Dvariable')                                                               valueWithArguments: {  name.  newX2Denv.  offset.  port.}).                             ((schemeEnv globalRef:  #'display')                                  value: ( ' := (') value: ( port)).                             ((schemeEnv globalRef:  #'xlate')                                                               valueWithArguments: {  init.  newX2Denv.  initX2Doffset.  port.}).                             ((schemeEnv globalRef:  #'display')                                  value: ( ').') value: ( port)).                            ] value]) value: ( formals) value: ( inits)).                       ((schemeEnv globalRef:  #'map')                            value: (                       [ :bodyX2Dexp |  [                             ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                  value: ( bodyX2Doffset) value: ( port)).                             ((schemeEnv globalRef:  #'xlate')                                                               valueWithArguments: {  bodyX2Dexp.  newX2Denv.  bodyX2Doffset.  port.}).                             ((schemeEnv globalRef:  #'display')                                  value: ( $.) value: ( port)).                            ] value]) value: (((schemeEnv globalRef:  #'letX2Dbody')                            value: ( exp)))).                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( offset) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: ( '] value') value: ( port)).                      ] value                   ] value: (((schemeEnv globalRef:  #'extendX2Denv')                        value: ( formals) value: ( ctX2Denv)))                 ] value: (((schemeEnv globalRef:  #'letX2Dinits')                      value: ( exp)))               ] value: (((schemeEnv globalRef:  #'letX2Dformals')                    value: ( exp)))             ] value: (((schemeEnv globalRef:  #'X2B')                  value: ( offset) value: ( (schemeEnv globalRef:  #'letX2Dindent')                 )))           ] value: (((schemeEnv globalRef:  #'X2B')                value: ( offset) value: ( (schemeEnv globalRef:  #'letX2DbodyX2Dindent')               )))] ) . schemeEnv define:  #'xlateX2DX3EstsX2DdynamicX2Dlet'    "xlate->sts-dynamic-let"  as: (        [ :exp :ctX2Denv :offset :port |  [ :bodyX2Doffset |                 [                 ((schemeEnv globalRef:  #'display')                      value: ( ' [') value: ( port)).                 ((schemeEnv globalRef:  #'map')                      value: (                 [ :binding |  [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( bodyX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: (((schemeEnv globalRef:  #'global')                            value: ( '') value: ( 'dynamicPush: #'))) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                            value: (((schemeEnv globalRef:  #'letX2Dformal')                            value: ( binding))))) value: ( port)).                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: (((schemeEnv globalRef:  #'X2B')                            value: ( 10) value: ( bodyX2Doffset))) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: ( ' as: ') value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: { ((schemeEnv globalRef:  #'letX2Dinit')                            value: ( binding)).  ctX2Denv.  bodyX2Doffset.  port.}).                       ((schemeEnv globalRef:  #'display')                            value: ( $.) value: ( port)).                      ] value]) value: (((schemeEnv globalRef:  #'letX2Dbindings')                      value: ( exp)))).                 ((schemeEnv globalRef:  #'map')                      value: (                 [ :bodyX2Dexp |  [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( bodyX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: {  bodyX2Dexp.  ctX2Denv.  bodyX2Doffset.  port.}).                       ((schemeEnv globalRef:  #'display')                            value: ( $.) value: ( port)).                      ] value]) value: (((schemeEnv globalRef:  #'letX2Dbody')                      value: ( exp)))).                 ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                      value: ( offset) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( '] ensure: [') value: ( port)).                 ((schemeEnv globalRef:  #'map')                      value: (                 [ :formal |  [                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                            value: ( bodyX2Doffset) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: (((schemeEnv globalRef:  #'global')                            value: ( '') value: ( 'dynamicPop: #'))) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                            value: ( formal))) value: ( port)).                       ((schemeEnv globalRef:  #'display')                            value: ( $.) value: ( port)).                      ] value]) value: (((schemeEnv globalRef:  #'letX2Dformals')                      value: ( exp)))).                 ((schemeEnv globalRef:  #'display')                      value: ( '].') value: ( port)).                 ((schemeEnv globalRef:  #'endline')                      value: ( port)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'X2B')                    value: ( offset) value: ( (schemeEnv globalRef:  #'letX2Dindent')                   ))). }] ) . schemeEnv define:  #'xlateX2DX3EstsX2DdynamicX2Ddefine'    "xlate->sts-dynamic-define"  as: (        [ :exp :ctX2Denv :offset :port |  [             ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                  value: ( offset) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'global')                  value: ( '') value: ( 'dynamicDefine: #'))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                  value: (((schemeEnv globalRef:  #'definitionX2Dname')                  value: ( exp))))) value: ( port)).             ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                  value: ( offset) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( ' as: ') value: ( port)).             ((schemeEnv globalRef:  #'xlate')                               valueWithArguments: { ((schemeEnv globalRef:  #'definitionX2Dbody')                  value: ( exp)).  ctX2Denv. ((schemeEnv globalRef:  #'X2B')                  value: ( offset) value: ( (schemeEnv globalRef:  #'defineX2Dindent')                 )).  port.}).            ] value] ) . schemeEnv define:  #'xlateX2DX3EstsX2DdynamicX2Dref'    "xlate->sts-dynamic-ref"  as: (        [ :exp :ctX2Denv :offset :port |  [             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'global')                  value: ( '(') value: ( 'dynamicRef: #'))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                  value: (((schemeEnv globalRef:  #'cadr')                  value: ( exp))))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( ')') value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2DX3EstsX2DdynamicX2Drwd'    "xlate->sts-dynamic-rwd"  as: (        [ :exp :ctX2Denv :offset :port |  [             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'global')                  value: ( '(') value: ( 'dynamicRef: #'))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                  value: (((schemeEnv globalRef:  #'cadr')                  value: ( exp))))) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: ( ' withDefault: ') value: ( port)).             ((schemeEnv globalRef:  #'xlate')                               valueWithArguments: { ((schemeEnv globalRef:  #'caddr')                  value: ( exp)).  ctX2Denv.  offset.  port.}).             ((schemeEnv globalRef:  #'display')                  value: ( ')') value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2DX3EstsX2DdynamicX2DsetX21'    "xlate->sts-dynamic-set!!"  as: (        [ :exp :ctX2Denv :offset :port |  [ :var :val |                 [                 ((schemeEnv globalRef:  #'display')                      value: (((schemeEnv globalRef:  #'global')                      value: ( '(') value: ( 'dynamicSetX21: #'))) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                      value: ( var))) value: ( port)).                 ((schemeEnv globalRef:  #'display')                      value: ( ' as: ') value: ( port)).                 ((schemeEnv globalRef:  #'xlate')                                       valueWithArguments: {  val.  ctX2Denv.  offset.  port.}).                 ((schemeEnv globalRef:  #'display')                      value: ( ')') value: ( port)).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'setX21X2Dvar')                    value: ( exp))). (((schemeEnv globalRef:  #'setX21X2Dval')                    value: ( exp))). }] ) . schemeEnv define:  #'xlateX2DX3EstsX2Dapplication'    "xlate->sts-application"  as: (        [ :exp :ctX2Denv :offset :port |  [ :op |                 [                 ((schemeEnv globalRef:  #'display')                      value: ( '(') value: ( port)).                  (((((schemeEnv globalRef:  #'variableX3F')                          value: ( op))) == false) not)                     	ifTrue: [ (((((schemeEnv globalRef:  #'isX2DglobalX3F')                              value: ( op) value: ( ctX2Denv))) == false) not)                         	ifTrue: [ [                           ((schemeEnv globalRef:  #'xlateX2DglobalX2Dref')                                value: ( op) value: ( port)).                           ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                value: (((schemeEnv globalRef:  #'X2B')                                value: ( 4) value: ( offset))) value: ( port)).                          ] value]                         	ifFalse: [((schemeEnv globalRef:  #'display')                              value: (((schemeEnv globalRef:  #'schemeX2DX3EsmalltalkX2Didentifier')                              value: ( op))) value: ( port))]]                     	ifFalse: [ [                       ((schemeEnv globalRef:  #'display')                            value: ( '(') value: ( port)).                       ((schemeEnv globalRef:  #'xlate')                                                   valueWithArguments: {  op.  ctX2Denv.  offset.  port.}).                       ((schemeEnv globalRef:  #'display')                            value: ( ')') value: ( port)).                      ] value].                                  [ :operands |                    [ :numX2Doperands |                       (((((schemeEnv globalRef:  #'zeroX3F')                              value: ( numX2Doperands))) == false) not)                         	ifTrue: [((schemeEnv globalRef:  #'display')                              value: ( ' value)') value: ( port))]                         	ifFalse: [ (((((schemeEnv globalRef:  #'X3D')                                  value: ( 1) value: ( numX2Doperands))) == false) not)                             	ifTrue: [ [                               ((schemeEnv globalRef:  #'display')                                    value: ( ' value: (') value: ( port)).                               ((schemeEnv globalRef:  #'xlate')                                                                   valueWithArguments: { ((schemeEnv globalRef:  #'car')                                    value: ( operands)).  ctX2Denv.  offset.  port.}).                               ((schemeEnv globalRef:  #'display')                                    value: ( '))') value: ( port)).                              ] value]                             	ifFalse: [ (((((schemeEnv globalRef:  #'X3D')                                      value: ( 2) value: ( numX2Doperands))) == false) not)                                 	ifTrue: [ [                                   ((schemeEnv globalRef:  #'display')                                        value: ( ' value: (') value: ( port)).                                   ((schemeEnv globalRef:  #'xlate')                                                                           valueWithArguments: { ((schemeEnv globalRef:  #'car')                                        value: ( operands)).  ctX2Denv.  offset.  port.}).                                   ((schemeEnv globalRef:  #'display')                                        value: ( ') value: (') value: ( port)).                                   ((schemeEnv globalRef:  #'xlate')                                                                           valueWithArguments: { ((schemeEnv globalRef:  #'cadr')                                        value: ( operands)).  ctX2Denv.  offset.  port.}).                                   ((schemeEnv globalRef:  #'display')                                        value: ( '))') value: ( port)).                                  ] value]                                 	ifFalse: [ (((((schemeEnv globalRef:  #'X3D')                                          value: ( 3) value: ( numX2Doperands))) == false) not)                                     	ifTrue: [ [                                       ((schemeEnv globalRef:  #'display')                                            value: ( ' value: (') value: ( port)).                                       ((schemeEnv globalRef:  #'xlate')                                                                                   valueWithArguments: { ((schemeEnv globalRef:  #'car')                                            value: ( operands)).  ctX2Denv.  offset.  port.}).                                       ((schemeEnv globalRef:  #'display')                                            value: ( ') value: (') value: ( port)).                                       ((schemeEnv globalRef:  #'xlate')                                                                                   valueWithArguments: { ((schemeEnv globalRef:  #'cadr')                                            value: ( operands)).  ctX2Denv.  offset.  port.}).                                       ((schemeEnv globalRef:  #'display')                                            value: ( ') value: (') value: ( port)).                                       ((schemeEnv globalRef:  #'xlate')                                                                                   valueWithArguments: { ((schemeEnv globalRef:  #'caddr')                                            value: ( operands)).  ctX2Denv.  offset.  port.}).                                       ((schemeEnv globalRef:  #'display')                                            value: ( '))') value: ( port)).                                      ] value]                                     	ifFalse: [ [                                       ((schemeEnv globalRef:  #'endlineX2DandX2Dspaces')                                            value: ( offset) value: ( port)).                                       ((schemeEnv globalRef:  #'display')                                            value: ( ' valueWithArguments: {') value: ( port)).                                       ((schemeEnv globalRef:  #'forX2Deach')                                            value: (                                       [ :whatever |  [                                             ((schemeEnv globalRef:  #'display')                                                  value: ( $ ) value: ( port)).                                             ((schemeEnv globalRef:  #'xlate')                                                                                               valueWithArguments: {  whatever.  ctX2Denv.  offset.  port.}).                                             ((schemeEnv globalRef:  #'display')                                                  value: ( $.) value: ( port)).                                            ] value]) value: ( operands)).                                       ((schemeEnv globalRef:  #'display')                                            value: ( '})') value: ( port)).                                      ] value]]]]                   ] value: (((schemeEnv globalRef:  #'length')                        value: ( operands)))                 ] value: (((schemeEnv globalRef:  #'operands')                      value: ( exp))).                ] value.           ] valueWithArguments: {(((schemeEnv globalRef:  #'operator')                    value: ( exp))). }] ) . schemeEnv define:  #'xlateX2DX3EstsX2Dvalues'    "xlate->sts-values"  as: (        [ :exp :ctX2Denv :offset :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( ' {') value: ( port)).             ((schemeEnv globalRef:  #'forX2Deach')                  value: (             [ :whatever |  [                   ((schemeEnv globalRef:  #'display')                        value: ( $ ) value: ( port)).                   ((schemeEnv globalRef:  #'xlate')                                           valueWithArguments: {  whatever.  ctX2Denv.  offset.  port.}).                   ((schemeEnv globalRef:  #'display')                        value: ( $.) value: ( port)).                  ] value]) value: (((schemeEnv globalRef:  #'cdr')                  value: ( exp)))).             ((schemeEnv globalRef:  #'display')                  value: ( '}') value: ( port)).            ] value] ) . schemeEnv define:  #'xlateX2Dmagically'    "xlate-magically"  as: (        [ :exp :ctX2Denv :offset :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( ' (') value: ( port)).                           [ | loop |                  loop :=                  [ :stuff :oddX3F |                   (((((schemeEnv globalRef:  #'nullX3F')                          value: ( stuff))) == false) not)                     	ifTrue: [ (schemeEnv globalRef:  #'unspecified')                         ]                     	ifFalse: [ [                        ((( oddX3F) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'xlate')                                                           valueWithArguments: { ((schemeEnv globalRef:  #'car')                                value: ( stuff)).  ctX2Denv.  offset.  port.})]                           	ifFalse: [ [                             ((schemeEnv globalRef:  #'display')                                  value: ( $ ) value: ( port)).                             ((schemeEnv globalRef:  #'display')                                  value: (((schemeEnv globalRef:  #'car')                                  value: ( stuff))) value: ( port)).                            ] value].                       (loop value: (((schemeEnv globalRef:  #'cdr')                            value: ( stuff))) value: (((schemeEnv globalRef:  #'not')                            value: ( oddX3F)))).                      ] value]             ].             loop valueWithArguments: {                 ((schemeEnv globalRef:  #'cdr')                      value: ( exp)).                   true. } ] value.             ((schemeEnv globalRef:  #'display')                  value: ( ')') value: ( port)).            ] value] ) . schemeEnv define:  #'emitX2DssX2Dref'    "emit-ss-ref"  as: (        [ :exp :port |  [             ((schemeEnv globalRef:  #'display')                  value: ( $ ) value: ( port)).             ((schemeEnv globalRef:  #'display')                  value: (((schemeEnv globalRef:  #'cadr')                  value: ( exp))) value: ( port)).            ] value] ) .! !!SmallScheme methodsFor: 'user'!xlate3    "Capture self as env for use by nested block code"    | schemeEnv | schemeEnv := self.  schemeEnv define:  #'makeX2DlistX2DprefixX2Dpredicate'    "make-list-prefix-predicate"  as: (        [ :sym |            [ :exp |  (((((schemeEnv globalRef:  #'pairX3F')                        value: ( exp))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'eqX3F')                        value: (((schemeEnv globalRef:  #'car')                        value: ( exp))) value: ( sym))]                   	ifFalse: [ false]]] ) . schemeEnv define:  #'quoteX3F'    "quote?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'quote')) ) . schemeEnv define:  #'lambdaX3F'    "lambda?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'lambda')) ) . schemeEnv define:  #'caseX2DlambdaX3F'    "case-lambda?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'caseX2Dlambda')) ) . schemeEnv define:  #'setX21X3F'    "set!!?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'setX21')) ) . schemeEnv define:  #'letX3F'    "let?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'let')) ) . schemeEnv define:  #'letX2AX3F'    "let*?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'letX2A')) ) . schemeEnv define:  #'letrecX3F'    "letrec?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'letrec')) ) . schemeEnv define:  #'dynamicX2DletX3F'    "dynamic-let?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'dynamicX2Dlet')) ) . schemeEnv define:  #'dynamicX2DdefineX3F'    "dynamic-define?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'dynamicX2Ddefine')) ) . schemeEnv define:  #'dynamicX2DrefX3F'    "dynamic-ref?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'dynamicX2Dref')) ) . schemeEnv define:  #'dynamicX2DrefX2DwithX2DdefaultX3F'    "dynamic-ref-with-default?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'dynamicX2DrefX2DwithX2Ddefault')) ) . schemeEnv define:  #'dynamicX2DsetX21X3F'    "dynamic-set!!?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'dynamicX2DsetX21')) ) . schemeEnv define:  #'quasiquoteX3F'    "quasiquote?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'quasiquote')) ) . schemeEnv define:  #'unquoteX3F'    "unquote?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'unquote')) ) . schemeEnv define:  #'unquoteX2DsplicingX3F'    "unquote-splicing?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'unquoteX2Dsplicing')) ) . schemeEnv define:  #'namedX2DletX3F'    "named-let?"  as: (        [ :exp |  (((((schemeEnv globalRef:  #'letX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'symbolX3F')                    value: (((schemeEnv globalRef:  #'cadr')                    value: ( exp))))]               	ifFalse: [ false]] ) . schemeEnv define:  #'ifX3F'    "if?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'if')) ) . schemeEnv define:  #'defineX3F'    "define?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'define')) ) . schemeEnv define:  #'beginX3F'    "begin?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'begin')) ) . schemeEnv define:  #'valuesX3F'    "values?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'values')) ) . schemeEnv define:  #'magicX3F'    "magic?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'X3A')) ) . schemeEnv define:  #'smalltalkX2DrefX3F'    "smalltalk-ref?"  as: ( ((schemeEnv globalRef:  #'makeX2DlistX2DprefixX2Dpredicate')            value: ( #'X24')) ) . schemeEnv define:  #'emptyX2DlistX3F'    "empty-list?"  as: (        [ :thing | ((schemeEnv globalRef:  #'eqX3F')                value: ( thing) value: ( nil))] ) . schemeEnv define:  #'keywordX3F'    "keyword?"  as: (        [ :x | ((schemeEnv globalRef:  #'member')                value: ( x) value: ( ({ #'quote'.  #'lambda'.  #'if'.  #'begin'.  #'letrec'.  #'define'. } asRest)))] ) . schemeEnv define:  #'literalX3F'    "literal?"  as: (        [ :exp |  [ :temp90 |                 ((( temp90) == false) not)                   	ifTrue: [ temp90]                   	ifFalse: [ [ :temp91 |                         ((( temp91) == false) not)                           	ifTrue: [ temp91]                           	ifFalse: [((schemeEnv globalRef:  #'quoteX3F')                                value: ( exp))].                   ] valueWithArguments: {(((schemeEnv globalRef:  #'booleanX3F')                            value: ( exp))). }].           ] valueWithArguments: {(((schemeEnv globalRef:  #'numberX3F')                    value: ( exp))). }] ) . schemeEnv define:  #'variableX3F'    "variable?"  as: (        [ :exp |  (((((schemeEnv globalRef:  #'symbolX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'not')                    value: (((schemeEnv globalRef:  #'keywordX3F')                    value: ( exp))))]               	ifFalse: [ false]] ) . schemeEnv define:  #'sameX2DvariableX3F'    "same-variable?"  as: (  (schemeEnv globalRef:  #'eqX3F')            ) . schemeEnv define:  #'lambdaX2Dformals'    "lambda-formals"  as: (  (schemeEnv globalRef:  #'cadr')            ) . schemeEnv define:  #'lambdaX2Dbody'    "lambda-body"  as: (  (schemeEnv globalRef:  #'cddr')            ) . schemeEnv define:  #'setX21X2Dtarget'    "set!!-target"  as: (  (schemeEnv globalRef:  #'cadr')            ) . schemeEnv define:  #'setX21X2DvalueX2Dexp'    "set!!-value-exp"  as: (  (schemeEnv globalRef:  #'caddr')            ) . schemeEnv define:  #'applicationX3F'    "application?"  as: (        [ :exp |  (((((schemeEnv globalRef:  #'pairX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'not')                    value: (((schemeEnv globalRef:  #'keywordX3F')                    value: (((schemeEnv globalRef:  #'car')                    value: ( exp))))))]               	ifFalse: [ false]] ) . schemeEnv define:  #'operator'  as: (  (schemeEnv globalRef:  #'car')            ) . schemeEnv define:  #'operands'  as: (  (schemeEnv globalRef:  #'cdr')            ) . schemeEnv define:  #'ifX2Dpredicate'    "if-predicate"  as: (  (schemeEnv globalRef:  #'cadr')            ) . schemeEnv define:  #'ifX2Dconsequent'    "if-consequent"  as: (  (schemeEnv globalRef:  #'caddr')            ) . schemeEnv define:  #'ifX2Dalternate'    "if-alternate"  as: (  (schemeEnv globalRef:  #'cadddr')            ) . schemeEnv define:  #'ifX2DhasX2DalternateX3F'    "if-has-alternate?"  as: (        [ :exp | ((schemeEnv globalRef:  #'not')                value: (((schemeEnv globalRef:  #'nullX3F')                value: (((schemeEnv globalRef:  #'cdddr')                value: ( exp))))))] ) . schemeEnv define:  #'beginX2Dsubexpressions'    "begin-subexpressions"  as: (  (schemeEnv globalRef:  #'cdr')            ) . schemeEnv define:  #'definitionX2Dname'    "definition-name"  as: (        [ :form |  [ :pattern |                 (((((schemeEnv globalRef:  #'pairX3F')                        value: ( pattern))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'car')                        value: ( pattern))]                   	ifFalse: [ pattern].           ] valueWithArguments: {(((schemeEnv globalRef:  #'cadr')                    value: ( form))). }] ) . schemeEnv define:  #'definitionX2Dbody'    "definition-body"  as: (        [ :form |  [ :pattern |                 (((((schemeEnv globalRef:  #'pairX3F')                        value: ( pattern))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'cons')                        value: ( #'lambda') value: (((schemeEnv globalRef:  #'cons')                        value: (((schemeEnv globalRef:  #'cdr')                        value: ( pattern))) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                        value: (((schemeEnv globalRef:  #'cddr')                        value: ( form))) value: ( nil))))))]                   	ifFalse: [((schemeEnv globalRef:  #'caddr')                        value: ( form))].           ] valueWithArguments: {(((schemeEnv globalRef:  #'cadr')                    value: ( form))). }] ) . schemeEnv define:  #'mapX2A'    "map*"  as: (        [ :fn :list |            list := list asRest.            (((((schemeEnv globalRef:  #'nullX3F')                    value: (((schemeEnv globalRef:  #'car')                    value: ( list))))) == false) not)               	ifTrue: [ nil]               	ifFalse: [ (((((schemeEnv globalRef:  #'pairX3F')                        value: (((schemeEnv globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'cons')                        value: (((schemeEnv globalRef:  #'apply')                        value: ( fn) value: (((schemeEnv globalRef:  #'map')                        value: ( (schemeEnv globalRef:  #'car')                       ) value: ( list))))) value: (((schemeEnv globalRef:  #'apply')                        value: ( (schemeEnv globalRef:  #'mapX2A')                       ) value: ( fn) value: (((schemeEnv globalRef:  #'map')                        value: ( (schemeEnv globalRef:  #'cdr')                       ) value: ( list))))))]                   	ifFalse: [((schemeEnv globalRef:  #'apply')                        value: ( fn) value: ( list))]]] withLastArgRest  ) . schemeEnv define:  #'desugar'  as: (        [ :exp :qqX2Dlevel |  ((( [ :temp92 |                     ((( temp92) == false) not)                       	ifTrue: [ temp92]                       	ifFalse: [ [ :temp93 |                             ((( temp93) == false) not)                               	ifTrue: [ temp93]                               	ifFalse: [ [ :temp94 |                                     ((( temp94) == false) not)                                       	ifTrue: [ temp94]                                       	ifFalse: [((schemeEnv globalRef:  #'charX3F')                                            value: ( exp))].                               ] valueWithArguments: {(((schemeEnv globalRef:  #'stringX3F')                                        value: ( exp))). }].                       ] valueWithArguments: {(((schemeEnv globalRef:  #'booleanX3F')                                value: ( exp))). }].               ] valueWithArguments: {(((schemeEnv globalRef:  #'numberX3F')                        value: ( exp))). }) == false) not)               	ifTrue: [ exp]               	ifFalse: [ (((((schemeEnv globalRef:  #'symbolX3F')                        value: ( exp))) == false) not)                   	ifTrue: [ exp]                   	ifFalse: [ (((((schemeEnv globalRef:  #'quoteX3F')                            value: ( exp))) == false) not)                       	ifTrue: [ exp]                       	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                value: ( exp) value: ( nil))) == false) not)                           	ifTrue: [ exp]                           	ifFalse: [ (((((schemeEnv globalRef:  #'lambdaX3F')                                    value: ( exp))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'cons')                                    value: ( #'lambda') value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'lambdaX2Dformals')                                    value: ( exp))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'desugarX2Dbody')                                    value: (((schemeEnv globalRef:  #'lambdaX2Dbody')                                    value: ( exp))) value: ( qqX2Dlevel))) value: ( nil))))))]                               	ifFalse: [ (((((schemeEnv globalRef:  #'defineX3F')                                        value: ( exp))) == false) not)                                   	ifTrue: [((schemeEnv globalRef:  #'cons')                                        value: ( #'define') value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'definitionX2Dname')                                        value: ( exp))) value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'desugar')                                        value: (((schemeEnv globalRef:  #'definitionX2Dbody')                                        value: ( exp))) value: ( qqX2Dlevel))) value: ( nil))))))]                                   	ifFalse: [ (((((schemeEnv globalRef:  #'setX21X3F')                                            value: ( exp))) == false) not)                                       	ifTrue: [((schemeEnv globalRef:  #'cons')                                            value: ( #'setX21') value: (((schemeEnv globalRef:  #'cons')                                            value: (((schemeEnv globalRef:  #'setX21X2Dtarget')                                            value: ( exp))) value: (((schemeEnv globalRef:  #'cons')                                            value: (((schemeEnv globalRef:  #'desugar')                                            value: (((schemeEnv globalRef:  #'setX21X2DvalueX2Dexp')                                            value: ( exp))) value: ( qqX2Dlevel))) value: ( nil))))))]                                       	ifFalse: [ (((((schemeEnv globalRef:  #'beginX3F')                                                value: ( exp))) == false) not)                                           	ifTrue: [((schemeEnv globalRef:  #'desugarX2Dbody')                                                value: (((schemeEnv globalRef:  #'beginX2Dsubexpressions')                                                value: ( exp))) value: ( qqX2Dlevel))]                                           	ifFalse: [ (((((schemeEnv globalRef:  #'ifX3F')                                                    value: ( exp))) == false) not)                                               	ifTrue: [((schemeEnv globalRef:  #'cons')                                                    value: ( #'if') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                                    value: (((schemeEnv globalRef:  #'map')                                                    value: (                                               [ :e | ((schemeEnv globalRef:  #'desugar')                                                        value: ( e) value: ( qqX2Dlevel))]) value: (((schemeEnv globalRef:  #'cdr')                                                    value: ( exp))))) value: ( nil))))]                                               	ifFalse: [ (((((schemeEnv globalRef:  #'namedX2DletX3F')                                                        value: ( exp))) == false) not)                                                   	ifTrue: [((schemeEnv globalRef:  #'cons')                                                        value: ( #'let') value: (((schemeEnv globalRef:  #'cons')                                                        value: (((schemeEnv globalRef:  #'letX2Dname')                                                        value: ( exp))) value: (((schemeEnv globalRef:  #'cons')                                                        value: (((schemeEnv globalRef:  #'map')                                                        value: (                                                   [ :binding | ((schemeEnv globalRef:  #'cons')                                                            value: (((schemeEnv globalRef:  #'letX2Dformal')                                                            value: ( binding))) value: (((schemeEnv globalRef:  #'cons')                                                            value: (((schemeEnv globalRef:  #'desugar')                                                            value: (((schemeEnv globalRef:  #'letX2Dinit')                                                            value: ( binding))) value: ( qqX2Dlevel))) value: ( nil))))]) value: (((schemeEnv globalRef:  #'letX2Dbindings')                                                        value: ( exp))))) value: (((schemeEnv globalRef:  #'cons')                                                        value: (((schemeEnv globalRef:  #'desugarX2Dbody')                                                        value: (((schemeEnv globalRef:  #'letX2Dbody')                                                        value: ( exp))) value: ( qqX2Dlevel))) value: ( nil))))))))]                                                   	ifFalse: [ (((((schemeEnv globalRef:  #'memq')                                                            value: (((schemeEnv globalRef:  #'car')                                                            value: ( exp))) value: ( ({ #'let'.  #'letX2A'.  #'letrec'. } asRest)))) == false) not)                                                       	ifTrue: [((schemeEnv globalRef:  #'cons')                                                            value: (((schemeEnv globalRef:  #'car')                                                            value: ( exp))) value: (((schemeEnv globalRef:  #'cons')                                                            value: (((schemeEnv globalRef:  #'map')                                                            value: (                                                       [ :binding | ((schemeEnv globalRef:  #'cons')                                                                value: (((schemeEnv globalRef:  #'letX2Dformal')                                                                value: ( binding))) value: (((schemeEnv globalRef:  #'cons')                                                                value: (((schemeEnv globalRef:  #'desugar')                                                                value: (((schemeEnv globalRef:  #'letX2Dinit')                                                                value: ( binding))) value: ( qqX2Dlevel))) value: ( nil))))]) value: (((schemeEnv globalRef:  #'letX2Dbindings')                                                            value: ( exp))))) value: (((schemeEnv globalRef:  #'cons')                                                            value: (((schemeEnv globalRef:  #'desugarX2Dbody')                                                            value: (((schemeEnv globalRef:  #'letX2Dbody')                                                            value: ( exp))) value: ( qqX2Dlevel))) value: ( nil))))))]                                                       	ifFalse: [ (((((schemeEnv globalRef:  #'quasiquoteX3F')                                                                value: ( exp))) == false) not)                                                           	ifTrue: [ (((((schemeEnv globalRef:  #'zeroX3F')                                                                    value: ( qqX2Dlevel))) == false) not)                                                               	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Dquasiquote')                                                                    value: ( exp) value: ( qqX2Dlevel))]                                                               	ifFalse: [((schemeEnv globalRef:  #'desugar')                                                                    value: (((schemeEnv globalRef:  #'rewrite')                                                                    value: ( exp))) value: ( qqX2Dlevel))]]                                                           	ifFalse: [ (((((schemeEnv globalRef:  #'sugarX3F')                                                                    value: ( exp))) == false) not)                                                               	ifTrue: [((schemeEnv globalRef:  #'desugar')                                                                    value: (((schemeEnv globalRef:  #'rewrite')                                                                    value: ( exp))) value: ( qqX2Dlevel))]                                                               	ifFalse: [((schemeEnv globalRef:  #'mapX2A')                                                                    value: (                                                               [ :e | ((schemeEnv globalRef:  #'desugar')                                                                        value: ( e) value: ( qqX2Dlevel))]) value: ( exp))]]]]]]]]]]]]]] ) . schemeEnv define:  #'setX2DlastX2Dpair'    "set-last-pair"  as: (        [ :list :thing |  (((((schemeEnv globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ thing]               	ifFalse: [ (((((schemeEnv globalRef:  #'not')                        value: (((schemeEnv globalRef:  #'pairX3F')                        value: ( list))))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'error')                        value: ( 'set-last-pair: expected a list') value: ( list))]                   	ifFalse: [                    [ | loop |                        loop :=                        [ :result :lastX2Dpair :old |                         ((( [ :temp95 |                                 ((( temp95) == false) not)                                   	ifTrue: [ temp95]                                   	ifFalse: [((schemeEnv globalRef:  #'not')                                        value: (((schemeEnv globalRef:  #'pairX3F')                                        value: ( old))))].                           ] valueWithArguments: {(((schemeEnv globalRef:  #'nullX3F')                                    value: ( old))). }) == false) not)                           	ifTrue: [ [                             ((schemeEnv globalRef:  #'setX2DcdrX21')                                  value: ( lastX2Dpair) value: ( thing)).                              result.                            ] value]                           	ifFalse: [ [ :new |                                 (((((schemeEnv globalRef:  #'nullX3F')                                        value: ( lastX2Dpair))) == false) not)                                   	ifTrue: [(loop value: ( new) value: ( new) value: (((schemeEnv globalRef:  #'cdr')                                        value: ( old))))]                                   	ifFalse: [ [                                     ((schemeEnv globalRef:  #'setX2DcdrX21')                                          value: ( lastX2Dpair) value: ( new)).                                     (loop value: ( result) value: ( new) value: (((schemeEnv globalRef:  #'cdr')                                          value: ( old)))).                                    ] value].                           ] valueWithArguments: {(((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'car')                                    value: ( old))) value: ( nil))). }]                   ].                   loop valueWithArguments: {                        nil.                         nil.                         list. } ] value]]] ) . schemeEnv define:  #'X25quasiquote'    "%quasiquote"  as: (  ({ #'quote'.  #'quasiquote'. } asRest) ) . schemeEnv define:  #'X25unquote'    "%unquote"  as: (  ({ #'quote'.  #'unquote'. } asRest) ) . schemeEnv define:  #'X25unquoteX2Dsplicing'    "%unquote-splicing"  as: (  ({ #'quote'.  #'unquoteX2Dsplicing'. } asRest) ) . schemeEnv define:  #'rewriteX2Dquasiquote'    "rewrite-quasiquote"  as: (        [ :exp :level |  (((((schemeEnv globalRef:  #'X3D')                    value: ( level) value: ( 00))) == false) not)               	ifTrue: [ (((((schemeEnv globalRef:  #'vectorX3F')                        value: (((schemeEnv globalRef:  #'cadr')                        value: ( exp))))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'cons')                        value: ( #'listX2DX3Evector') value: (((schemeEnv globalRef:  #'cons')                        value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                        value: (((schemeEnv globalRef:  #'vectorX2DX3Elist')                        value: (((schemeEnv globalRef:  #'cadr')                        value: ( exp))))) value: (((schemeEnv globalRef:  #'X2B')                        value: ( level) value: ( 1))))) value: ( nil))))]                   	ifFalse: [((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                        value: (((schemeEnv globalRef:  #'cadr')                        value: ( exp))) value: (((schemeEnv globalRef:  #'X2B')                        value: ( level) value: ( 1))))]]               	ifFalse: [((schemeEnv globalRef:  #'cons')                    value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                    value: ( (schemeEnv globalRef:  #'X25quasiquote')                   ) value: (((schemeEnv globalRef:  #'cons')                    value: (((schemeEnv globalRef:  #'cons')                    value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                    value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                    value: (((schemeEnv globalRef:  #'cadr')                    value: ( exp))) value: (((schemeEnv globalRef:  #'X2B')                    value: ( level) value: ( 1))))) value: (((schemeEnv globalRef:  #'cons')                    value: (((schemeEnv globalRef:  #'cons')                    value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')                    value: ( nil) value: ( nil))))) value: ( nil))))))) value: ( nil))))))]] ) . schemeEnv define:  #'buildX2DquasiX2Dlist'    "build-quasi-list"  as: (        [ :thing :level |  (((((schemeEnv globalRef:  #'not')                    value: (((schemeEnv globalRef:  #'pairX3F')                    value: ( thing))))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'cons')                    value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')                    value: ( thing) value: ( nil))))]               	ifFalse: [ (((((schemeEnv globalRef:  #'pairX3F')                        value: (((schemeEnv globalRef:  #'car')                        value: ( thing))))) == false) not)                   	ifTrue: [ [ :sublist |                         (((((schemeEnv globalRef:  #'quasiquoteX3F')                                value: ( sublist))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'cons')                                value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'rewriteX2Dquasiquote')                                value: ( sublist) value: ( level))) value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                value: (((schemeEnv globalRef:  #'cdr')                                value: ( thing))) value: ( level))) value: ( nil))))))]                           	ifFalse: [ (((((schemeEnv globalRef:  #'unquoteX3F')                                    value: ( sublist))) == false) not)                               	ifTrue: [ (((((schemeEnv globalRef:  #'X3D')                                        value: ( level) value: ( 1))) == false) not)                                   	ifTrue: [((schemeEnv globalRef:  #'cons')                                        value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'desugar')                                        value: (((schemeEnv globalRef:  #'cadr')                                        value: ( sublist))) value: (((schemeEnv globalRef:  #'X2D')                                        value: ( level) value: ( 1))))) value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                        value: (((schemeEnv globalRef:  #'cdr')                                        value: ( thing))) value: ( level))) value: ( nil))))))]                                   	ifFalse: [((schemeEnv globalRef:  #'cons')                                        value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                        value: ( sublist) value: ( level))) value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                        value: (((schemeEnv globalRef:  #'cdr')                                        value: ( thing))) value: ( level))) value: ( nil))))))]]                               	ifFalse: [ (((((schemeEnv globalRef:  #'unquoteX2DsplicingX3F')                                        value: ( sublist))) == false) not)                                   	ifTrue: [ (((((schemeEnv globalRef:  #'X3D')                                            value: ( level) value: ( 1))) == false) not)                                       	ifTrue: [((schemeEnv globalRef:  #'cons')                                            value: ( #'setX2DlastX2Dpair') value: (((schemeEnv globalRef:  #'cons')                                            value: (((schemeEnv globalRef:  #'desugar')                                            value: (((schemeEnv globalRef:  #'cadr')                                            value: ( sublist))) value: (((schemeEnv globalRef:  #'X2D')                                            value: ( level) value: ( 1))))) value: (((schemeEnv globalRef:  #'cons')                                            value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                            value: (((schemeEnv globalRef:  #'cdr')                                            value: ( thing))) value: ( level))) value: ( nil))))))]                                       	ifFalse: [((schemeEnv globalRef:  #'cons')                                            value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                                            value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                            value: ( sublist) value: (((schemeEnv globalRef:  #'X2D')                                            value: ( level) value: ( 1))))) value: (((schemeEnv globalRef:  #'cons')                                            value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                            value: (((schemeEnv globalRef:  #'cdr')                                            value: ( thing))) value: ( level))) value: ( nil))))))]]                                   	ifFalse: [((schemeEnv globalRef:  #'cons')                                        value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                        value: ( sublist) value: ( level))) value: (((schemeEnv globalRef:  #'cons')                                        value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                        value: (((schemeEnv globalRef:  #'cdr')                                        value: ( thing))) value: ( level))) value: ( nil))))))]]].                   ] valueWithArguments: {(((schemeEnv globalRef:  #'car')                            value: ( thing))). }]                   	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                            value: (((schemeEnv globalRef:  #'car')                            value: ( thing))) value: ( #'unquote'))) == false) not)                       	ifTrue: [ (((((schemeEnv globalRef:  #'X3D')                                value: ( level) value: ( 1))) == false) not)                           	ifTrue: [ (((((schemeEnv globalRef:  #'pairX3F')                                    value: (((schemeEnv globalRef:  #'cdr')                                    value: ( thing))))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'desugar')                                    value: (((schemeEnv globalRef:  #'cadr')                                    value: ( thing))) value: (((schemeEnv globalRef:  #'X2D')                                    value: ( level) value: ( 1))))]                               	ifFalse: [((schemeEnv globalRef:  #'cdr')                                    value: ( thing))]]                           	ifFalse: [((schemeEnv globalRef:  #'cons')                                value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                                value: ( (schemeEnv globalRef:  #'X25unquote')                               ) value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'cons')                                value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                                value: (((schemeEnv globalRef:  #'cadr')                                value: ( thing))) value: (((schemeEnv globalRef:  #'X2D')                                value: ( level) value: ( 1))))) value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'cons')                                value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')                                value: ( nil) value: ( nil))))) value: ( nil))))))) value: ( nil))))))]]                       	ifFalse: [((schemeEnv globalRef:  #'cons')                            value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                            value: (((schemeEnv globalRef:  #'cons')                            value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')                            value: (((schemeEnv globalRef:  #'car')                            value: ( thing))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')                            value: (((schemeEnv globalRef:  #'buildX2DquasiX2Dlist')                            value: (((schemeEnv globalRef:  #'cdr')                            value: ( thing))) value: ( level))) value: ( nil))))))]]]] ) . schemeEnv define:  #'desugarX2Dbody'    "desugar-body"  as: (        [ :body :qqX2Dlevel |             [ | loop |                loop :=                [ :form :forms :defines :others |                 (((((schemeEnv globalRef:  #'defineX3F')                        value: ( form))) == false) not)                   	ifTrue: [ (((((schemeEnv globalRef:  #'nullX3F')                            value: ( forms))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'error')                            value: ( 'expected body') value: ( body))]                       	ifFalse: [(loop                        valueWithArguments: { ((schemeEnv globalRef:  #'car')                            value: ( forms)). ((schemeEnv globalRef:  #'cdr')                            value: ( forms)). ((schemeEnv globalRef:  #'cons')                            value: ( form) value: ( defines)).  others.})]]                   	ifFalse: [ (((((schemeEnv globalRef:  #'nullX3F')                            value: ( forms))) == false) not)                       	ifTrue: [ (((((schemeEnv globalRef:  #'nullX3F')                                value: ( defines))) == false) not)                           	ifTrue: [ [ :body |                                 (((((schemeEnv globalRef:  #'nullX3F')                                        value: (((schemeEnv globalRef:  #'cdr')                                        value: ( body))))) == false) not)                                   	ifTrue: [((schemeEnv globalRef:  #'car')                                        value: ( body))]                                   	ifFalse: [((schemeEnv globalRef:  #'cons')                                        value: ( #'begin') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                        value: ( body) value: ( nil))))].                           ] valueWithArguments: {(((schemeEnv globalRef:  #'map')                                    value: (                               [ :exp | ((schemeEnv globalRef:  #'desugar')                                        value: ( exp) value: ( qqX2Dlevel))]) value: ( body))). }]                           	ifFalse: [((schemeEnv globalRef:  #'cons')                                value: ( #'letrec') value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'map')                                value: (                           [ :def | ((schemeEnv globalRef:  #'list')                                    value: (((schemeEnv globalRef:  #'definitionX2Dname')                                    value: ( def))) value: (((schemeEnv globalRef:  #'desugar')                                    value: (((schemeEnv globalRef:  #'definitionX2Dbody')                                    value: ( def))) value: ( qqX2Dlevel))))]) value: (((schemeEnv globalRef:  #'reverse')                                value: ( defines))))) value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'desugarX2Dbody')                                value: (((schemeEnv globalRef:  #'reverse')                                value: (((schemeEnv globalRef:  #'cons')                                value: ( form) value: ( others))))) value: ( qqX2Dlevel))) value: ( nil))))))]]                       	ifFalse: [(loop                        valueWithArguments: { ((schemeEnv globalRef:  #'car')                            value: ( forms)). ((schemeEnv globalRef:  #'cdr')                            value: ( forms)).  defines. ((schemeEnv globalRef:  #'cons')                            value: ( form) value: ( others)).})]]           ].           loop valueWithArguments: {               ((schemeEnv globalRef:  #'car')                    value: ( body)).                ((schemeEnv globalRef:  #'cdr')                    value: ( body)).                 nil.                 nil. } ] value] ) . schemeEnv define:  #'sugarX3F'    "sugar?"  as: (        [ :exp |  (((((schemeEnv globalRef:  #'pairX3F')                    value: ( exp))) == false) not)               	ifTrue: [((schemeEnv globalRef:  #'member')                    value: (((schemeEnv globalRef:  #'car')                    value: ( exp))) value: ( ({ #'and'.  #'or'.  #'cond'.  #'do'.  #'case'.  #'delay'.  #'string'.  #'vector'. } asRest)))]               	ifFalse: [ false]] ) . schemeEnv define:  #'unspecified'  as: (  'Unspecified' ) . schemeEnv define:  #'rewrite'  as: (        [ :exp |  (((((schemeEnv globalRef:  #'not')                    value: (((schemeEnv globalRef:  #'pairX3F')                    value: ( exp))))) == false) not)               	ifTrue: [ exp]               	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                        value: (((schemeEnv globalRef:  #'car')                        value: ( exp))) value: ( #'and'))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Dand')                        value: ( exp))]                   	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                            value: (((schemeEnv globalRef:  #'car')                            value: ( exp))) value: ( #'or'))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Dor')                            value: ( exp))]                       	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                value: (((schemeEnv globalRef:  #'car')                                value: ( exp))) value: ( #'cond'))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Dcond')                                value: ( exp))]                           	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                    value: (((schemeEnv globalRef:  #'car')                                    value: ( exp))) value: ( #'do'))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Ddo')                                    value: ( exp))]                               	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                        value: (((schemeEnv globalRef:  #'car')                                        value: ( exp))) value: ( #'case'))) == false) not)                                   	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Dcase')                                        value: ( exp))]                                   	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                            value: (((schemeEnv globalRef:  #'car')                                            value: ( exp))) value: ( #'delay'))) == false) not)                                       	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Ddelay')                                            value: ( exp))]                                       	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                                value: (((schemeEnv globalRef:  #'car')                                                value: ( exp))) value: ( #'string'))) == false) not)                                           	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Dstring')                                                value: ( exp))]                                           	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                                    value: (((schemeEnv globalRef:  #'car')                                                    value: ( exp))) value: ( #'vector'))) == false) not)                                               	ifTrue: [((schemeEnv globalRef:  #'rewriteX2Dvector')                                                    value: ( exp))]                                               	ifFalse: [ exp]]]]]]]]]] ) . schemeEnv define:  #'rewriteX2Dand'    "rewrite-and"  as: (        [ :exp |  [ :conjuncts |                 (((((schemeEnv globalRef:  #'nullX3F')                        value: ( conjuncts))) == false) not)                   	ifTrue: [ true]                   	ifFalse: [ (((((schemeEnv globalRef:  #'nullX3F')                            value: (((schemeEnv globalRef:  #'cdr')                            value: ( conjuncts))))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'car')                            value: ( conjuncts))]                       	ifFalse: [((schemeEnv globalRef:  #'cons')                            value: ( #'if') value: (((schemeEnv globalRef:  #'cons')                            value: (((schemeEnv globalRef:  #'car')                            value: ( conjuncts))) value: (((schemeEnv globalRef:  #'cons')                            value: (((schemeEnv globalRef:  #'cons')                            value: ( #'and') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                            value: (((schemeEnv globalRef:  #'cdr')                            value: ( conjuncts))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')                            value: ( false) value: ( nil))))))))]].           ] valueWithArguments: {(((schemeEnv globalRef:  #'cdr')                    value: ( exp))). }] ) . schemeEnv define:  #'rewriteX2Dor'    "rewrite-or"  as: (        [ :exp |  [ :disjuncts |                 (((((schemeEnv globalRef:  #'nullX3F')                        value: ( disjuncts))) == false) not)                   	ifTrue: [ false]                   	ifFalse: [ (((((schemeEnv globalRef:  #'nullX3F')                            value: (((schemeEnv globalRef:  #'cdr')                            value: ( disjuncts))))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'car')                            value: ( disjuncts))]                       	ifFalse: [ [ :temp :test :others |                            ((schemeEnv globalRef:  #'cons')                                value: ( #'let') value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'cons')                                value: ( temp) value: (((schemeEnv globalRef:  #'cons')                                value: ( test) value: ( nil))))) value: ( nil))) value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'cons')                                value: ( #'if') value: (((schemeEnv globalRef:  #'cons')                                value: ( temp) value: (((schemeEnv globalRef:  #'cons')                                value: ( temp) value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'cons')                                value: ( #'or') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                value: ( others) value: ( nil))))) value: ( nil))))))))) value: ( nil)))))).                       ] valueWithArguments: {(((schemeEnv globalRef:  #'gensym')                                value: ( 'temp'))). (((schemeEnv globalRef:  #'car')                                value: ( disjuncts))). (((schemeEnv globalRef:  #'cdr')                                value: ( disjuncts))). }]].           ] valueWithArguments: {(((schemeEnv globalRef:  #'cdr')                    value: ( exp))). }] ) . schemeEnv define:  #'rewriteX2Dcond'    "rewrite-cond"  as: (        [ :exp |  [ :clauses |                 (((((schemeEnv globalRef:  #'nullX3F')                        value: ( clauses))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'cons')                        value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')                        value: ( (schemeEnv globalRef:  #'unspecified')                       ) value: ( nil))))]                   	ifFalse: [ (((((schemeEnv globalRef:  #'nullX3F')                            value: (((schemeEnv globalRef:  #'cdar')                            value: ( clauses))))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'cons')                            value: ( #'or') value: (((schemeEnv globalRef:  #'cons')                            value: (((schemeEnv globalRef:  #'caar')                            value: ( clauses))) value: (((schemeEnv globalRef:  #'cons')                            value: (((schemeEnv globalRef:  #'cons')                            value: ( #'cond') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                            value: (((schemeEnv globalRef:  #'cdr')                            value: ( clauses))) value: ( nil))))) value: ( nil))))))]                       	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                value: (((schemeEnv globalRef:  #'cadar')                                value: ( clauses))) value: ( #'X3DX3E'))) == false) not)                           	ifTrue: [ [ :result :test :recipient :others |                                ((schemeEnv globalRef:  #'cons')                                    value: ( #'let') value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( result) value: (((schemeEnv globalRef:  #'cons')                                    value: ( test) value: ( nil))))) value: ( nil))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'if') value: (((schemeEnv globalRef:  #'cons')                                    value: ( result) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( recipient) value: (((schemeEnv globalRef:  #'cons')                                    value: ( result) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'cond') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                    value: ( others) value: ( nil))))) value: ( nil))))))))) value: ( nil)))))).                           ] valueWithArguments: {(((schemeEnv globalRef:  #'gensym')                                    value: ( #'result'))). (((schemeEnv globalRef:  #'caar')                                    value: ( clauses))). (((schemeEnv globalRef:  #'caddar')                                    value: ( clauses))). (((schemeEnv globalRef:  #'cdr')                                    value: ( clauses))). }]                           	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                    value: (((schemeEnv globalRef:  #'caar')                                    value: ( clauses))) value: ( #'else'))) == false) not)                               	ifTrue: [((schemeEnv globalRef:  #'cons')                                    value: ( #'begin') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                    value: (((schemeEnv globalRef:  #'cdar')                                    value: ( clauses))) value: ( nil))))]                               	ifFalse: [((schemeEnv globalRef:  #'cons')                                    value: ( #'if') value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'caar')                                    value: ( clauses))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'begin') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                    value: (((schemeEnv globalRef:  #'cdar')                                    value: ( clauses))) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'cond') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                    value: (((schemeEnv globalRef:  #'cdr')                                    value: ( clauses))) value: ( nil))))) value: ( nil))))))))]]]].           ] valueWithArguments: {(((schemeEnv globalRef:  #'cdr')                    value: ( exp))). }] ) . schemeEnv define:  #'rewriteX2Ddo'    "rewrite-do"  as: (        [ :exp |  [ :loopX2Dname :locals :exits :commands |                 [ :varX2Dinits :steps :test :exps |                    ((schemeEnv globalRef:  #'cons')                        value: ( #'let') value: (((schemeEnv globalRef:  #'cons')                        value: ( loopX2Dname) value: (((schemeEnv globalRef:  #'cons')                        value: ( varX2Dinits) value: (((schemeEnv globalRef:  #'cons')                        value: (((schemeEnv globalRef:  #'cons')                        value: ( #'if') value: (((schemeEnv globalRef:  #'cons')                        value: ( test) value: (((schemeEnv globalRef:  #'cons')                        value: (((schemeEnv globalRef:  #'cons')                        value: ( #'begin') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                        value: ( exps) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')                        value: (((schemeEnv globalRef:  #'cons')                        value: ( #'begin') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                        value: ( commands) value: (((schemeEnv globalRef:  #'cons')                        value: (((schemeEnv globalRef:  #'cons')                        value: ( loopX2Dname) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                        value: ( steps) value: ( nil))))) value: ( nil))))))) value: ( nil))))))))) value: ( nil)))))))).               ] valueWithArguments: {(((schemeEnv globalRef:  #'map')                        value: (                   [ :vis | ((schemeEnv globalRef:  #'list')                            value: (((schemeEnv globalRef:  #'car')                            value: ( vis))) value: (((schemeEnv globalRef:  #'cadr')                            value: ( vis))))]) value: ( locals))). (((schemeEnv globalRef:  #'map')                        value: (                   [ :vis |  (((((schemeEnv globalRef:  #'nullX3F')                                value: (((schemeEnv globalRef:  #'cddr')                                value: ( vis))))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'car')                                value: ( vis))]                           	ifFalse: [((schemeEnv globalRef:  #'caddr')                                value: ( vis))]]) value: ( locals))). (((schemeEnv globalRef:  #'car')                        value: ( exits))). (((schemeEnv globalRef:  #'cdr')                        value: ( exits))). }.           ] valueWithArguments: {(((schemeEnv globalRef:  #'gensym')                    value: ( 'do-loop'))). (((schemeEnv globalRef:  #'cadr')                    value: ( exp))). (((schemeEnv globalRef:  #'caddr')                    value: ( exp))). (((schemeEnv globalRef:  #'cdddr')                    value: ( exp))). }] ) . schemeEnv define:  #'rewriteX2Dcase'    "rewrite-case"  as: (        [ :exp |  [ :clauses |                 (((((schemeEnv globalRef:  #'nullX3F')                        value: ( clauses))) == false) not)                   	ifTrue: [((schemeEnv globalRef:  #'cons')                        value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')                        value: ( (schemeEnv globalRef:  #'unspecified')                       ) value: ( nil))))]                   	ifFalse: [ (((((schemeEnv globalRef:  #'nullX3F')                            value: (((schemeEnv globalRef:  #'cdr')                            value: ( clauses))))) == false) not)                       	ifTrue: [((schemeEnv globalRef:  #'car')                            value: ( clauses))]                       	ifFalse: [ (((((schemeEnv globalRef:  #'eqX3F')                                value: (((schemeEnv globalRef:  #'caadr')                                value: ( clauses))) value: ( #'else'))) == false) not)                           	ifTrue: [((schemeEnv globalRef:  #'cons')                                value: ( #'begin') value: (((schemeEnv globalRef:  #'cons')                                value: (((schemeEnv globalRef:  #'car')                                value: ( clauses))) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                value: (((schemeEnv globalRef:  #'cdadr')                                value: ( clauses))) value: ( nil))))))]                           	ifFalse: [ [ :keyX2Dname :key :datums :exps :others |                                ((schemeEnv globalRef:  #'cons')                                    value: ( #'let') value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( keyX2Dname) value: (((schemeEnv globalRef:  #'cons')                                    value: ( key) value: ( nil))))) value: ( nil))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'if') value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'memv') value: (((schemeEnv globalRef:  #'cons')                                    value: ( keyX2Dname) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'quote') value: (((schemeEnv globalRef:  #'cons')                                    value: ( datums) value: ( nil))))) value: ( nil))))))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'begin') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                    value: ( exps) value: ( nil))))) value: (((schemeEnv globalRef:  #'cons')                                    value: (((schemeEnv globalRef:  #'cons')                                    value: ( #'case') value: (((schemeEnv globalRef:  #'cons')                                    value: ( keyX2Dname) value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                                    value: ( others) value: ( nil))))))) value: ( nil))))))))) value: ( nil)))))).                           ] valueWithArguments: {(((schemeEnv globalRef:  #'gensym')                                    value: ( #'key'))). (((schemeEnv globalRef:  #'car')                                    value: ( clauses))). (((schemeEnv globalRef:  #'caadr')                                    value: ( clauses))). (((schemeEnv globalRef:  #'cdadr')                                    value: ( clauses))). (((schemeEnv globalRef:  #'cddr')                                    value: ( clauses))). }]]].           ] valueWithArguments: {(((schemeEnv globalRef:  #'cdr')                    value: ( exp))). }] ) . schemeEnv define:  #'rewriteX2Ddelay'    "rewrite-delay"  as: (        [ :exp | ((schemeEnv globalRef:  #'cons')                value: ( #'makeX2Dpromise') value: (((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'cons')                value: ( #'lambda') value: (((schemeEnv globalRef:  #'cons')                value: ( nil) value: (((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'cadr')                value: ( exp))) value: ( nil))))))) value: ( nil))))] ) . schemeEnv define:  #'rewriteX2Dlist'    "rewrite-list"  as: (        [ :exp |  (((((schemeEnv globalRef:  #'nullX3F')                    value: (((schemeEnv globalRef:  #'cdr')                    value: ( exp))))) == false) not)               	ifTrue: [ ({ #'quote'.  nil. } asRest)]               	ifFalse: [((schemeEnv globalRef:  #'cons')                    value: ( #'cons') value: (((schemeEnv globalRef:  #'cons')                    value: (((schemeEnv globalRef:  #'cadr')                    value: ( exp))) value: (((schemeEnv globalRef:  #'cons')                    value: (((schemeEnv globalRef:  #'cons')                    value: ( #'list') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                    value: (((schemeEnv globalRef:  #'cddr')                    value: ( exp))) value: ( nil))))) value: ( nil))))))]] ) . schemeEnv define:  #'rewriteX2Dstring'    "rewrite-string"  as: (        [ :exp | ((schemeEnv globalRef:  #'cons')                value: ( #'listX2DX3Estring') value: (((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'cons')                value: ( #'list') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                value: (((schemeEnv globalRef:  #'cdr')                value: ( exp))) value: ( nil))))) value: ( nil))))] ) . schemeEnv define:  #'rewriteX2Dvector'    "rewrite-vector"  as: (        [ :exp | ((schemeEnv globalRef:  #'cons')                value: ( #'listX2DX3Evector') value: (((schemeEnv globalRef:  #'cons')                value: (((schemeEnv globalRef:  #'cons')                value: ( #'list') value: (((schemeEnv globalRef:  #'setX2DlastX2Dpair')                value: (((schemeEnv globalRef:  #'cdr')                value: ( exp))) value: ( nil))))) value: ( nil))))] ) .! !!SmallScheme class methodsFor: 'instance creation' stamp: 'KenD 5/14/2002 18:22'!newEnv	"Return a new instance with an empty user environment"	^(self new initialize)! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/14/2002 08:38'!define: nameSymbol as: value	R5RSEnv at: nameSymbol put: value.	^value! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/24/2002 10:32'!dynamicDefine: var as: val	| valueStack dynamicDict |	dynamicDict := (Process2 dynamicVars).	valueStack := dynamicDict at: var ifAbsent: [nil].	(valueStack isNil)	   ifTrue:  [dynamicDict at: var put: (Stack with: val).]	   ifFalse: [valueStack push: val].  "already defined"! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/20/2002 14:44'!dynamicPop: var	| valueStack | 	valueStack := (Process dynamicVars) at: var 				ifAbsent: [Error signal: 			 		  'Attempt to remove undefined dynamic variable: ' ,			 		  (var toSchemeIdentifier)].	(valueStack isEmpty)		ifTrue: [Error signal: 'Attempt to remove undefined dynamic variable: ' ,			 	   (var toSchemeIdentifier)].	^(valueStack pop)   "Note: typically ignored"! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/24/2002 10:28'!dynamicPush: var as: val	| valueStack |	valueStack := (Process2 dynamicVars) at: var ifAbsent: [nil].	(valueStack isNil)	   ifTrue:  [self dynamicDefine: var as: val.] "ignore the bug"	   ifFalse: [valueStack push: val].! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/24/2002 11:14'!dynamicRef: var	"last entry is most recent value"	^(((Process dynamicVars) at: var) topValue) ! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/20/2002 14:45'!dynamicRef: var withDefault: aBlock	| valueStack | 	"(Process dynamicVars) isNil ifTrue: [^(aBlock value)]. @@DEBUG@@"	valueStack := (Process dynamicVars) at: var 						 ifAbsent: [^(aBlock value)].	(valueStack isEmpty) ifTrue: [^(aBlock value)].	^(valueStack topValue) "last entry is most recent value".! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/20/2002 14:45'!dynamicSetX21: var as: newVal	"dynamicSet!!"	| valueStack |	valueStack := (Process dynamicVars) at: var 				ifAbsent: [Error signal: 			 		  'Attempt to access undefined dynamic variable: ' ,			 		  (var toSchemeIdentifier)].	(valueStack isEmpty)		ifTrue: [Error signal: 'Attempt to set!! undefined dynamic variable: ' ,			 	   (var toSchemeIdentifier)].	valueStack topValue: newVal.! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 6/18/2002 13:20'!fileinLibrary	"Reread Scheme library code from source files"	"NB: trace is instance, others class".	#( 'numbers'	'booleans'		'lists' 	   'symbols'	'characters'	'strings'	   'vectors'	'control'		'io'	   'eval'		'ratize'		'read' 	   'string2number'	'transcript' 	   'pretty-print'	'format'	'trace' 	) 	do: [ :libName |		  (FileStream fileNamed: (LibraryDirPrefix , libName , '.sts')) fileIn].	self fileinTranslator.! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 6/18/2002 13:11'!fileinTranslator	"Reread xlate (Scheme->Smalltalk) code from source files"	#( 'xlate1' 'xlate2' 'xlate3')	do: [ :testName |		  (FileStream fileNamed: (LibraryDirPrefix , testName , '.sts')) fileIn].! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/16/2002 10:40'!globalRef: nameSymbol	^(R5RSEnv at: nameSymbol	     ifAbsent: 		[Error signal: 		 'Undefined global name: ' , (nameSymbol asSchemeString)])! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 6/18/2002 13:12'!initLibrary	"add library code to R5RSEnv"	self initNumbers.	self initBooleans.	self initLists.	self initSymbols.	self initCharacters.  	self initStrings.   	self initVectors. 	self initControl.     	self initIo.   	self initRatize.	self initRead.	self initString2number.	"@@ self initTranscript."	self initFormat.	self initPrettyX2Dprint.! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 6/8/2002 19:19'!initialize	"Create and initialize R5RS Scheme implementation/global Environment"	R5RSEnv := Dictionary new.	self libraryDirPrefix: '/usr/local/src/Squeak/ProtoScheme/out/'. 	"Add core definitions to R5RSEnv"	"EQUALITY"	SmallScheme define: #'eqX3F' as: [:a :b | (a == b)]. "eq?"	SmallScheme define: #'eqvX3F'    "eqv?"                     as: [:a :b | 						 ((a == b) |				   		    ((a isKindOf: Number) &                             (b isKindOf: Number) &                             (a = b)))					].	SmallScheme define: #'equalX3F'   "equal?"                              as: [:a :b | ((a == b) | (a = b))].	"ERROR"	SmallScheme define: #'error' 			      as: ([:message :irritant|						((irritant size) = 0)						ifTrue:  [Error signal: (message asString)]						ifFalse: [ | msg |							msg := ((message asString) , ': ').							irritant do: [ :elt | msg := msg , ' ' , (elt asString)].				    		Error signal: msg.]					   ] withLastArgRest).	SmallScheme define: #'warning' 			      as: [:message :irritant|				     Warning signal: 				       ((message asString) , ': ',					 (irritant asSchemeObjString)).].	SmallScheme define: #'nil' as: nil. "theEmptyList".	"EVERYTHING ELSE IS TRANSLATED BY MACHINE INTO INIT METHODS"	self initLibrary.	^self! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/20/2002 14:30'!libraryDirPrefix	^LibraryDirPrefix! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 5/20/2002 14:30'!libraryDirPrefix: aPathString	LibraryDirPrefix := aPathString.! !!SmallScheme class methodsFor: 'private' stamp: 'KenD 6/8/2002 19:30'!runTestSuite	"Open a transcript and run the translated test suite"	| scheme |	scheme _ SmallScheme newEnv.	"scheme fileinTestSuite."	scheme runTestSuite! !!SmallScheme class methodsFor: 'initialization'!initBooleans SmallScheme define:  #'booleanX3F'    "boolean?"  as: (        [ :obj |  ( obj isKindOf: Boolean)] ) . SmallScheme define:  #'not'  as: (        [ :b |  ((( ( b == false)) == false) not)               	ifTrue: [ true]               	ifFalse: [ false]] ) .! !!SmallScheme class methodsFor: 'initialization'!initCharacters SmallScheme define:  #'charX3F'    "char?"  as: (        [ :obj |  ( obj isKindOf: Character)] ) . SmallScheme define:  #'charX3DX3F'    "char=?"  as: (        [ :c1 :c2 |  ( c1 = c2)] ) . SmallScheme define:  #'charX3CX3F'    "char<?"  as: (        [ :c1 :c2 |  ( c1 < c2)] ) . SmallScheme define:  #'charX3EX3F'    "char>?"  as: (        [ :c1 :c2 |  ( c1 > c2)] ) . SmallScheme define:  #'charX3EX3DX3F'    "char>=?"  as: (        [ :c1 :c2 |  ( c1 >= c2)] ) . SmallScheme define:  #'charX3CX3DX3F'    "char<=?"  as: (        [ :c1 :c2 |  ( c1 <= c2)] ) . SmallScheme define:  #'charX2DciX3DX3F'    "char-ci=?"  as: (        [ :c1 :c2 |  ( ( c1 asLowercase) = ( c2 asLowercase))] ) . SmallScheme define:  #'charX2DciX3CX3F'    "char-ci<?"  as: (        [ :c1 :c2 |  ( ( c1 asLowercase) < ( c2 asLowercase))] ) . SmallScheme define:  #'charX2DciX3EX3F'    "char-ci>?"  as: (        [ :c1 :c2 |  ( ( c1 asLowercase) > ( c2 asLowercase))] ) . SmallScheme define:  #'charX2DciX3CX3DX3F'    "char-ci<=?"  as: (        [ :c1 :c2 |  ( ( c1 asLowercase) <= ( c2 asLowercase))] ) . SmallScheme define:  #'charX2DciX3EX3DX3F'    "char-ci>=?"  as: (        [ :c1 :c2 |  ( ( c1 asLowercase) >= ( c2 asLowercase))] ) . SmallScheme define:  #'charX2DalphabeticX3F'    "char-alphabetic?"  as: (        [ :c |  [ :temp18 |                 ((( temp18) == false) not)                   	ifTrue: [ temp18]                   	ifFalse: [((SmallScheme globalRef:  #'charX2DlowerX2DcaseX3F')                        value: ( c))].           ] valueWithArguments: {(((SmallScheme globalRef:  #'charX2DupperX2DcaseX3F')                    value: ( c))). }] ) . SmallScheme define:  #'charX2DnumericX3F'    "char-numeric?"  as: (        [ :c |  (((((SmallScheme globalRef:  #'charX3EX3DX3F')                    value: ( c) value: ( $0))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'charX3CX3DX3F')                    value: ( c) value: ( $9))]               	ifFalse: [ false]] ) . SmallScheme define:  #'charX2DwhitespaceX3F'    "char-whitespace?"  as: (        [ :c |  ( ( c asciiValue) <= 32)] ) . SmallScheme define:  #'charX2DnewlineX3F'    "char-newline?"  as: (        [ :c |  [ :temp19 |                 ((( temp19) == false) not)                   	ifTrue: [ temp19]                   	ifFalse: [ ( c  asciiValue = 13)].           ] valueWithArguments: {( ( c  asciiValue  = 10)). }] ) . SmallScheme define:  #'charX2DupperX2DcaseX3F'    "char-upper-case?"  as: (        [ :c |  (((((SmallScheme globalRef:  #'charX3EX3DX3F')                    value: ( c) value: ( $A))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'charX3CX3DX3F')                    value: ( c) value: ( $Z))]               	ifFalse: [ false]] ) . SmallScheme define:  #'charX2DlowerX2DcaseX3F'    "char-lower-case?"  as: (        [ :c |  (((((SmallScheme globalRef:  #'charX3EX3DX3F')                    value: ( c) value: ( $a))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'charX3CX3DX3F')                    value: ( c) value: ( $z))]               	ifFalse: [ false]] ) . SmallScheme define:  #'charX2DX3Einteger'    "char->integer"  as: (        [ :c |  ( c asciiValue)] ) . SmallScheme define:  #'integerX2DX3Echar'    "integer->char"  as: (        [ :n |  ( n asCharacter)] ) . SmallScheme define:  #'charX2Dupcase'    "char-upcase"  as: (        [ :c |  ( c asUppercase)] ) . SmallScheme define:  #'charX2Ddowncase'    "char-downcase"  as: (        [ :c |  ( c asLowercase)] ) .! !!SmallScheme class methodsFor: 'initialization'!initControl SmallScheme define:  #'procedureX3F'    "procedure?"  as: (        [ :obj |  ( obj isKindOf: BlockClosure)] ) . SmallScheme define:  #'apply'  as: (        [ :proc :args |            args := args asRest.            [ :key20 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key20) value: ( ({ 00. } asRest)))) == false) not)                   	ifTrue: [(proc value)]                   	ifFalse: [ [ :key21 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key21) value: ( ({ 1. } asRest)))) == false) not)                           	ifTrue: [ [ :arg |                                 ((( ( arg == nil)) == false) not)                                   	ifTrue: [(proc value)]                                   	ifFalse: [ ( proc valueWithArguments: ( arg asArray))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'car')                                    value: ( args))). }]                           	ifFalse: [ [                              key21.                                                          [ :lp |                                [ :arglist |                                   [                                    (((((SmallScheme globalRef:  #'not')                                            value: (((SmallScheme globalRef:  #'listX3F')                                            value: ( arglist))))) == false) not)                                       	ifTrue: [((SmallScheme globalRef:  #'error')                                            value: ( 'APPLY requires a list as the last argument') value: ( args))].                                   ((SmallScheme globalRef:  #'setX2DcdrX21')                                        value: ( lp) value: (((SmallScheme globalRef:  #'cdr')                                        value: ( arglist)))).                                   ((SmallScheme globalRef:  #'setX2DcarX21')                                        value: ( lp) value: (((SmallScheme globalRef:  #'car')                                        value: ( arglist)))).                                    ( proc valueWithArguments: ( args asArray)).                                  ] value                               ] value: (((SmallScheme globalRef:  #'car')                                    value: ( lp)))                             ] value: (((SmallScheme globalRef:  #'lastX2Dpair')                                  value: ( args))).                            ] value].                   ] valueWithArguments: {( key20). }].           ] valueWithArguments: {(((SmallScheme globalRef:  #'length')                    value: ( args))). }] withLastArgRest  ) . SmallScheme define:  #'map'  as: (        [ :fn :list |            list := list asRest.            (((((SmallScheme globalRef:  #'nullX3F')                    value: (((SmallScheme globalRef:  #'car')                    value: ( list))))) == false) not)               	ifTrue: [ nil]               	ifFalse: [ (((((SmallScheme globalRef:  #'pairX3F')                        value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'cons')                        value: (((SmallScheme globalRef:  #'apply')                        value: ( fn) value: ( ( list collect: (SmallScheme globalRef:  #'car')                       )))) value: (((SmallScheme globalRef:  #'apply')                        value: ( (SmallScheme globalRef:  #'map')                       ) value: ( fn) value: ( ( list collect: (SmallScheme globalRef:  #'cdr')                       )))))]                   	ifFalse: [((SmallScheme globalRef:  #'apply')                        value: ( fn) value: ( list))]]] withLastArgRest  ) . SmallScheme define:  #'any'  as: (        [ :pred :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ false]               	ifFalse: [ ((((pred value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'car')                        value: ( list))]                   	ifFalse: [((SmallScheme globalRef:  #'any')                        value: ( pred) value: (((SmallScheme globalRef:  #'cdr')                        value: ( list))))]]] ) . SmallScheme define:  #'forX2Deach'    "for-each"  as: (        [ :proc :first :rest |            rest := rest asRest.            (((((SmallScheme globalRef:  #'nullX3F')                    value: ( rest))) == false) not)               	ifTrue: [ (((((SmallScheme globalRef:  #'not')                        value: (((SmallScheme globalRef:  #'nullX3F')                        value: ( first))))) == false) not)                   	ifTrue: [ ( first do: proc)]]               	ifFalse: [                [ | loop |                    loop :=                    [ :lists |                     (((((SmallScheme globalRef:  #'not')                            value: (((SmallScheme globalRef:  #'any')                            value: ( (SmallScheme globalRef:  #'nullX3F')                           ) value: ( lists))))) == false) not)                       	ifTrue: [ [                         ((SmallScheme globalRef:  #'apply')                              value: ( proc) value: ( ( (SmallScheme globalRef:  #'list')                              collect: (SmallScheme globalRef:  #'car')                             ))).                         (loop value: ( proc) value: ( ( (SmallScheme globalRef:  #'list')                              collect: (SmallScheme globalRef:  #'cdr')                             ))).                        ] value]               ].               loop valueWithArguments: {                   ((SmallScheme globalRef:  #'cons')                        value: ( first) value: ( rest)). } ] value]] withLastArgRest  ) . SmallScheme define:  #'makeX2Dpromise'    "make-promise"  as: (        [ :thunk |  [ :forcedX3F :result |                               [ ((( forcedX3F) == false) not)                       	ifTrue: [ result]                       	ifFalse: [ [ :whatever |                             ((( forcedX3F) == false) not)                               	ifTrue: [ result]                               	ifFalse: [ [                                 (result :=  whatever).                                 (forcedX3F :=  true).                                 (thunk :=  false).                                  result.                                ] value].                       ] valueWithArguments: {((thunk value)). }]].           ] valueWithArguments: {( false). ( false). }] ) . SmallScheme define:  #'force'  as: (        [ :promise | (promise value)] ) . SmallScheme define:  #'callX2DwithX2Dvalues'    "call-with-values"  as: (        [ :producer :consumer |  ( consumer valueWithArguments:(producer value))] ) . SmallScheme define:  #'dynamicX2Dwind'    "dynamic-wind"  as: (        [ :before :thunk :after |  (           [ [                 (before value).                 (thunk value).                ] value] ensure:           [(after value)])] ) .! !!SmallScheme class methodsFor: 'initialization'!initFormat SmallScheme define:  #'format'  as: (  [ :lastX2DwasX2Dnewline :asciiX2Dtab :asciiX2Dff :dontX2Dprint |                       [ :X3CoutputX2DportX3E :X3CformatX2DstringX3E :X3CargsX3E |                X3CargsX3E := X3CargsX3E asRest.                               [ | port returnX2Dvalue |                                 port := ( (((((SmallScheme globalRef:  #'outputX2DportX3F')                          value: ( X3CoutputX2DportX3E))) == false) not)                     	ifTrue: [ X3CoutputX2DportX3E]                     	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                              value: ( X3CoutputX2DportX3E) value: ( true))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                              value)]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( X3CoutputX2DportX3E) value: ( false))) == false) not)                             	ifTrue: [((SmallScheme globalRef:  #'openX2DoutputX2Dstring')                                  value)]                             	ifFalse: [((SmallScheme globalRef:  #'error')                                  value: ( 'format: bad port -> ') value: ( X3CoutputX2DportX3E))]]]).                  returnX2Dvalue := ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( X3CoutputX2DportX3E) value: ( false))) == false) not)                     	ifTrue: [                     [((SmallScheme globalRef:  #'getX2DoutputX2Dstring')                              value: ( port))]]                     	ifFalse: [                     [ dontX2Dprint]]).                                       [ | formatX2Dhelp |                                         formatX2Dhelp := (                     [ :formatX2Dstrg :arglyst |                           [ | lengthX2DofX2DformatX2Dstring anycharX2Ddispatch tildeX2Ddispatch |                                                     lengthX2DofX2DformatX2Dstring := (((SmallScheme globalRef:  #'stringX2Dlength')                                value: ( formatX2Dstrg))).                            anycharX2Ddispatch := (                           [ :pos :arglist :lastX2DcharX2DwasX2Dnl |  (((((SmallScheme globalRef:  #'X3EX3D')                                        value: ( pos) value: ( lengthX2DofX2DformatX2Dstring))) == false) not)                                   	ifTrue: [ [                                     (lastX2DwasX2Dnewline :=  lastX2DcharX2DwasX2Dnl).                                      arglist.                                    ] value]                                   	ifFalse: [ [ :char |                                         (((((SmallScheme globalRef:  #'eqX3F')                                                value: ( char) value: ( $~))) == false) not)                                           	ifTrue: [(tildeX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                value: ( pos) value: ( 1))) value: ( arglist) value: ( lastX2DcharX2DwasX2Dnl))]                                           	ifFalse: [ [                                             ((SmallScheme globalRef:  #'writeX2Dchar')                                                  value: ( char) value: ( port)).                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                  value: ( pos) value: ( 1))) value: ( arglist) value: ( false)).                                            ] value].                                   ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                                            value: ( formatX2Dstrg) value: ( pos))). }]]).                            tildeX2Ddispatch := (                           [ :pos :arglist :lastX2DcharX2DwasX2Dnl |  (((((SmallScheme globalRef:  #'X3EX3D')                                        value: ( pos) value: ( lengthX2DofX2DformatX2Dstring))) == false) not)                                   	ifTrue: [ [                                     ((SmallScheme globalRef:  #'writeX2Dchar')                                          value: ( $~) value: ( port)).                                     (lastX2DwasX2Dnewline :=  lastX2DcharX2DwasX2Dnl).                                      arglist.                                    ] value]                                   	ifFalse: [ [ :key56 |                                         (((((SmallScheme globalRef:  #'memv')                                                value: ( key56) value: ( ({ $A. } asRest)))) == false) not)                                           	ifTrue: [ [                                             ((SmallScheme globalRef:  #'display')                                                  value: (((SmallScheme globalRef:  #'car')                                                  value: ( arglist))) value: ( port)).                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                  value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                  value: ( arglist))) value: ( false)).                                            ] value]                                           	ifFalse: [ [ :key57 |                                                 (((((SmallScheme globalRef:  #'memv')                                                        value: ( key57) value: ( ({ $S. } asRest)))) == false) not)                                                   	ifTrue: [ [                                                     ((SmallScheme globalRef:  #'write')                                                          value: (((SmallScheme globalRef:  #'car')                                                          value: ( arglist))) value: ( port)).                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                          value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                          value: ( arglist))) value: ( false)).                                                    ] value]                                                   	ifFalse: [ [ :key58 |                                                         (((((SmallScheme globalRef:  #'memv')                                                                value: ( key58) value: ( ({ $D. } asRest)))) == false) not)                                                           	ifTrue: [ [                                                             ((SmallScheme globalRef:  #'display')                                                                  value: (((SmallScheme globalRef:  #'numberX2DX3Estring')                                                                  value: (((SmallScheme globalRef:  #'car')                                                                  value: ( arglist))) value: ( 10))) value: ( port)).                                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                  value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                                  value: ( arglist))) value: ( false)).                                                            ] value]                                                           	ifFalse: [ [ :key59 |                                                                 (((((SmallScheme globalRef:  #'memv')                                                                        value: ( key59) value: ( ({ $X. } asRest)))) == false) not)                                                                   	ifTrue: [ [                                                                     ((SmallScheme globalRef:  #'display')                                                                          value: (((SmallScheme globalRef:  #'numberX2DX3Estring')                                                                          value: (((SmallScheme globalRef:  #'car')                                                                          value: ( arglist))) value: ( 16))) value: ( port)).                                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                          value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                                          value: ( arglist))) value: ( false)).                                                                    ] value]                                                                   	ifFalse: [ [ :key60 |                                                                         (((((SmallScheme globalRef:  #'memv')                                                                                value: ( key60) value: ( ({ $O. } asRest)))) == false) not)                                                                           	ifTrue: [ [                                                                             ((SmallScheme globalRef:  #'display')                                                                                  value: (((SmallScheme globalRef:  #'numberX2DX3Estring')                                                                                  value: (((SmallScheme globalRef:  #'car')                                                                                  value: ( arglist))) value: ( 8))) value: ( port)).                                                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                  value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                                                  value: ( arglist))) value: ( false)).                                                                            ] value]                                                                           	ifFalse: [ [ :key61 |                                                                                 (((((SmallScheme globalRef:  #'memv')                                                                                        value: ( key61) value: ( ({ $B. } asRest)))) == false) not)                                                                                   	ifTrue: [ [                                                                                     ((SmallScheme globalRef:  #'display')                                                                                          value: (((SmallScheme globalRef:  #'numberX2DX3Estring')                                                                                          value: (((SmallScheme globalRef:  #'car')                                                                                          value: ( arglist))) value: ( 2))) value: ( port)).                                                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                          value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                                                          value: ( arglist))) value: ( false)).                                                                                    ] value]                                                                                   	ifFalse: [ [ :key62 |                                                                                         (((((SmallScheme globalRef:  #'memv')                                                                                                value: ( key62) value: ( ({ $C. } asRest)))) == false) not)                                                                                           	ifTrue: [ [                                                                                             ((SmallScheme globalRef:  #'writeX2Dchar')                                                                                                  value: (((SmallScheme globalRef:  #'car')                                                                                                  value: ( arglist))) value: ( port)).                                                                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                  value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                                                                  value: ( arglist))) value: ( false)).                                                                                            ] value]                                                                                           	ifFalse: [ [ :key63 |                                                                                                 (((((SmallScheme globalRef:  #'memv')                                                                                                        value: ( key63) value: ( ({ $P. } asRest)))) == false) not)                                                                                                   	ifTrue: [ [                                                                                                      (((((SmallScheme globalRef:  #'X3D')                                                                                                              value: (((SmallScheme globalRef:  #'car')                                                                                                              value: ( arglist))) value: ( 1))) == false) not)                                                                                                         	ifTrue: [ false]                                                                                                         	ifFalse: [((SmallScheme globalRef:  #'writeX2Dchar')                                                                                                              value: ( $s) value: ( port))].                                                                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                          value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                                                                          value: ( arglist))) value: ( false)).                                                                                                    ] value]                                                                                                   	ifFalse: [ [ :key64 |                                                                                                         (((((SmallScheme globalRef:  #'memv')                                                                                                                value: ( key64) value: ( ({ $~. } asRest)))) == false) not)                                                                                                           	ifTrue: [ [                                                                                                             ((SmallScheme globalRef:  #'writeX2Dchar')                                                                                                                  value: ( $~) value: ( port)).                                                                                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                  value: ( pos) value: ( 1))) value: ( arglist) value: ( false)).                                                                                                            ] value]                                                                                                           	ifFalse: [ [ :key65 |                                                                                                                 (((((SmallScheme globalRef:  #'memv')                                                                                                                        value: ( key65) value: ( ({ $%. } asRest)))) == false) not)                                                                                                                   	ifTrue: [ [                                                                                                                     ((SmallScheme globalRef:  #'newline')                                                                                                                          value: ( port)).                                                                                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                          value: ( pos) value: ( 1))) value: ( arglist) value: ( true)).                                                                                                                    ] value]                                                                                                                   	ifFalse: [ [ :key66 |                                                                                                                         (((((SmallScheme globalRef:  #'memv')                                                                                                                                value: ( key66) value: ( ({ $_. } asRest)))) == false) not)                                                                                                                           	ifTrue: [ [                                                                                                                             ((SmallScheme globalRef:  #'writeX2Dchar')                                                                                                                                  value: ( $ ) value: ( port)).                                                                                                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                                  value: ( pos) value: ( 1))) value: ( arglist) value: ( false)).                                                                                                                            ] value]                                                                                                                           	ifFalse: [ [ :key67 |                                                                                                                                 (((((SmallScheme globalRef:  #'memv')                                                                                                                                        value: ( key67) value: ( ({ $&. } asRest)))) == false) not)                                                                                                                                   	ifTrue: [ [                                                                                                                                      (((((SmallScheme globalRef:  #'not')                                                                                                                                              value: ( lastX2DcharX2DwasX2Dnl))) == false) not)                                                                                                                                         	ifTrue: [((SmallScheme globalRef:  #'newline')                                                                                                                                              value: ( port))].                                                                                                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                                          value: ( pos) value: ( 1))) value: ( arglist) value: ( true)).                                                                                                                                    ] value]                                                                                                                                   	ifFalse: [ [ :key68 |                                                                                                                                         (((((SmallScheme globalRef:  #'memv')                                                                                                                                                value: ( key68) value: ( ({ $T. } asRest)))) == false) not)                                                                                                                                           	ifTrue: [ [                                                                                                                                             ((SmallScheme globalRef:  #'writeX2Dchar')                                                                                                                                                  value: ( asciiX2Dtab) value: ( port)).                                                                                                                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                                                  value: ( pos) value: ( 1))) value: ( arglist) value: ( false)).                                                                                                                                            ] value]                                                                                                                                           	ifFalse: [ [ :key69 |                                                                                                                                                 (((((SmallScheme globalRef:  #'memv')                                                                                                                                                        value: ( key69) value: ( ({ $|. } asRest)))) == false) not)                                                                                                                                                   	ifTrue: [ [                                                                                                                                                     ((SmallScheme globalRef:  #'writeX2Dchar')                                                                                                                                                          value: ( asciiX2Dff) value: ( port)).                                                                                                                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                                                          value: ( pos) value: ( 1))) value: ( arglist) value: ( true)).                                                                                                                                                    ] value]                                                                                                                                                   	ifFalse: [ [ :key70 |                                                                                                                                                         (((((SmallScheme globalRef:  #'memv')                                                                                                                                                                value: ( key70) value: ( ({ $G. } asRest)))) == false) not)                                                                                                                                                           	ifTrue: [ [                                                                                                                                                              (((((SmallScheme globalRef:  #'eqX3F')                                                                                                                                                                      value: ( port) value: ( false))) == false) not)                                                                                                                                                                 	ifTrue: [((SmallScheme globalRef:  #'display')                                                                                                                                                                      value: (((SmallScheme globalRef:  #'prettyX2DprintX2DtoX2Dstring')                                                                                                                                                                      value: (((SmallScheme globalRef:  #'car')                                                                                                                                                                      value: ( arglist))))) value: ( port))]                                                                                                                                                                 	ifFalse: [((SmallScheme globalRef:  #'prettyX2Dprint')                                                                                                                                                                      value: (((SmallScheme globalRef:  #'car')                                                                                                                                                                      value: ( arglist))) value: ( port))].                                                                                                                                                             (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                                                                  value: ( pos) value: ( 1))) value: (((SmallScheme globalRef:  #'cdr')                                                                                                                                                                  value: ( arglist))) value: ( true)).                                                                                                                                                            ] value]                                                                                                                                                           	ifFalse: [ [ :key71 |                                                                                                                                                                 (((((SmallScheme globalRef:  #'memv')                                                                                                                                                                        value: ( key71) value: ( ({ $?. } asRest)))) == false) not)                                                                                                                                                                   	ifTrue: [ [                                                                                                                                                                     (lastX2DwasX2Dnewline :=  lastX2DcharX2DwasX2Dnl).                                                                                                                                                                     (anycharX2Ddispatch value: (((SmallScheme globalRef:  #'X2B')                                                                                                                                                                          value: ( pos) value: ( 1))) value: ((formatX2Dhelp value: (((SmallScheme globalRef:  #'car')                                                                                                                                                                          value: ( arglist))) value: (((SmallScheme globalRef:  #'cdr')                                                                                                                                                                          value: ( arglist))))) value: ( lastX2DwasX2Dnewline)).                                                                                                                                                                    ] value]                                                                                                                                                                   	ifFalse: [ [                                                                                                                                                                      key71.                                                                                                                                                                     ((SmallScheme globalRef:  #'error')                                                                                                                                                                          value: ( 'FORMAT: unknown tilde escape') value: (((SmallScheme globalRef:  #'stringX2Dref')                                                                                                                                                                          value: ( formatX2Dstrg) value: ( pos)))).                                                                                                                                                                    ] value].                                                                                                                                                           ] valueWithArguments: {( key70). }].                                                                                                                                                   ] valueWithArguments: {( key69). }].                                                                                                                                           ] valueWithArguments: {( key68). }].                                                                                                                                   ] valueWithArguments: {( key67). }].                                                                                                                           ] valueWithArguments: {( key66). }].                                                                                                                   ] valueWithArguments: {( key65). }].                                                                                                           ] valueWithArguments: {( key64). }].                                                                                                   ] valueWithArguments: {( key63). }].                                                                                           ] valueWithArguments: {( key62). }].                                                                                   ] valueWithArguments: {( key61). }].                                                                           ] valueWithArguments: {( key60). }].                                                                   ] valueWithArguments: {( key59). }].                                                           ] valueWithArguments: {( key58). }].                                                   ] valueWithArguments: {( key57). }].                                           ] valueWithArguments: {( key56). }].                                   ] valueWithArguments: {(((SmallScheme globalRef:  #'charX2Dupcase')                                            value: (((SmallScheme globalRef:  #'stringX2Dref')                                            value: ( formatX2Dstrg) value: ( pos))))). }]]).                             (anycharX2Ddispatch value: ( 00) value: ( arglyst) value: ( lastX2DwasX2Dnewline)).                         ] value]).                        [                         (formatX2Dhelp value: ( X3CformatX2DstringX3E) value: ( X3CargsX3E)).                         (returnX2Dvalue value).                        ] value.                   ] value.               ] value] withLastArgRest .       ] valueWithArguments: {( false). (((SmallScheme globalRef:  #'integerX2DX3Echar')                value: ( 9))). (((SmallScheme globalRef:  #'integerX2DX3Echar')                value: ( 12))). (((SmallScheme globalRef:  #'stringX2DX3Esymbol')                value: ( ''))). } ) .! !!SmallScheme class methodsFor: 'initialization'!initIo SmallScheme define:  #'fullX2DpathnameX2Dfor'    "full-pathname-for"  as: (        [ :fileX2DnameX2Dstring |  ( ( FileDirectory forFileName: fileX2DnameX2Dstring) fullNameFor: fileX2DnameX2Dstring)] ) . SmallScheme define:  #'callX2DwithX2DinputX2Dfile'    "call-with-input-file"  as: (        [ :fileX2DnameX2Dstring :proc |  [ :inport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ (                   [(proc value: ( inport))] ensure:                   [ ( inport close)])].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: false)). }] ) . SmallScheme define:  #'callX2DwithX2DoutputX2Dfile'    "call-with-output-file"  as: (        [ :fileX2DnameX2Dstring :proc |  [ :outport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( outport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ (                   [(proc value: ( outport))] ensure:                   [ ( outport close)])].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: true)). }] ) . SmallScheme define:  #'inputX2DportX3F'    "input-port?"  as: (        [ :obj |  [ :temp22 |                 ((( temp22) == false) not)                   	ifTrue: [ temp22]                   	ifFalse: [ ( obj isKindOf: ReadWriteStream)].           ] valueWithArguments: {( ( obj isKindOf: ReadStream)). }] ) . SmallScheme define:  #'outputX2DportX3F'    "output-port?"  as: (        [ :obj |  [ :temp23 |                 ((( temp23) == false) not)                   	ifTrue: [ temp23]                   	ifFalse: [ ( obj isKindOf: ReadWriteStream)].           ] valueWithArguments: {( ( obj isKindOf: WriteStream)). }] ) . SmallScheme define:  #'portX3F'    "port?"  as: (        [ :obj |  ( obj isKindOf: Stream)] ) . SmallScheme dynamicDefine: #X25X2AcurrentX2DinputX2DportX2AX25  as:  nil. SmallScheme dynamicDefine: #X25X2AcurrentX2DoutputX2DportX2AX25  as:  Transcript. SmallScheme define:  #'currentX2DinputX2Dport'    "current-input-port"  as: (        [(SmallScheme dynamicRef: #X25X2AcurrentX2DinputX2DportX2AX25 withDefault:            [ nil])] ) . SmallScheme define:  #'currentX2DoutputX2Dport'    "current-output-port"  as: (        [(SmallScheme dynamicRef: #X25X2AcurrentX2DoutputX2DportX2AX25 withDefault:            [ Transcript])] ) . SmallScheme define:  #'withX2DinputX2DfromX2Dfile'    "with-input-from-file"  as: (        [ :fileX2DnameX2Dstring :thunk |  [ :inport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ [                     SmallScheme dynamicPush: #X25X2AcurrentX2DinputX2DportX2AX25                                as:  inport.                      ( thunk ensure:                     [ ( inport close)]).                   ] ensure: [                     SmallScheme dynamicPop: #X25X2AcurrentX2DinputX2DportX2AX25.].].           ] valueWithArguments: {(((SmallScheme globalRef:  #'openX2DinputX2Dfile')                    value: ( fileX2DnameX2Dstring))). }] ) . SmallScheme define:  #'withX2DoutputX2DtoX2Dfile'    "with-output-to-file"  as: (        [ :fileX2DnameX2Dstring :thunk |  [ :outport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( outport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ [                     SmallScheme dynamicPush: #X25X2AcurrentX2DoutputX2DportX2AX25                                as:  outport.                      ( thunk ensure:                     [ ( outport close)]).                   ] ensure: [                     SmallScheme dynamicPop: #X25X2AcurrentX2DoutputX2DportX2AX25.].].           ] valueWithArguments: {(((SmallScheme globalRef:  #'openX2DoutputX2Dfile')                    value: ( fileX2DnameX2Dstring))). }] ) . SmallScheme define:  #'openX2DinputX2Dfile'    "open-input-file"  as: (        [ :fileX2DnameX2Dstring |  [ :inport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ inport].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: false)). }] ) . SmallScheme define:  #'openX2DoutputX2Dfile'    "open-output-file"  as: (        [ :fileX2DnameX2Dstring |  [ :outport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( outport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ outport].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: true)). }] ) . SmallScheme define:  #'closeX2DinputX2Dport'    "close-input-port"  as: (        [ :port |  ( port close)] ) . SmallScheme define:  #'closeX2DoutputX2Dport'    "close-output-port"  as: (        [ :port |  ( port close)] ) . SmallScheme define:  #'theX2DeofX2Dobject'    "the-eof-object"  as: (  'EOF' ) . SmallScheme define:  #'readX2Dchar'    "read-char"  as: (        [ :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :inport |                 ((( ( inport atEnd)) == false) not)                   	ifTrue: [ (SmallScheme globalRef:  #'theX2DeofX2Dobject')                       ]                   	ifFalse: [ ( inport next)].           ] valueWithArguments: {( ((( [ :temp24 |                         ((( temp24) == false) not)                           	ifTrue: [ temp24]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'inputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'peekX2Dchar'    "peek-char"  as: (        [ :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :inport |                 ((( ( inport atEnd)) == false) not)                   	ifTrue: [ (SmallScheme globalRef:  #'theX2DeofX2Dobject')                       ]                   	ifFalse: [ ( inport peek)].           ] valueWithArguments: {( ((( [ :temp25 |                         ((( temp25) == false) not)                           	ifTrue: [ temp25]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'inputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'eofX2DobjectX3F'    "eof-object?"  as: (        [ :obj |  ( obj == (SmallScheme globalRef:  #'theX2DeofX2Dobject')               )] ) . SmallScheme define:  #'charX2DreadyX3F'    "char-ready?"  as: (        [ :port |  true] ) . SmallScheme define:  #'write'  as: (        [ :obj :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                 ( outport nextPutAll: ( obj asSchemeObjString)).           ] valueWithArguments: {( ((( [ :temp26 |                         ((( temp26) == false) not)                           	ifTrue: [ temp26]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'display'  as: (        [ :obj :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                 ( outport nextPutAll: ( obj asSchemeString)).           ] valueWithArguments: {( ((( [ :temp27 |                         ((( temp27) == false) not)                           	ifTrue: [ temp27]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'newline'  as: (        [ :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                 ( outport nextPut: Character cr).           ] valueWithArguments: {( ((( [ :temp28 |                         ((( temp28) == false) not)                           	ifTrue: [ temp28]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'writeX2Dchar'    "write-char"  as: (        [ :char :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                ((SmallScheme globalRef:  #'display')                    value: ( char) value: ( outport)).           ] valueWithArguments: {( ((( [ :temp29 |                         ((( temp29) == false) not)                           	ifTrue: [ temp29]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'openX2DoutputX2Dstring'    "open-output-string"  as: (        [ ( WriteStream with: '')] ) . SmallScheme define:  #'getX2DoutputX2Dstring'    "get-output-string"  as: (        [ :outputX2DstringX2Dport |  (((((SmallScheme globalRef:  #'outputX2DportX3F')                    value: ( outputX2DstringX2Dport))) == false) not)               	ifTrue: [ ( outputX2DstringX2Dport contents)]               	ifFalse: [((SmallScheme globalRef:  #'error')                    value: ( 'Not an output-string-port') value: ( outputX2DstringX2Dport))]] ) . SmallScheme define:  #'openX2DinputX2Dstring'    "open-input-string"  as: (        [ :str |  ( ReadStream on: str from: 1 to: ( str size))] ) .! !!SmallScheme class methodsFor: 'initialization'!initLists SmallScheme define:  #'pairX3F'    "pair?"  as: (        [ :obj |  ( obj isPair)] ) . SmallScheme define:  #'cons'  as: (        [ :obj1 :obj2 |  ( Pair car: obj1 cdr: obj2)] ) . SmallScheme define:  #'car'  as: (        [ :pair |  ( pair car)] ) . SmallScheme define:  #'cdr'  as: (        [ :pair |  ( pair cdr)] ) . SmallScheme define:  #'setX2DcarX21'    "set-car!!"  as: (        [ :pair :obj |  ( pair setCar: obj)] ) . SmallScheme define:  #'setX2DcdrX21'    "set-cdr!!"  as: (        [ :pair :obj |  ( pair setCdr: obj)] ) . SmallScheme define:  #'caar'  as: (        [ :pair |  ( pair caar)] ) . SmallScheme define:  #'cadr'  as: (        [ :pair |  ( pair cadr)] ) . SmallScheme define:  #'cddr'  as: (        [ :pair |  ( pair cddr)] ) . SmallScheme define:  #'cdar'  as: (        [ :pair |  ( pair cdar)] ) . SmallScheme define:  #'caaar'  as: (        [ :pair |  ( pair caaar)] ) . SmallScheme define:  #'caadr'  as: (        [ :pair |  ( pair caadr)] ) . SmallScheme define:  #'cadar'  as: (        [ :pair |  ( pair cadar)] ) . SmallScheme define:  #'cdaar'  as: (        [ :pair |  ( pair cdaar)] ) . SmallScheme define:  #'caddr'  as: (        [ :pair |  ( pair caddr)] ) . SmallScheme define:  #'cdadr'  as: (        [ :pair |  ( pair cdadr)] ) . SmallScheme define:  #'cdddr'  as: (        [ :pair |  ( pair cdddr)] ) . SmallScheme define:  #'cddar'  as: (        [ :pair |  ( pair cddar)] ) . SmallScheme define:  #'caaaar'  as: (        [ :pair |  ( pair caaadr)] ) . SmallScheme define:  #'caaadr'  as: (        [ :pair |  ( pair caaadr)] ) . SmallScheme define:  #'caadar'  as: (        [ :pair |  ( pair caadar)] ) . SmallScheme define:  #'cadaar'  as: (        [ :pair |  ( pair cadaar)] ) . SmallScheme define:  #'cdaaar'  as: (        [ :pair |  ( pair cdaaar)] ) . SmallScheme define:  #'caaddr'  as: (        [ :pair |  ( pair caaddr)] ) . SmallScheme define:  #'cadadr'  as: (        [ :pair |  ( pair cadadr)] ) . SmallScheme define:  #'cdaadr'  as: (        [ :pair |  ( pair cdaadr)] ) . SmallScheme define:  #'caddar'  as: (        [ :pair |  ( pair caddar)] ) . SmallScheme define:  #'cdadar'  as: (        [ :pair |  ( pair cdadar)] ) . SmallScheme define:  #'cadddr'  as: (        [ :pair |  ( pair cadddr)] ) . SmallScheme define:  #'cdaddr'  as: (        [ :pair |  ( pair cdaddr)] ) . SmallScheme define:  #'cddadr'  as: (        [ :pair |  ( pair cddadr)] ) . SmallScheme define:  #'cdddar'  as: (        [ :pair |  ( pair cdddar)] ) . SmallScheme define:  #'cddddr'  as: (        [ :pair |  ( pair cddddr)] ) . SmallScheme define:  #'nullX3F'    "null?"  as: (        [ :obj |  ( obj == nil)] ) . SmallScheme define:  #'listX3F'    "list?"  as: (        [ :obj |  [ :temp16 |                 ((( temp16) == false) not)                   	ifTrue: [ temp16]                   	ifFalse: [ ((( ( obj isKindOf: Pair)) == false) not)                       	ifTrue: [ ( obj isProper)]                       	ifFalse: [ false]].           ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                    value: ( obj))). }] ) . SmallScheme define:  #'list'  as: (        [ :things |            things := things asRest.            things] withLastArgRest  ) . SmallScheme define:  #'length'  as: (        [ :list |  ( list length)] ) . SmallScheme define:  #'setX2DlastX2Dpair'    "set-last-pair"  as: (        [ :list :thing |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ thing]               	ifFalse: [ (((((SmallScheme globalRef:  #'not')                        value: (((SmallScheme globalRef:  #'pairX3F')                        value: ( list))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'set-last-pair: expected a list') value: ( list))]                   	ifFalse: [                    [ | loop |                        loop :=                        [ :result :lastX2Dpair :old |                         ((( [ :temp17 |                                 ((( temp17) == false) not)                                   	ifTrue: [ temp17]                                   	ifFalse: [((SmallScheme globalRef:  #'not')                                        value: (((SmallScheme globalRef:  #'pairX3F')                                        value: ( old))))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                                    value: ( old))). }) == false) not)                           	ifTrue: [ [                             ((SmallScheme globalRef:  #'setX2DcdrX21')                                  value: ( lastX2Dpair) value: ( thing)).                              result.                            ] value]                           	ifFalse: [ [ :new |                                 (((((SmallScheme globalRef:  #'nullX3F')                                        value: ( lastX2Dpair))) == false) not)                                   	ifTrue: [(loop value: ( new) value: ( new) value: (((SmallScheme globalRef:  #'cdr')                                        value: ( old))))]                                   	ifFalse: [ [                                     ((SmallScheme globalRef:  #'setX2DcdrX21')                                          value: ( lastX2Dpair) value: ( new)).                                     (loop value: ( result) value: ( new) value: (((SmallScheme globalRef:  #'cdr')                                          value: ( old)))).                                    ] value].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'cons')                                    value: (((SmallScheme globalRef:  #'car')                                    value: ( old))) value: ( nil))). }]                   ].                   loop valueWithArguments: {                        nil.                         nil.                         list. } ] value]]] ) . SmallScheme define:  #'append'  as: (        [ :lists |            lists := lists asRest.            (((((SmallScheme globalRef:  #'nullX3F')                    value: ( lists))) == false) not)               	ifTrue: [ nil]               	ifFalse: [                [ | loop |                    loop :=                    [ :l |                     (((((SmallScheme globalRef:  #'nullX3F')                            value: (((SmallScheme globalRef:  #'cdr')                            value: ( l))))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'car')                            value: ( l))]                       	ifFalse: [((SmallScheme globalRef:  #'setX2DlastX2Dpair')                            value: (((SmallScheme globalRef:  #'car')                            value: ( l))) value: ((loop value: (((SmallScheme globalRef:  #'cdr')                            value: ( l))))))]               ].               loop valueWithArguments: {                    lists. } ] value]] withLastArgRest  ) . SmallScheme define:  #'appendX21'    "append!!"  as: (        [ :list1 :list2 |  ( list1 appendX21: list2)] ) . SmallScheme define:  #'reverse'  as: (        [ :list |  ( list reverse)] ) . SmallScheme define:  #'listX2Dtail'    "list-tail"  as: (        [ :list :k |  (((((SmallScheme globalRef:  #'X3CX3D')                    value: ( k) value: ( 00))) == false) not)               	ifTrue: [ list]               	ifFalse: [((SmallScheme globalRef:  #'listX2Dtail')                    value: (((SmallScheme globalRef:  #'cdr')                    value: ( list))) value: (((SmallScheme globalRef:  #'X2D')                    value: ( k) value: ( 1))))]] ) . SmallScheme define:  #'listX2Dref'    "list-ref"  as: (        [ :list :k | ((SmallScheme globalRef:  #'car')                value: (((SmallScheme globalRef:  #'listX2Dtail')                value: ( list) value: ( k))))] ) . SmallScheme define:  #'lastX2Dpair'    "last-pair"  as: (        [ :list |  ( list lastPair)] ) . SmallScheme define:  #'setX2DlastX2DpairX21'    "set-last-pair!!"  as: (        [ :list :thing |  [             ((SmallScheme globalRef:  #'setX2DcdrX21')                  value: (((SmallScheme globalRef:  #'lastX2Dpair')                  value: ( list))) value: ( thing)).              list.            ] value] ) . SmallScheme define:  #'memq'  as: (        [ :obj :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ false]               	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                        value: ( obj) value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [ list]                   	ifFalse: [((SmallScheme globalRef:  #'memq')                        value: ( obj) value: (((SmallScheme globalRef:  #'cdr')                        value: ( list))))]]] ) . SmallScheme define:  #'memv'  as: (        [ :obj :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ false]               	ifFalse: [ (((((SmallScheme globalRef:  #'eqvX3F')                        value: ( obj) value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [ list]                   	ifFalse: [((SmallScheme globalRef:  #'memv')                        value: ( obj) value: (((SmallScheme globalRef:  #'cdr')                        value: ( list))))]]] ) . SmallScheme define:  #'member'  as: (        [ :obj :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ false]               	ifFalse: [ (((((SmallScheme globalRef:  #'equalX3F')                        value: ( obj) value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [ list]                   	ifFalse: [((SmallScheme globalRef:  #'member')                        value: ( obj) value: (((SmallScheme globalRef:  #'cdr')                        value: ( list))))]]] ) . SmallScheme define:  #'assq'  as: (        [ :obj :alist |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( alist))) == false) not)               	ifTrue: [ false]               	ifFalse: [ ( alist detect:               [ :pair | ((SmallScheme globalRef:  #'eqX3F')                        value: ( obj) value: (((SmallScheme globalRef:  #'car')                        value: ( pair))))])]] ) . SmallScheme define:  #'assv'  as: (        [ :obj :alist |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( alist))) == false) not)               	ifTrue: [ false]               	ifFalse: [ ( alist detect:               [ :pair | ((SmallScheme globalRef:  #'eqvX3F')                        value: ( obj) value: (((SmallScheme globalRef:  #'car')                        value: ( pair))))])]] ) . SmallScheme define:  #'assoc'  as: (        [ :obj :alist |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( alist))) == false) not)               	ifTrue: [ false]               	ifFalse: [ ( alist detect:               [ :pair | ((SmallScheme globalRef:  #'equalX3F')                        value: ( obj) value: (((SmallScheme globalRef:  #'car')                        value: ( pair))))])]] ) . SmallScheme define:  #'rassq'  as: (        [ :obj :alist |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( alist))) == false) not)               	ifTrue: [ false]               	ifFalse: [ ( alist detect:               [ :pair | ((SmallScheme globalRef:  #'eqX3F')                        value: ( obj) value: (((SmallScheme globalRef:  #'cdr')                        value: ( pair))))])]] ) .! !!SmallScheme class methodsFor: 'initialization'!initNumbers SmallScheme define:  #'nilX3F'    "nil?"  as: (        [ :obj |  ( obj == nil)] ) . SmallScheme define:  #'numberX3F'    "number?"  as: (        [ :obj |  ( obj isKindOf: Number)] ) . SmallScheme define:  #'complexX3F'    "complex?"  as: (        [ :obj |  [ :temp1 |                 ((( temp1) == false) not)                   	ifTrue: [ temp1]                   	ifFalse: [ [ :temp2 |                         ((( temp2) == false) not)                           	ifTrue: [ temp2]                           	ifFalse: [ [ :temp3 |                                 ((( temp3) == false) not)                                   	ifTrue: [ temp3]                                   	ifFalse: [((SmallScheme globalRef:  #'integerX3F')                                        value: ( obj))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'rationalX3F')                                    value: ( obj))). }].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'realX3F')                            value: ( obj))). }].           ] valueWithArguments: {( ( obj isKindOf: Complex)). }] ) . SmallScheme define:  #'realX3F'    "real?"  as: (        [ :obj |  [ :temp4 |                 ((( temp4) == false) not)                   	ifTrue: [ temp4]                   	ifFalse: [ [ :temp5 |                         ((( temp5) == false) not)                           	ifTrue: [ temp5]                           	ifFalse: [((SmallScheme globalRef:  #'integerX3F')                                value: ( obj))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'rationalX3F')                            value: ( obj))). }].           ] valueWithArguments: {( ( obj isKindOf: Float)). }] ) . SmallScheme define:  #'rationalX3F'    "rational?"  as: (        [ :obj |  [ :temp6 |                 ((( temp6) == false) not)                   	ifTrue: [ temp6]                   	ifFalse: [((SmallScheme globalRef:  #'integerX3F')                        value: ( obj))].           ] valueWithArguments: {( ( obj isKindOf: Fraction)). }] ) . SmallScheme define:  #'integerX3F'    "integer?"  as: (        [ :obj |  ( obj isKindOf: Integer)] ) . SmallScheme define:  #'exactX3F'    "exact?"  as: (        [ :n |  [ :temp7 |                 ((( temp7) == false) not)                   	ifTrue: [ temp7]                   	ifFalse: [((SmallScheme globalRef:  #'rationalX3F')                        value: ( n))].           ] valueWithArguments: {(((SmallScheme globalRef:  #'integerX3F')                    value: ( n))). }] ) . SmallScheme define:  #'inexactX3F'    "inexact?"  as: (        [ :n | ((SmallScheme globalRef:  #'not')                value: (((SmallScheme globalRef:  #'exactX3F')                value: ( n))))] ) . SmallScheme define:  #'reduce'  as: (        [ :op :seed :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ seed]               	ifFalse: [((SmallScheme globalRef:  #'reduce')                    value: ( op) value: ((op value: ( seed) value: (((SmallScheme globalRef:  #'car')                    value: ( list))))) value: (((SmallScheme globalRef:  #'cdr')                    value: ( list))))]] ) . SmallScheme define:  #'naryX2Dand'    "nary-and"  as: (        [ :op :seed :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ true]               	ifFalse: [ ((((op value: ( seed) value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'naryX2Dand')                        value: ( op) value: (((SmallScheme globalRef:  #'car')                        value: ( list))) value: (((SmallScheme globalRef:  #'cdr')                        value: ( list))))]                   	ifFalse: [ false]]] ) . SmallScheme define:  #'X3D'    "="  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 = x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3C'    "<"  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 < x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3E'    ">"  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 > x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3CX3D'    "<="  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 <= x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3EX3D'    ">="  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 >= x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'zeroX3F'    "zero?"  as: (        [ :z |  ( z = 00)] ) . SmallScheme define:  #'positiveX3F'    "positive?"  as: (        [ :x |  ( x > 00)] ) . SmallScheme define:  #'negativeX3F'    "negative?"  as: (        [ :x |  ( x < 00)] ) . SmallScheme define:  #'oddX3F'    "odd?"  as: (        [ :n |  ( n odd)] ) . SmallScheme define:  #'evenX3F'    "even?"  as: (        [ :n |  ( n even)] ) . SmallScheme define:  #'max'  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 max: x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'min'  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 min: x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X2B'    "+"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 + x2)]) value: ( 00) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'X2A'    "*"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 * x2)]) value: ( 1) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'uncommunitiveX2Dreduce'    "uncommunitive-reduce"  as: (        [ :op :seed :things |  [ :key8 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key8) value: ( ({ 00. } asRest)))) == false) not)                   	ifTrue: [ seed]                   	ifFalse: [ [ :key9 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key9) value: ( ({ 1. } asRest)))) == false) not)                           	ifTrue: [(op value: ( seed) value: (((SmallScheme globalRef:  #'car')                                value: ( things))))]                           	ifFalse: [ [ :key10 |                                 (((((SmallScheme globalRef:  #'memv')                                        value: ( key10) value: ( ({ 2. } asRest)))) == false) not)                                   	ifTrue: [(op value: (((SmallScheme globalRef:  #'car')                                        value: ( things))) value: (((SmallScheme globalRef:  #'cadr')                                        value: ( things))))]                                   	ifFalse: [ [                                      key10.                                     ((SmallScheme globalRef:  #'reduce')                                          value: ( op) value: ((op value: (((SmallScheme globalRef:  #'car')                                          value: ( things))) value: (((SmallScheme globalRef:  #'cadr')                                          value: ( things))))) value: (((SmallScheme globalRef:  #'cddr')                                          value: ( things)))).                                    ] value].                           ] valueWithArguments: {( key9). }].                   ] valueWithArguments: {( key8). }].           ] valueWithArguments: {(((SmallScheme globalRef:  #'length')                    value: ( things))). }] ) . SmallScheme define:  #'X2D'    "-"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :x1 :x2 |  ( x1 - x2)]) value: ( 00) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'X2F'    "/"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :x1 :x2 |  ( x1 / x2)]) value: ( 1) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'abs'  as: (        [ :n |  ((( ( n < 00)) == false) not)               	ifTrue: [ ( 00 - n)]               	ifFalse: [ n]] ) . SmallScheme define:  #'quotient'  as: (        [ :n1 :n2 |  ( n1 quo: n2)] ) . SmallScheme define:  #'remainder'  as: (        [ :n1 :n2 |  ( n1 rem: n2)] ) . SmallScheme define:  #'modulo'  as: (        [ :n1 :n2 |  [ :rem |                 (((((SmallScheme globalRef:  #'X3E')                        value: ( n2) value: ( 00))) == false) not)                   	ifTrue: [ (((((SmallScheme globalRef:  #'X3C')                            value: ( rem) value: ( 00))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'X2B')                            value: ( rem) value: ( n2))]                       	ifFalse: [ rem]]                   	ifFalse: [ (((((SmallScheme globalRef:  #'X3E')                            value: ( rem) value: ( 00))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'X2B')                            value: ( rem) value: ( n2))]                       	ifFalse: [ rem]].           ] valueWithArguments: {(((SmallScheme globalRef:  #'remainder')                    value: ( n1) value: ( n2))). }] ) . SmallScheme define:  #'gcd'  as: (        [ :numbers |            numbers := numbers asRest.           ((SmallScheme globalRef:  #'abs')                value: (((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :n1 :n2 |  ( n1 gcd: n2)]) value: ( 00) value: ( numbers))))] withLastArgRest  ) . SmallScheme define:  #'lcm'  as: (        [ :numbers |            numbers := numbers asRest.           ((SmallScheme globalRef:  #'abs')                value: (((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :n1 :n2 |  ( n1 lcm: n2)]) value: ( 1) value: ( numbers))))] withLastArgRest  ) . SmallScheme define:  #'factorial'  as: (        [ :n |  ( n factorial)] ) . SmallScheme define:  #'numerator'  as: (        [ :q |  ( q numerator)] ) . SmallScheme define:  #'denominator'  as: (        [ :q |  ( q denominator)] ) . SmallScheme define:  #'floor'  as: (        [ :x |  ( x floor)] ) . SmallScheme define:  #'ceiling'  as: (        [ :x |  ( x ceiling)] ) . SmallScheme define:  #'truncate'  as: (        [ :x |  ( x truncated)] ) . SmallScheme define:  #'round'  as: (        [ :x |  (((((SmallScheme globalRef:  #'X3D')                    value: ( 0.5) value: ( ( ( x fractionPart) abs)))) == false) not)               	ifTrue: [ [ :trunc |                     (((((SmallScheme globalRef:  #'evenX3F')                            value: ( trunc))) == false) not)                       	ifTrue: [ trunc]                       	ifFalse: [ (((((SmallScheme globalRef:  #'negativeX3F')                                value: ( x))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'X2D')                                value: ( trunc) value: ( 1))]                           	ifFalse: [((SmallScheme globalRef:  #'X2B')                                value: ( trunc) value: ( 1))]].               ] valueWithArguments: {( ( x truncated)). }]               	ifFalse: [ (((((SmallScheme globalRef:  #'negativeX3F')                        value: ( x))) == false) not)                   	ifTrue: [ (((SmallScheme globalRef:  #'X2D')                        value: ( x) value: ( 0.5)) truncated)]                   	ifFalse: [ (((SmallScheme globalRef:  #'X2B')                        value: ( x) value: ( 0.5)) truncated)]]] ) . SmallScheme define:  #'exp'  as: (        [ :z |  ( z exp)] ) . SmallScheme define:  #'log'  as: (        [ :z |  ( z ln)] ) . SmallScheme define:  #'sin'  as: (        [ :z |  ( z sin)] ) . SmallScheme define:  #'cos'  as: (        [ :z |  ( z cos)] ) . SmallScheme define:  #'tan'  as: (        [ :z |  ( z tan)] ) . SmallScheme define:  #'asin'  as: (        [ :z |  ( z arcSin)] ) . SmallScheme define:  #'acos'  as: (        [ :z |  ( z arcCos)] ) . SmallScheme define:  #'atan'  as: (        [ :x |  ( x arcTan)] ) . SmallScheme define:  #'atan'  as: (        [ :y :x |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( x))) == false) not)               	ifTrue: [ ( y arcTan)]               	ifFalse: [ ( y atan2: x)]] ) . SmallScheme define:  #'sqrt'  as: (        [ :z |  ( z sqrt)] ) . SmallScheme define:  #'expt'  as: (        [ :z1 :z2 |  (((((SmallScheme globalRef:  #'integerX3F')                    value: ( z2))) == false) not)               	ifTrue: [ ( z1 raisedToInteger: z2)]               	ifFalse: [ ( z1 raisedTo: z2)]] ) . SmallScheme define:  #'makeX2Drectangular'    "make-rectangular"  as: (        [ :x1 :x2 |  ( Complex real: x1 imaginary: x2)] ) . SmallScheme define:  #'makeX2Dpolar'    "make-polar"  as: (        [ :x3 :x4 |  ( Complex magnitude: (SmallScheme globalRef:  #'x1')                angle: (SmallScheme globalRef:  #'x2')               )] ) . SmallScheme define:  #'realX2Dpart'    "real-part"  as: (        [ :z |  ( z real)] ) . SmallScheme define:  #'imagX2Dpart'    "imag-part"  as: (        [ :z |  ( z imaginary)] ) . SmallScheme define:  #'magnitude'  as: (        [ :z |  ( z magnitude)] ) . SmallScheme define:  #'angle'  as: (        [ :z |  ( z angle)] ) . SmallScheme define:  #'degreesX2DX3Eradians'    "degrees->radians"  as: (        [ :d |  ( d degreesToRadians)] ) . SmallScheme define:  #'radiansX2DX3Edegrees'    "radians->degrees"  as: (        [ :r |  ( r radiansToDegrees)] ) . SmallScheme define:  #'exactX2DX3Einexact'    "exact->inexact"  as: (        [ :z | ((SmallScheme globalRef:  #'X2B')                value: ( z) value: ( 0.0))] ) . SmallScheme define:  #'inexactX2DX3Eexact'    "inexact->exact"  as: (        [ :z | ((SmallScheme globalRef:  #'round')                value: ( z))] ) . SmallScheme define:  #'numberX2DX3Estring'    "number->string"  as: (        [ :z :optionalX2Dradix |            optionalX2Dradix := optionalX2Dradix asRest.                      [ :radix |              [ :stX2Dstring |                 [ :key13 |                     (((((SmallScheme globalRef:  #'memv')                            value: ( key13) value: ( ({ 2.  8. } asRest)))) == false) not)                       	ifTrue: [ ( stX2Dstring copyFrom: 3 to: ( stX2Dstring size))]                       	ifFalse: [ [ :key14 |                             (((((SmallScheme globalRef:  #'memv')                                    value: ( key14) value: ( ({ 10. } asRest)))) == false) not)                               	ifTrue: [ stX2Dstring]                               	ifFalse: [ [ :key15 |                                     (((((SmallScheme globalRef:  #'memv')                                            value: ( key15) value: ( ({ 16. } asRest)))) == false) not)                                       	ifTrue: [ ( stX2Dstring copyFrom: 4 to: ( stX2Dstring size))]                                       	ifFalse: [ key15].                               ] valueWithArguments: {( key14). }].                       ] valueWithArguments: {( key13). }].               ] valueWithArguments: {( radix). }             ] value: ( [ :key11 |                   (((((SmallScheme globalRef:  #'memv')                          value: ( key11) value: ( ({ 2.  8.  16. } asRest)))) == false) not)                     	ifTrue: [ ( z radix: radix)]                     	ifFalse: [ [ :key12 |                           (((((SmallScheme globalRef:  #'memv')                                  value: ( key12) value: ( ({ 10. } asRest)))) == false) not)                             	ifTrue: [ ( z asSchemeString)]                             	ifFalse: [ [                                key12.                               ((SmallScheme globalRef:  #'error')                                    value: ( 'Radix must be 2 8 10 or 16') value: ( radix)).                              ] value].                     ] valueWithArguments: {( key11). }].             ] valueWithArguments: {( radix). })           ] value: ( (((((SmallScheme globalRef:  #'nullX3F')                    value: ( optionalX2Dradix))) == false) not)               	ifTrue: [ 10]               	ifFalse: [((SmallScheme globalRef:  #'car')                    value: ( optionalX2Dradix))])] withLastArgRest  ) .! !!SmallScheme class methodsFor: 'initialization'!initPrettyX2Dprint SmallScheme define:  #'genericX2Dwrite'    "generic-write"  as: (        [ :obj :displayX3F :width :output |             [ | readX2DmacroX3F readX2DmacroX2Dbody readX2DmacroX2Dprefix out wr pp |                         readX2DmacroX3F := (             [ :l |                   [ | length1X3F |                                     length1X3F := (                   [ :l |  (((((SmallScheme globalRef:  #'pairX3F')                                value: ( l))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'nullX3F')                                value: (((SmallScheme globalRef:  #'cdr')                                value: ( l))))]                           	ifFalse: [ false]]).                      [ :head :tail |                           [ :key72 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key72) value: ( ({ #'quote'.  #'quasiquote'.  #'unquote'.  #'unquoteX2Dsplicing'. } asRest)))) == false) not)                                 	ifTrue: [(length1X3F value: ( tail))]                                 	ifFalse: [ [                                    key72.                                    false.                                  ] value].                         ] valueWithArguments: {( head). }.                     ] valueWithArguments: {(((SmallScheme globalRef:  #'car')                              value: ( l))). (((SmallScheme globalRef:  #'cdr')                              value: ( l))). }.                 ] value]).              readX2DmacroX2Dbody := (             [ :l | ((SmallScheme globalRef:  #'cadr')                      value: ( l))]).              readX2DmacroX2Dprefix := (             [ :l |  [ :head :tail |                       [ :key73 |                           (((((SmallScheme globalRef:  #'memv')                                  value: ( key73) value: ( ({ #'quote'. } asRest)))) == false) not)                             	ifTrue: [ '''']                             	ifFalse: [ [ :key74 |                                   (((((SmallScheme globalRef:  #'memv')                                          value: ( key74) value: ( ({ #'quasiquote'. } asRest)))) == false) not)                                     	ifTrue: [ '``']                                     	ifFalse: [ [ :key75 |                                           (((((SmallScheme globalRef:  #'memv')                                                  value: ( key75) value: ( ({ #'unquote'. } asRest)))) == false) not)                                             	ifTrue: [ ',']                                             	ifFalse: [ [ :key76 |                                                   (((((SmallScheme globalRef:  #'memv')                                                          value: ( key76) value: ( ({ #'unquoteX2Dsplicing'. } asRest)))) == false) not)                                                     	ifTrue: [ ',@']                                                     	ifFalse: [ key76].                                             ] valueWithArguments: {( key75). }].                                     ] valueWithArguments: {( key74). }].                             ] valueWithArguments: {( key73). }].                     ] valueWithArguments: {( head). }.                 ] valueWithArguments: {(((SmallScheme globalRef:  #'car')                          value: ( l))). (((SmallScheme globalRef:  #'cdr')                          value: ( l))). }]).              out := (             [ :str :col |  ((( col) == false) not)                     	ifTrue: [ ((((output value: ( str))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'X2B')                              value: ( col) value: (((SmallScheme globalRef:  #'stringX2Dlength')                              value: ( str))))]                         	ifFalse: [ false]]                     	ifFalse: [ false]]).              wr := (             [ :obj :col |                   [ | wrX2Dexpr wrX2Dlst |                                     wrX2Dexpr := (                   [ :expr :col |  ((((readX2DmacroX3F value: ( expr))) == false) not)                           	ifTrue: [(wr value: ((readX2DmacroX2Dbody value: ( expr))) value: ((out value: ((readX2DmacroX2Dprefix value: ( expr))) value: ( col))))]                           	ifFalse: [(wrX2Dlst value: ( expr) value: ( col))]]).                    wrX2Dlst := (                   [ :l :col |  (((((SmallScheme globalRef:  #'pairX3F')                                value: ( l))) == false) not)                           	ifTrue: [                            [ | loop |                                loop :=                                [ :l :col |                                 ((( col) == false) not)                                   	ifTrue: [ (((((SmallScheme globalRef:  #'pairX3F')                                            value: ( l))) == false) not)                                       	ifTrue: [(loop value: (((SmallScheme globalRef:  #'cdr')                                            value: ( l))) value: ((wr value: (((SmallScheme globalRef:  #'car')                                            value: ( l))) value: ((out value: ( ' ') value: ( col))))))]                                       	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                                value: ( l))) == false) not)                                           	ifTrue: [(out value: ( ')') value: ( col))]                                           	ifFalse: [(out value: ( ')') value: ((wr value: ( l) value: ((out value: ( ' . ') value: ( col))))))]]]                                   	ifFalse: [ false]                           ].                           loop valueWithArguments: {                               ((SmallScheme globalRef:  #'cdr')                                    value: ( l)).                                (wr value: (((SmallScheme globalRef:  #'car')                                    value: ( l))) value: ((out value: ( '(') value: ( col)))). } ] value]                           	ifFalse: [(out value: ( '()') value: ( col))]]).                      (((((SmallScheme globalRef:  #'pairX3F')                              value: ( obj))) == false) not)                         	ifTrue: [(wrX2Dexpr value: ( obj) value: ( col))]                         	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                  value: ( obj))) == false) not)                             	ifTrue: [(wrX2Dlst value: ( obj) value: ( col))]                             	ifFalse: [ (((((SmallScheme globalRef:  #'vectorX3F')                                      value: ( obj))) == false) not)                                 	ifTrue: [(wrX2Dlst value: (((SmallScheme globalRef:  #'vectorX2DX3Elist')                                      value: ( obj))) value: ((out value: ( '#') value: ( col))))]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'booleanX3F')                                          value: ( obj))) == false) not)                                     	ifTrue: [(out value: ( ((( obj) == false) not)                                         	ifTrue: [ '#t']                                         	ifFalse: [ '#f']) value: ( col))]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'numberX3F')                                              value: ( obj))) == false) not)                                         	ifTrue: [(out value: (((SmallScheme globalRef:  #'numberX2DX3Estring')                                              value: ( obj))) value: ( col))]                                         	ifFalse: [ (((((SmallScheme globalRef:  #'symbolX3F')                                                  value: ( obj))) == false) not)                                             	ifTrue: [(out value: (((SmallScheme globalRef:  #'symbolX2DX3Estring')                                                  value: ( obj))) value: ( col))]                                             	ifFalse: [ (((((SmallScheme globalRef:  #'procedureX3F')                                                      value: ( obj))) == false) not)                                                 	ifTrue: [(out value: ( '#[procedure]') value: ( col))]                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'stringX3F')                                                          value: ( obj))) == false) not)                                                     	ifTrue: [ ((( displayX3F) == false) not)                                                         	ifTrue: [(out value: ( obj) value: ( col))]                                                         	ifFalse: [                                                          [ | loop |                                                              loop :=                                                              [ :i :j :col |                                                               ((( ((( col) == false) not)                                                                     	ifTrue: [((SmallScheme globalRef:  #'X3C')                                                                          value: ( j) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                                          value: ( obj))))]                                                                     	ifFalse: [ false]) == false) not)                                                                 	ifTrue: [ [ :c |                                                                       ((( [ :temp77 |                                                                               ((( temp77) == false) not)                                                                                 	ifTrue: [ temp77]                                                                                 	ifFalse: [((SmallScheme globalRef:  #'charX3DX3F')                                                                                      value: ( c) value: ( $"))].                                                                         ] valueWithArguments: {(((SmallScheme globalRef:  #'charX3DX3F')                                                                                  value: ( c) value: ( $\))). }) == false) not)                                                                         	ifTrue: [(loop value: ( j) value: (((SmallScheme globalRef:  #'X2B')                                                                              value: ( j) value: ( 1))) value: ((out value: ( '\') value: ((out value: (((SmallScheme globalRef:  #'substring')                                                                              value: ( obj) value: ( i) value: ( j))) value: ( col))))))]                                                                         	ifFalse: [(loop value: ( i) value: (((SmallScheme globalRef:  #'X2B')                                                                              value: ( j) value: ( 1))) value: ( col))].                                                                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                                                                          value: ( obj) value: ( j))). }]                                                                 	ifFalse: [(out value: ( '"') value: ((out value: (((SmallScheme globalRef:  #'substring')                                                                      value: ( obj) value: ( i) value: ( j))) value: ( col))))]                                                         ].                                                         loop valueWithArguments: {                                                              00.                                                               00.                                                              (out value: ( '"') value: ( col)). } ] value]]                                                     	ifFalse: [ (((((SmallScheme globalRef:  #'charX3F')                                                              value: ( obj))) == false) not)                                                         	ifTrue: [ ((( displayX3F) == false) not)                                                             	ifTrue: [(out value: (((SmallScheme globalRef:  #'makeX2Dstring')                                                                  value: ( 1) value: ( obj))) value: ( col))]                                                             	ifFalse: [(out value: ( ( obj asSchemeObjString)) value: ( col))]]                                                         	ifFalse: [ (((((SmallScheme globalRef:  #'inputX2DportX3F')                                                                  value: ( obj))) == false) not)                                                             	ifTrue: [(out value: ( '#[input-port]') value: ( col))]                                                             	ifFalse: [ (((((SmallScheme globalRef:  #'outputX2DportX3F')                                                                      value: ( obj))) == false) not)                                                                 	ifTrue: [(out value: ( '#[output-port]') value: ( col))]                                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                                                          value: ( obj))) == false) not)                                                                     	ifTrue: [(out value: ( '#[eof-object]') value: ( col))]                                                                     	ifFalse: [(out value: ( '#[unknown]') value: ( col))]]]]]]]]]]]].                 ] value]).              pp := (             [ :obj :col |                   [ | spaces indent pr ppX2Dexpr ppX2Dcall ppX2Dlist ppX2Ddown ppX2Dgeneral ppX2DexprX2Dlist ppX2Dlambda ppX2Dif ppX2Dcond ppX2Dcase ppX2Dand ppX2Dlet ppX2Dbegin ppX2Ddo indentX2Dgeneral maxX2DcallX2DheadX2Dwidth maxX2DexprX2Dwidth style |                                     spaces := (                   [ :n :col |  (((((SmallScheme globalRef:  #'X3E')                                value: ( n) value: ( 00))) == false) not)                           	ifTrue: [ (((((SmallScheme globalRef:  #'X3E')                                    value: ( n) value: ( 7))) == false) not)                               	ifTrue: [(spaces value: (((SmallScheme globalRef:  #'X2D')                                    value: ( n) value: ( 8))) value: ((out value: ( '        ') value: ( col))))]                               	ifFalse: [(out value: (((SmallScheme globalRef:  #'substring')                                    value: ( '        ') value: ( 00) value: ( n))) value: ( col))]]                           	ifFalse: [ col]]).                    indent := (                   [ :to :col |  ((( col) == false) not)                           	ifTrue: [ (((((SmallScheme globalRef:  #'X3C')                                    value: ( to) value: ( col))) == false) not)                               	ifTrue: [ ((((out value: (((SmallScheme globalRef:  #'makeX2Dstring')                                        value: ( 1) value: ((Character cr)))) value: ( col))) == false) not)                                   	ifTrue: [(spaces value: ( to) value: ( 00))]                                   	ifFalse: [ false]]                               	ifFalse: [(spaces value: (((SmallScheme globalRef:  #'X2D')                                    value: ( to) value: ( col))) value: ( col))]]                           	ifFalse: [ false]]).                    pr := (                   [ :obj :col :extra :ppX2Dpair |  ((( [ :temp78 |                                 ((( temp78) == false) not)                                   	ifTrue: [ temp78]                                   	ifFalse: [((SmallScheme globalRef:  #'vectorX3F')                                        value: ( obj))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'pairX3F')                                    value: ( obj))). }) == false) not)                           	ifTrue: [ [ :result :left |                                 [                                 ((SmallScheme globalRef:  #'genericX2Dwrite')                                                                       valueWithArguments: {  obj.  displayX3F.  false.                                  [ :str |  [                                       (result := ((SmallScheme globalRef:  #'cons')                                            value: ( str) value: ( result))).                                       (left := ((SmallScheme globalRef:  #'X2D')                                            value: ( left) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                            value: ( str))))).                                       ((SmallScheme globalRef:  #'X3E')                                            value: ( left) value: ( 00)).                                      ] value].}).                                  (((((SmallScheme globalRef:  #'X3E')                                          value: ( left) value: ( 00))) == false) not)                                     	ifTrue: [(out value: (((SmallScheme globalRef:  #'reverseX2DstringX2Dappend')                                          value: ( result))) value: ( col))]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'pairX3F')                                              value: ( obj))) == false) not)                                         	ifTrue: [(ppX2Dpair value: ( obj) value: ( col) value: ( extra))]                                         	ifFalse: [(ppX2Dlist                                          valueWithArguments: { ((SmallScheme globalRef:  #'vectorX2DX3Elist')                                              value: ( obj)). (out value: ( '#') value: ( col)).  extra.  ppX2Dexpr.})]].                                ] value.                           ] valueWithArguments: {( nil). (((SmallScheme globalRef:  #'min')                                    value: (((SmallScheme globalRef:  #'X2B')                                    value: (((SmallScheme globalRef:  #'X2D')                                    value: (((SmallScheme globalRef:  #'X2D')                                    value: ( width) value: ( col))) value: ( extra))) value: ( 1))) value: ( maxX2DexprX2Dwidth))). }]                           	ifFalse: [(wr value: ( obj) value: ( col))]]).                    ppX2Dexpr := (                   [ :expr :col :extra |  ((((readX2DmacroX3F value: ( expr))) == false) not)                           	ifTrue: [(pr                            valueWithArguments: { (readX2DmacroX2Dbody value: ( expr)). (out value: ((readX2DmacroX2Dprefix value: ( expr))) value: ( col)).  extra.  ppX2Dexpr.})]                           	ifFalse: [ [ :head |                                 (((((SmallScheme globalRef:  #'symbolX3F')                                        value: ( head))) == false) not)                                   	ifTrue: [ [ :proc |                                         ((( proc) == false) not)                                           	ifTrue: [(proc value: ( expr) value: ( col) value: ( extra))]                                           	ifFalse: [ (((((SmallScheme globalRef:  #'X3E')                                                    value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                    value: (((SmallScheme globalRef:  #'symbolX2DX3Estring')                                                    value: ( head))))) value: ( maxX2DcallX2DheadX2Dwidth))) == false) not)                                               	ifTrue: [(ppX2Dgeneral                                                valueWithArguments: {  expr.  col.  extra.  false.  false.  false.  ppX2Dexpr.})]                                               	ifFalse: [(ppX2Dcall                                                valueWithArguments: {  expr.  col.  extra.  ppX2Dexpr.})]].                                   ] valueWithArguments: {((style value: ( head))). }]                                   	ifFalse: [(ppX2Dlist                                    valueWithArguments: {  expr.  col.  extra.  ppX2Dexpr.})].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'car')                                    value: ( expr))). }]]).                    ppX2Dcall := (                   [ :expr :col :extra :ppX2Ditem |  [ :colX2A |                             ((( col) == false) not)                               	ifTrue: [(ppX2Ddown                                valueWithArguments: { ((SmallScheme globalRef:  #'cdr')                                    value: ( expr)).  colX2A. ((SmallScheme globalRef:  #'X2B')                                    value: ( colX2A) value: ( 1)).  extra.  ppX2Ditem.})]                               	ifFalse: [ false].                       ] valueWithArguments: {((wr value: (((SmallScheme globalRef:  #'car')                                value: ( expr))) value: ((out value: ( '(') value: ( col))))). }]).                    ppX2Dlist := (                   [ :l :col :extra :ppX2Ditem |  [ :col |                            (ppX2Ddown                            valueWithArguments: {  l.  col.  col.  extra.  ppX2Ditem.}).                       ] valueWithArguments: {((out value: ( '(') value: ( col))). }]).                    ppX2Ddown := (                   [ :l :col1 :col2 :extra :ppX2Ditem |                         [ | loop |                            loop :=                            [ :l :col |                             ((( col) == false) not)                               	ifTrue: [ (((((SmallScheme globalRef:  #'pairX3F')                                        value: ( l))) == false) not)                                   	ifTrue: [ [ :rest |                                         [ :extra |                                            (loop value: ( rest) value: ((pr                                            valueWithArguments: { ((SmallScheme globalRef:  #'car')                                                value: ( l)). (indent value: ( col2) value: ( col)).  extra.  ppX2Ditem.}))).                                       ] valueWithArguments: {( (((((SmallScheme globalRef:  #'nullX3F')                                                    value: ( rest))) == false) not)                                               	ifTrue: [((SmallScheme globalRef:  #'X2B')                                                    value: ( extra) value: ( 1))]                                               	ifFalse: [ 00]). }.                                   ] valueWithArguments: {(((SmallScheme globalRef:  #'cdr')                                            value: ( l))). }]                                   	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                            value: ( l))) == false) not)                                       	ifTrue: [(out value: ( ')') value: ( col))]                                       	ifFalse: [(out value: ( ')') value: ((pr                                        valueWithArguments: {  l. (indent value: ( col2) value: ((out value: ( '.') value: ((indent value: ( col2) value: ( col)))))). ((SmallScheme globalRef:  #'X2B')                                            value: ( extra) value: ( 1)).  ppX2Ditem.})))]]]                               	ifFalse: [ false]                       ].                       loop valueWithArguments: {                            l.                             col1. } ] value]).                    ppX2Dgeneral := (                   [ :expr :col :extra :namedX3F :ppX2D1 :ppX2D2 :ppX2D3 |                         [ | tail1 tail2 tail3 |                                                 tail1 := (                         [ :rest :col1 :col2 :col3 |  ((( ((( ppX2D1) == false) not)                                     	ifTrue: [((SmallScheme globalRef:  #'pairX3F')                                          value: ( rest))]                                     	ifFalse: [ false]) == false) not)                                 	ifTrue: [                                 [ :val1 |                                    [ :rest |                                      [ :extra |                                        (tail2                                        valueWithArguments: {  rest.  col1. (pr                                        valueWithArguments: {  val1. (indent value: ( col3) value: ( col2)).  extra.  ppX2D1.}).  col3.})                                     ] value: ( (((((SmallScheme globalRef:  #'nullX3F')                                              value: ( rest))) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'X2B')                                              value: ( extra) value: ( 1))]                                         	ifFalse: [ 00])                                   ] value: (((SmallScheme globalRef:  #'cdr')                                        value: ( rest)))                                 ] value: (((SmallScheme globalRef:  #'car')                                      value: ( rest)))]                                 	ifFalse: [(tail2                                  valueWithArguments: {  rest.  col1.  col2.  col3.})]]).                          tail2 := (                         [ :rest :col1 :col2 :col3 |  ((( ((( ppX2D2) == false) not)                                     	ifTrue: [((SmallScheme globalRef:  #'pairX3F')                                          value: ( rest))]                                     	ifFalse: [ false]) == false) not)                                 	ifTrue: [                                 [ :val1 |                                    [ :rest |                                      [ :extra |                                        (tail3 value: ( rest) value: ( col1) value: ((pr                                        valueWithArguments: {  val1. (indent value: ( col3) value: ( col2)).  extra.  ppX2D2.})))                                     ] value: ( (((((SmallScheme globalRef:  #'nullX3F')                                              value: ( rest))) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'X2B')                                              value: ( extra) value: ( 1))]                                         	ifFalse: [ 00])                                   ] value: (((SmallScheme globalRef:  #'cdr')                                        value: ( rest)))                                 ] value: (((SmallScheme globalRef:  #'car')                                      value: ( rest)))]                                 	ifFalse: [(tail3 value: ( rest) value: ( col1) value: ( col2))]]).                          tail3 := (                         [ :rest :col1 :col2 | (ppX2Ddown                              valueWithArguments: {  rest.  col2.  col1.  extra.  ppX2D3.})]).                                                      [ :head |                              [ :rest |                                [ :colX2A |                                   ((( ((( namedX3F) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'pairX3F')                                              value: ( rest))]                                         	ifFalse: [ false]) == false) not)                                     	ifTrue: [                                     [ :name |                                        [ :rest |                                          [ :colX2AX2A |                                            (tail1                                            valueWithArguments: {  rest. ((SmallScheme globalRef:  #'X2B')                                                value: ( col) value: ( indentX2Dgeneral)).  colX2AX2A. ((SmallScheme globalRef:  #'X2B')                                                value: ( colX2AX2A) value: ( 1)).})                                         ] value: ((wr value: ( name) value: ((out value: ( ' ') value: ( colX2A)))))                                       ] value: (((SmallScheme globalRef:  #'cdr')                                            value: ( rest)))                                     ] value: (((SmallScheme globalRef:  #'car')                                          value: ( rest)))]                                     	ifFalse: [(tail1                                      valueWithArguments: {  rest. ((SmallScheme globalRef:  #'X2B')                                          value: ( col) value: ( indentX2Dgeneral)).  colX2A. ((SmallScheme globalRef:  #'X2B')                                          value: ( colX2A) value: ( 1)).})]                               ] value: ((wr value: ( head) value: ((out value: ( '(') value: ( col)))))                             ] value: (((SmallScheme globalRef:  #'cdr')                                  value: ( expr)))                           ] value: (((SmallScheme globalRef:  #'car')                                value: ( expr))).                       ] value]).                    ppX2DexprX2Dlist := (                   [ :l :col :extra | (ppX2Dlist                        valueWithArguments: {  l.  col.  extra.  ppX2Dexpr.})]).                    ppX2Dlambda := (                   [ :expr :col :extra | (ppX2Dgeneral                        valueWithArguments: {  expr.  col.  extra.  false.  ppX2DexprX2Dlist.  false.  ppX2Dexpr.})]).                    ppX2Dif := (                   [ :expr :col :extra | (ppX2Dgeneral                        valueWithArguments: {  expr.  col.  extra.  false.  ppX2Dexpr.  false.  ppX2Dexpr.})]).                    ppX2Dcond := (                   [ :expr :col :extra | (ppX2Dcall                        valueWithArguments: {  expr.  col.  extra.  ppX2DexprX2Dlist.})]).                    ppX2Dcase := (                   [ :expr :col :extra | (ppX2Dgeneral                        valueWithArguments: {  expr.  col.  extra.  false.  ppX2Dexpr.  false.  ppX2DexprX2Dlist.})]).                    ppX2Dand := (                   [ :expr :col :extra | (ppX2Dcall                        valueWithArguments: {  expr.  col.  extra.  ppX2Dexpr.})]).                    ppX2Dlet := (                   [ :expr :col :extra |                        [ :rest |                          [ :namedX3F |                            (ppX2Dgeneral                            valueWithArguments: {  expr.  col.  extra.  namedX3F.  ppX2DexprX2Dlist.  false.  ppX2Dexpr.})                         ] value: ( (((((SmallScheme globalRef:  #'pairX3F')                                  value: ( rest))) == false) not)                             	ifTrue: [((SmallScheme globalRef:  #'symbolX3F')                                  value: (((SmallScheme globalRef:  #'car')                                  value: ( rest))))]                             	ifFalse: [ false])                       ] value: (((SmallScheme globalRef:  #'cdr')                            value: ( expr)))]).                    ppX2Dbegin := (                   [ :expr :col :extra | (ppX2Dgeneral                        valueWithArguments: {  expr.  col.  extra.  false.  false.  false.  ppX2Dexpr.})]).                    ppX2Ddo := (                   [ :expr :col :extra | (ppX2Dgeneral                        valueWithArguments: {  expr.  col.  extra.  false.  ppX2DexprX2Dlist.  ppX2DexprX2Dlist.  ppX2Dexpr.})]).                    indentX2Dgeneral := ( 2).                    maxX2DcallX2DheadX2Dwidth := ( 5).                    maxX2DexprX2Dwidth := ( 50).                    style := (                   [ :head |  [ :key79 |                             (((((SmallScheme globalRef:  #'memv')                                    value: ( key79) value: ( ({ #'lambda'.  #'letX2A'.  #'letrec'.  #'define'. } asRest)))) == false) not)                               	ifTrue: [ ppX2Dlambda]                               	ifFalse: [ [ :key80 |                                     (((((SmallScheme globalRef:  #'memv')                                            value: ( key80) value: ( ({ #'if'.  #'setX21'. } asRest)))) == false) not)                                       	ifTrue: [ ppX2Dif]                                       	ifFalse: [ [ :key81 |                                             (((((SmallScheme globalRef:  #'memv')                                                    value: ( key81) value: ( ({ #'cond'. } asRest)))) == false) not)                                               	ifTrue: [ ppX2Dcond]                                               	ifFalse: [ [ :key82 |                                                     (((((SmallScheme globalRef:  #'memv')                                                            value: ( key82) value: ( ({ #'case'. } asRest)))) == false) not)                                                       	ifTrue: [ ppX2Dcase]                                                       	ifFalse: [ [ :key83 |                                                             (((((SmallScheme globalRef:  #'memv')                                                                    value: ( key83) value: ( ({ #'and'.  #'or'. } asRest)))) == false) not)                                                               	ifTrue: [ ppX2Dand]                                                               	ifFalse: [ [ :key84 |                                                                     (((((SmallScheme globalRef:  #'memv')                                                                            value: ( key84) value: ( ({ #'let'. } asRest)))) == false) not)                                                                       	ifTrue: [ ppX2Dlet]                                                                       	ifFalse: [ [ :key85 |                                                                             (((((SmallScheme globalRef:  #'memv')                                                                                    value: ( key85) value: ( ({ #'begin'. } asRest)))) == false) not)                                                                               	ifTrue: [ ppX2Dbegin]                                                                               	ifFalse: [ [ :key86 |                                                                                     (((((SmallScheme globalRef:  #'memv')                                                                                            value: ( key86) value: ( ({ #'do'. } asRest)))) == false) not)                                                                                       	ifTrue: [ ppX2Ddo]                                                                                       	ifFalse: [ [                                                                                          key86.                                                                                          false.                                                                                        ] value].                                                                               ] valueWithArguments: {( key85). }].                                                                       ] valueWithArguments: {( key84). }].                                                               ] valueWithArguments: {( key83). }].                                                       ] valueWithArguments: {( key82). }].                                               ] valueWithArguments: {( key81). }].                                       ] valueWithArguments: {( key80). }].                               ] valueWithArguments: {( key79). }].                       ] valueWithArguments: {( head). }]).                     (pr                      valueWithArguments: {  obj.  col.  00.  ppX2Dexpr.}).                 ] value]).                ((( width) == false) not)                   	ifTrue: [(out value: (((SmallScheme globalRef:  #'makeX2Dstring')                        value: ( 1) value: ((Character cr)))) value: ((pp value: ( obj) value: ( 00))))]                   	ifFalse: [(wr value: ( obj) value: ( 00))].           ] value] ) . SmallScheme define:  #'reverseX2DstringX2Dappend'    "reverse-string-append"  as: (        [ :l | ((SmallScheme globalRef:  #'apply')                value: ( (SmallScheme globalRef:  #'stringX2Dappend')               ) value: (((SmallScheme globalRef:  #'reverse')                value: ( l))))] ) . SmallScheme define:  #'prettyX2Dprint'    "pretty-print"  as: (        [ :obj :opt |            opt := opt asRest.            [ :port |                ((SmallScheme globalRef:  #'genericX2Dwrite')                                   valueWithArguments: {  obj.  false.  79.                [ :s |  [                     ((SmallScheme globalRef:  #'display')                          value: ( s) value: ( port)).                      true.                    ] value].}).           ] valueWithArguments: {( (((((SmallScheme globalRef:  #'pairX3F')                        value: ( opt))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'car')                        value: ( opt))]                   	ifFalse: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]). }] withLastArgRest  ) . SmallScheme define:  #'prettyX2DprintX2DtoX2Dstring'    "pretty-print-to-string"  as: (        [ :obj |  [ :result |                 [                 ((SmallScheme globalRef:  #'genericX2Dwrite')                                       valueWithArguments: {  obj.  false.  79.                  [ :str |  [                       (result := ((SmallScheme globalRef:  #'cons')                            value: ( str) value: ( result))).                        true.                      ] value].}).                 ((SmallScheme globalRef:  #'reverseX2DstringX2Dappend')                      value: ( result)).                ] value.           ] valueWithArguments: {( nil). }] ) .! !!SmallScheme class methodsFor: 'initialization'!initRatize SmallScheme define:  #'findX2DratioX2Dbetween'    "find-ratio-between"  as: (        [ :x :y |             [ | sr |                         sr := (             [ :x :y |  [ :fx :fy |                       (((((SmallScheme globalRef:  #'X3EX3D')                              value: ( fx) value: ( x))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'list')                              value: ( fx) value: ( 1))]                         	ifFalse: [ (((((SmallScheme globalRef:  #'X3D')                                  value: ( fx) value: ( fy))) == false) not)                             	ifTrue: [ [ :rat |                                  ((SmallScheme globalRef:  #'list')                                      value: (((SmallScheme globalRef:  #'X2B')                                      value: (((SmallScheme globalRef:  #'cadr')                                      value: ( rat))) value: (((SmallScheme globalRef:  #'X2A')                                      value: ( fx) value: (((SmallScheme globalRef:  #'car')                                      value: ( rat))))))) value: (((SmallScheme globalRef:  #'car')                                      value: ( rat)))).                             ] valueWithArguments: {((sr value: (((SmallScheme globalRef:  #'X2F')                                      value: (((SmallScheme globalRef:  #'X2D')                                      value: ( y) value: ( fy))))) value: (((SmallScheme globalRef:  #'X2F')                                      value: (((SmallScheme globalRef:  #'X2D')                                      value: ( x) value: ( fx))))))). }]                             	ifFalse: [((SmallScheme globalRef:  #'list')                                  value: (((SmallScheme globalRef:  #'X2B')                                  value: ( 1) value: ( fx))) value: ( 1))]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'inexactX2DX3Eexact')                          value: (((SmallScheme globalRef:  #'floor')                          value: ( x))))). (((SmallScheme globalRef:  #'inexactX2DX3Eexact')                          value: (((SmallScheme globalRef:  #'floor')                          value: ( y))))). }]).                (((((SmallScheme globalRef:  #'X3C')                        value: ( y) value: ( x))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'findX2DratioX2Dbetween')                        value: ( y) value: ( x))]                   	ifFalse: [ (((((SmallScheme globalRef:  #'X3EX3D')                            value: ( x) value: ( y))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'list')                            value: ( x) value: ( 1))]                       	ifFalse: [ (((((SmallScheme globalRef:  #'positiveX3F')                                value: ( x))) == false) not)                           	ifTrue: [(sr value: ( x) value: ( y))]                           	ifFalse: [ (((((SmallScheme globalRef:  #'negativeX3F')                                    value: ( y))) == false) not)                               	ifTrue: [ [ :rat |                                    ((SmallScheme globalRef:  #'list')                                        value: (((SmallScheme globalRef:  #'X2D')                                        value: (((SmallScheme globalRef:  #'car')                                        value: ( rat))))) value: (((SmallScheme globalRef:  #'cadr')                                        value: ( rat)))).                               ] valueWithArguments: {((sr value: (((SmallScheme globalRef:  #'X2D')                                        value: ( y))) value: (((SmallScheme globalRef:  #'X2D')                                        value: ( x))))). }]                               	ifFalse: [ ({ 00.  1. } asRest)]]]].           ] value] ) . SmallScheme define:  #'findX2Dratio'    "find-ratio"  as: (        [ :x :e | ((SmallScheme globalRef:  #'findX2DratioX2Dbetween')                value: (((SmallScheme globalRef:  #'X2D')                value: ( x) value: ( e))) value: (((SmallScheme globalRef:  #'X2B')                value: ( x) value: ( e))))] ) . SmallScheme define:  #'rationalize'  as: (        [ :x :e | ((SmallScheme globalRef:  #'apply')                value: ( (SmallScheme globalRef:  #'X2F')               ) value: (((SmallScheme globalRef:  #'findX2Dratio')                value: ( x) value: ( e))))] ) .! !!SmallScheme class methodsFor: 'initialization'!initRead SmallScheme define:  #'read'  as: (        [ :inputX2Dport |            inputX2Dport := inputX2Dport asRest.                       [ | whitespace delimiters specialX2DinitialX2Dchars specialX2Dinitials specialX2DsubsequentX2Dchars pecularX2Didentifier pecularX2Dinitials syntacticX2Dkeywords expressionX2Dkeywords characterX2DnamesX2Dalist tokenX2Dclasses abbreviationX2Dstarts radixX2Dchars exactnessX2Dchars letterX2Dchars digitX2Dchars numX2D2X2Dchars numX2D8X2Dchars numX2D10X2Dchars numX2D16X2Dchars exponentX2DmarkerX2Dchars signX2Dchars legalX2DnumberX2DcharsX2Dlist subsequents rparenX2Dmarker periodX2Dmarker stringX2DX3EcaseifiedX2Dsymbol read1 commentX2DcharX3F sharpX2DcharX3F stringX2DcharX3F lparenX2DcharX3F rparenX2DcharX3F specialX2DinitialX3F pecularX2DinitialX3F identifierX2DsubsequentX2DcharX3F abbrevX2DcharX3F legalX2DnumberX2DcharX3F consumeX2Dchar consumeX2Dcomment readX2DsharpX2Dthingie makeX2Dboolean readX2DsharpX2Dsym readX2Dcharacter readX2DidentifierX2Dstring readX2Dnumber readX2DnumberX2Dloop readX2Didentifier readX2Dabbreviation readX2Dstring readX2Dpecular periodX2DmarkerX3F rparenX2DmarkerX3F readX2Dlist readX2Dvector |                         whitespace := ( ({ $ . (Character cr). } asRest)).              delimiters := (((SmallScheme globalRef:  #'append')                  value: (((SmallScheme globalRef:  #'list')                               valueWithArguments: {  $(.  $).  $".  $;.})) value: ( whitespace))).              specialX2DinitialX2Dchars := ( '!!!!$%&/:*<=>?^_~').              specialX2Dinitials := (((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( specialX2DinitialX2Dchars))).              specialX2DsubsequentX2Dchars := ( '+-.@').              pecularX2Didentifier := ( ({ #'X2B'.  #'X2D'.  #'X2EX2EX2E'. } asRest)).              pecularX2Dinitials := ( ({ $+.  $-.  $.. } asRest)).              syntacticX2Dkeywords := ( ({ #'else'.  #'X3DX3E'.  #'define'.  #'unquote'.  #'unquoteX2Dsplicing'. } asRest)).              expressionX2Dkeywords := ( ({ #'quote'.  #'lambda'.  #'if'.  #'setX21'.  #'begin'.  #'cond'.  #'and'.  #'or'.  #'case'.  #'let'.  #'letX2A'.  #'letrec'.  #'do'.  #'delay'.  #'quasiquote'. } asRest)).              characterX2DnamesX2Dalist := (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'space') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 32))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'tab') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 9))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'return') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 13))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'newline') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 10))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'formfeed') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 12))))) value: ( nil))))))))))).              tokenX2Dclasses := ( ({ #'identifier'.  #'boolean'.  #'number'.  #'character'.  #'string'.  #'lparen'.  #'rparen'.  #'sharpX2Dlparen'.  #'quote'.  #'backquote'.  #'comma'.  #'commaX2Dsplice'.  #'period'. } asRest)).              abbreviationX2Dstarts := ( ({ $,.  $'.  $`. } asRest)).              radixX2Dchars := ( 'bodx').              exactnessX2Dchars := ( 'ie').              letterX2Dchars := ( 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ').              digitX2Dchars := ( '0123456789').              numX2D2X2Dchars := ( '01').              numX2D8X2Dchars := ( '01234567').              numX2D10X2Dchars := ( digitX2Dchars).              numX2D16X2Dchars := ( '01234567689abcdefABCDEF').              exponentX2DmarkerX2Dchars := ( 'esfdl').              signX2Dchars := ( '+-').              legalX2DnumberX2DcharsX2Dlist := (((SmallScheme globalRef:  #'append')                               valueWithArguments: { ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( signX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( numX2D16X2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( exponentX2DmarkerX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( radixX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( exactnessX2Dchars)). ((SmallScheme globalRef:  #'list')                               valueWithArguments: {  $..  $#.  $@.  $/.}).})).              subsequents := (((SmallScheme globalRef:  #'append')                               valueWithArguments: { ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( letterX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( digitX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( specialX2DinitialX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( specialX2DsubsequentX2Dchars)).})).              rparenX2Dmarker := ( ')').              periodX2Dmarker := ( '.').              stringX2DX3EcaseifiedX2Dsymbol := ( [ :squashX2Dcase |                                   [ :str | ((SmallScheme globalRef:  #'stringX2DX3Esymbol')                          value: (((SmallScheme globalRef:  #'listX2DX3Estring')                          value: (((SmallScheme globalRef:  #'map')                          value: ( squashX2Dcase) value: (((SmallScheme globalRef:  #'stringX2DX3Elist')                          value: ( str))))))))].             ] valueWithArguments: {( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( $a) value: (((SmallScheme globalRef:  #'stringX2Dref')                          value: (((SmallScheme globalRef:  #'symbolX2DX3Estring')                          value: ( #'a'))) value: ( 00))))) == false) not)                     	ifTrue: [ (SmallScheme globalRef:  #'charX2Ddowncase')                         ]                     	ifFalse: [ (SmallScheme globalRef:  #'charX2Dupcase')                         ]). }).              read1 := (             [ :port |                   [ | loop |                      loop :=                      [ :next |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))) == false) not)                         	ifTrue: [ next]                         	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DwhitespaceX3F')                                  value: ( next))) == false) not)                             	ifTrue: [ [                               ((SmallScheme globalRef:  #'readX2Dchar')                                    value: ( port)).                               (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                                    value: ( port)))).                              ] value]                             	ifFalse: [ ((((commentX2DcharX3F value: ( next))) == false) not)                                 	ifTrue: [ [                                   (consumeX2Dcomment value: ( port)).                                   (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                                        value: ( port)))).                                  ] value]                                 	ifFalse: [ ((((sharpX2DcharX3F value: ( next))) == false) not)                                     	ifTrue: [(readX2DsharpX2Dthingie value: ( port))]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DnumericX3F')                                              value: ( next))) == false) not)                                         	ifTrue: [(readX2Dnumber value: ( port))]                                         	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DalphabeticX3F')                                                  value: ( next))) == false) not)                                             	ifTrue: [(readX2Didentifier value: ( port))]                                             	ifFalse: [ ((((stringX2DcharX3F value: ( next))) == false) not)                                                 	ifTrue: [(readX2Dstring value: ( port))]                                                 	ifFalse: [ ((((abbrevX2DcharX3F value: ( next))) == false) not)                                                     	ifTrue: [(readX2Dabbreviation value: ( port))]                                                     	ifFalse: [ ((((lparenX2DcharX3F value: ( next))) == false) not)                                                         	ifTrue: [(readX2Dlist value: ( port))]                                                         	ifFalse: [ ((((specialX2DinitialX3F value: ( next))) == false) not)                                                             	ifTrue: [(readX2Didentifier value: ( port))]                                                             	ifFalse: [ ((((pecularX2DinitialX3F value: ( next))) == false) not)                                                                 	ifTrue: [(readX2Dpecular value: ( port))]                                                                 	ifFalse: [ ((((rparenX2DcharX3F value: ( next))) == false) not)                                                                     	ifTrue: [ [                                                                       (consumeX2Dchar value: ( port)).                                                                        rparenX2Dmarker.                                                                      ] value]                                                                     	ifFalse: [((SmallScheme globalRef:  #'error')                                                                          value: ( 'read: unacceptable character with code:') value: (((SmallScheme globalRef:  #'charX2DX3Einteger')                                                                          value: ( next))))]]]]]]]]]]]]                 ].                 loop valueWithArguments: {                     ((SmallScheme globalRef:  #'peekX2Dchar')                          value: ( port)). } ] value]).              commentX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $;))]).              sharpX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $#))]).              stringX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $"))]).              lparenX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $())]).              rparenX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $)))]).              specialX2DinitialX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( specialX2Dinitials))]).              pecularX2DinitialX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( pecularX2Dinitials))]).              identifierX2DsubsequentX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( subsequents))]).              abbrevX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( abbreviationX2Dstarts))]).              legalX2DnumberX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( legalX2DnumberX2DcharsX2Dlist))]).              consumeX2Dchar := (             [ :port |  (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                          value: (((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port))))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'error')                          value: ( 'Unexpected End Of File'))]]).              consumeX2Dcomment := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                       [ | loop |                        loop :=                        [ :next |                         (((((SmallScheme globalRef:  #'not')                                value: ( [ :temp30 |                                 ((( temp30) == false) not)                                   	ifTrue: [ temp30]                                   	ifFalse: [((SmallScheme globalRef:  #'charX2DnewlineX3F')                                        value: ( next))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'eofX2DobjectX3F')                                    value: ( next))). }))) == false) not)                           	ifTrue: [ [                             (consumeX2Dchar value: ( port)).                             (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                                  value: ( port)))).                            ] value]                           	ifFalse: [ #'done']                   ].                   loop valueWithArguments: {                       ((SmallScheme globalRef:  #'peekX2Dchar')                            value: ( port)). } ] value.                  ] value]).              readX2DsharpX2Dthingie := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                    [ :next |                         [ :key31 |                             (((((SmallScheme globalRef:  #'memv')                                    value: ( key31) value: ( ({ $t.  $f.  $T.  $F. } asRest)))) == false) not)                               	ifTrue: [(makeX2Dboolean value: ( port))]                               	ifFalse: [ [ :key32 |                                     (((((SmallScheme globalRef:  #'memv')                                            value: ( key32) value: ( ({ $e.  $i.  $o.  $b.  $d.  $x.  $E.  $I.  $O.  $B.  $D.  $X. } asRest)))) == false) not)                                       	ifTrue: [(readX2DnumberX2Dloop value: ( ({ $#. } asRest)) value: ( port))]                                       	ifFalse: [ [ :key33 |                                             (((((SmallScheme globalRef:  #'memv')                                                    value: ( key33) value: ( ({ $\. } asRest)))) == false) not)                                               	ifTrue: [(readX2Dcharacter value: ( port))]                                               	ifFalse: [ [ :key34 |                                                     (((((SmallScheme globalRef:  #'memv')                                                            value: ( key34) value: ( ({ $(. } asRest)))) == false) not)                                                       	ifTrue: [(readX2Dvector value: ( port))]                                                       	ifFalse: [ [ :key35 |                                                             (((((SmallScheme globalRef:  #'memv')                                                                    value: ( key35) value: ( ({ $'. } asRest)))) == false) not)                                                               	ifTrue: [(readX2DsharpX2Dsym value: ( port))]                                                               	ifFalse: [ [                                                                  key35.                                                                 ((SmallScheme globalRef:  #'error')                                                                      value: ( 'Unknown sharp syntax') value: ( next)).                                                                ] value].                                                       ] valueWithArguments: {( key34). }].                                               ] valueWithArguments: {( key33). }].                                       ] valueWithArguments: {( key32). }].                               ] valueWithArguments: {( key31). }].                       ] valueWithArguments: {( next). }.                   ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                            value: ( port))). }.                  ] value]).              makeX2Dboolean := (             [ :port |  [ :key36 |                       (((((SmallScheme globalRef:  #'memv')                              value: ( key36) value: ( ({ $t.  $T. } asRest)))) == false) not)                         	ifTrue: [ true]                         	ifFalse: [ [ :key37 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key37) value: ( ({ $f.  $F. } asRest)))) == false) not)                                 	ifTrue: [ false]                                 	ifFalse: [ [                                    key37.                                   ((SmallScheme globalRef:  #'error')                                        value: ( 'reading boolean: expected #t or #f here')).                                  ] value].                         ] valueWithArguments: {( key36). }].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port))). }]).              readX2DsharpX2Dsym := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                   ((SmallScheme globalRef:  #'cons')                        value: ( #'stringX2DX3Esymbol') value: (((SmallScheme globalRef:  #'cons')                        value: ((readX2DidentifierX2Dstring value: ( port))) value: ( nil)))).                  ] value]).              readX2Dcharacter := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                      [ :next |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'error')                              value: ( 'EOF parsing character while reading file'))]                         	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DalphabeticX3F')                                  value: ( next))) == false) not)                             	ifTrue: [ [ :charX2DnameX2Dstring |                                   (((((SmallScheme globalRef:  #'X3D')                                          value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                          value: ( charX2DnameX2Dstring))))) == false) not)                                     	ifTrue: [((SmallScheme globalRef:  #'stringX2Dref')                                          value: ( charX2DnameX2Dstring) value: ( 00))]                                     	ifFalse: [ [ :result38 |                                           ((( result38) == false) not)                                             	ifTrue: [((                                             [ :bucket | ((SmallScheme globalRef:  #'cdr')                                                      value: ( bucket))]) value: ( result38))]                                             	ifFalse: [((SmallScheme globalRef:  #'error')                                                  value: ( 'read: invalid character name') value: ( charX2DnameX2Dstring))].                                     ] valueWithArguments: {(((SmallScheme globalRef:  #'assq')                                              value: ((stringX2DX3EcaseifiedX2Dsymbol value: ( charX2DnameX2Dstring))) value: ( characterX2DnamesX2Dalist))). }].                             ] valueWithArguments: {((readX2DidentifierX2Dstring value: ( port))). }]                             	ifFalse: [((SmallScheme globalRef:  #'readX2Dchar')                                  value: ( port))]]                   ] value: (((SmallScheme globalRef:  #'peekX2Dchar')                        value: ( port))).                  ] value]).              readX2DidentifierX2Dstring := (             [ :port |                   [ | loop |                      loop :=                      [ :chars |                       [ :next |                           (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                  value: ( next))) == false) not)                             	ifTrue: [((SmallScheme globalRef:  #'listX2DX3Estring')                                  value: (((SmallScheme globalRef:  #'reverse')                                  value: ( chars))))]                             	ifFalse: [ ((((identifierX2DsubsequentX2DcharX3F value: ( next))) == false) not)                                 	ifTrue: [(loop value: (((SmallScheme globalRef:  #'cons')                                      value: (((SmallScheme globalRef:  #'readX2Dchar')                                      value: ( port))) value: ( chars))))]                                 	ifFalse: [((SmallScheme globalRef:  #'listX2DX3Estring')                                      value: (((SmallScheme globalRef:  #'reverse')                                      value: ( chars))))]].                     ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                              value: ( port))). }                 ].                 loop valueWithArguments: {                     ((SmallScheme globalRef:  #'list')                          value: (((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port)))). } ] value]).              readX2Dnumber := (             [ :port | (readX2DnumberX2Dloop value: (((SmallScheme globalRef:  #'list')                      value: (((SmallScheme globalRef:  #'readX2Dchar')                      value: ( port))))) value: ( port))]).              readX2DnumberX2Dloop := (             [ :chars :port |  [ :next |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'stringX2DX3Enumber')                              value: (((SmallScheme globalRef:  #'listX2DX3Estring')                              value: (((SmallScheme globalRef:  #'reverse')                              value: ( chars))))))]                         	ifFalse: [ ((((legalX2DnumberX2DcharX3F value: ( next))) == false) not)                             	ifTrue: [(readX2DnumberX2Dloop value: (((SmallScheme globalRef:  #'cons')                                  value: (((SmallScheme globalRef:  #'readX2Dchar')                                  value: ( port))) value: ( chars))) value: ( port))]                             	ifFalse: [((SmallScheme globalRef:  #'stringX2DX3Enumber')                                  value: (((SmallScheme globalRef:  #'listX2DX3Estring')                                  value: (((SmallScheme globalRef:  #'reverse')                                  value: ( chars))))))]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                          value: ( port))). }]).              readX2Didentifier := (             [ :port | (stringX2DX3EcaseifiedX2Dsymbol value: ((readX2DidentifierX2Dstring value: ( port))))]).              readX2Dabbreviation := (             [ :port |  [ :key39 |                       (((((SmallScheme globalRef:  #'memv')                              value: ( key39) value: ( ({ $`. } asRest)))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'list')                              value: ( #'quasiquote') value: ((read1 value: ( port))))]                         	ifFalse: [ [ :key40 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key40) value: ( ({ $'. } asRest)))) == false) not)                                 	ifTrue: [((SmallScheme globalRef:  #'list')                                      value: ( #'quote') value: ((read1 value: ( port))))]                                 	ifFalse: [ [ :key41 |                                       (((((SmallScheme globalRef:  #'memv')                                              value: ( key41) value: ( ({ $,. } asRest)))) == false) not)                                         	ifTrue: [ (((((SmallScheme globalRef:  #'eqX3F')                                                  value: ( $@) value: (((SmallScheme globalRef:  #'peekX2Dchar')                                                  value: ( port))))) == false) not)                                             	ifTrue: [ [                                               (consumeX2Dchar value: ( port)).                                               ((SmallScheme globalRef:  #'list')                                                    value: ( #'unquoteX2Dsplicing') value: ((read1 value: ( port)))).                                              ] value]                                             	ifFalse: [((SmallScheme globalRef:  #'list')                                                  value: ( #'unquote') value: ((read1 value: ( port))))]]                                         	ifFalse: [ [                                            key41.                                           ((SmallScheme globalRef:  #'error')                                                value: ( 'Assert failed in reading abbreviation')).                                          ] value].                                 ] valueWithArguments: {( key40). }].                         ] valueWithArguments: {( key39). }].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port))). }]).              readX2Dstring := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                       [ | loop |                        loop :=                        [ :chars |                         [ :next |                             (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                    value: ( next))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'error')                                    value: ( 'read: End Of File reading string'))]                               	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                        value: ( next) value: ( $"))) == false) not)                                   	ifTrue: [ [                                     (consumeX2Dchar value: ( port)).                                     ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( chars)))).                                    ] value]                                   	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                            value: ( next) value: ( $\))) == false) not)                                       	ifTrue: [ [                                         (consumeX2Dchar value: ( port)).                                          [ :following |                                               (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                                      value: ( following))) == false) not)                                                 	ifTrue: [((SmallScheme globalRef:  #'error')                                                      value: ( 'EOF in read-string'))]                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                          value: ( following) value: ( ({ $".  $\. } asRest)))) == false) not)                                                     	ifTrue: [(loop value: (((SmallScheme globalRef:  #'cons')                                                          value: (((SmallScheme globalRef:  #'readX2Dchar')                                                          value: ( port))) value: ( chars))))]                                                     	ifFalse: [((SmallScheme globalRef:  #'error')                                                          value: ( 'Illegal char following #\') value: ( following))]].                                         ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                                                  value: ( port))). }.                                        ] value]                                       	ifFalse: [(loop value: (((SmallScheme globalRef:  #'cons')                                            value: (((SmallScheme globalRef:  #'readX2Dchar')                                            value: ( port))) value: ( chars))))]]].                       ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                                value: ( port))). }                   ].                   loop valueWithArguments: {                        nil. } ] value.                  ] value]).              readX2Dpecular := (             [ :port |                  [ :char |                    [ :next |                       (((((SmallScheme globalRef:  #'memv')                              value: ( char) value: ( ({ $+.  $-. } asRest)))) == false) not)                         	ifTrue: [ ((((legalX2DnumberX2DcharX3F value: ( next))) == false) not)                             	ifTrue: [(readX2DnumberX2Dloop value: (((SmallScheme globalRef:  #'list')                                  value: ( char))) value: ( port))]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( char) value: ( $+))) == false) not)                                 	ifTrue: [ #'X2B']                                 	ifFalse: [ #'X2D']]]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( $.) value: ( char))) == false) not)                             	ifTrue: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( $.) value: ( next))) == false) not)                                 	ifTrue: [ [                                   (consumeX2Dchar value: ( port)).                                    (((((SmallScheme globalRef:  #'eqX3F')                                            value: ( $.) value: (((SmallScheme globalRef:  #'peekX2Dchar')                                            value: ( port))))) == false) not)                                       	ifTrue: [ [                                         (consumeX2Dchar value: ( port)).                                          #'X2EX2EX2E'.                                        ] value]                                       	ifFalse: [((SmallScheme globalRef:  #'error')                                            value: ( 'Illegal period literal'))].                                  ] value]                                 	ifFalse: [ periodX2Dmarker]]                             	ifFalse: [((SmallScheme globalRef:  #'error')                                  value: ( 'Assert failed in reading pecular identifier') value: ( char))]]                   ] value: (((SmallScheme globalRef:  #'peekX2Dchar')                        value: ( port)))                 ] value: (((SmallScheme globalRef:  #'readX2Dchar')                      value: ( port)))]).              periodX2DmarkerX3F := (             [ :thing | ((SmallScheme globalRef:  #'eqX3F')                      value: ( periodX2Dmarker) value: ( thing))]).              rparenX2DmarkerX3F := (             [ :thing | ((SmallScheme globalRef:  #'eqX3F')                      value: ( rparenX2Dmarker) value: ( thing))]).              readX2Dlist := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                       [ | loop |                        loop :=                        [ :result |                         [ :thing |                             (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                    value: ( thing))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'error')                                    value: ( 'unexpected end of file reading list'))]                               	ifFalse: [ ((((rparenX2DmarkerX3F value: ( thing))) == false) not)                                   	ifTrue: [((SmallScheme globalRef:  #'reverse')                                        value: ( result))]                                   	ifFalse: [ ((((periodX2DmarkerX3F value: ( thing))) == false) not)                                       	ifTrue: [ [ :next |                                             (((((SmallScheme globalRef:  #'memv')                                                    value: ( next) value: (((SmallScheme globalRef:  #'cons')                                                    value: ( periodX2Dmarker) value: (((SmallScheme globalRef:  #'cons')                                                    value: ( rparenX2Dmarker) value: ( nil))))))) == false) not)                                               	ifTrue: [((SmallScheme globalRef:  #'error')                                                    value: ( 'read: ill-formed list'))]                                               	ifFalse: [ [ :final |                                                     ((((rparenX2DmarkerX3F value: ( final))) == false) not)                                                       	ifTrue: [((SmallScheme globalRef:  #'setX2DlastX2Dpair')                                                            value: (((SmallScheme globalRef:  #'reverse')                                                            value: ( result))) value: ( next))]                                                       	ifFalse: [((SmallScheme globalRef:  #'error')                                                            value: ( 'read: ill-formed dotted list tail'))].                                               ] valueWithArguments: {((read1 value: ( port))). }].                                       ] valueWithArguments: {((read1 value: ( port))). }]                                       	ifFalse: [(loop value: (((SmallScheme globalRef:  #'cons')                                            value: ( thing) value: ( result))))]]].                       ] valueWithArguments: {((read1 value: ( port))). }                   ].                   loop valueWithArguments: {                        nil. } ] value.                  ] value]).              readX2Dvector := (             [ :port |  [ :list |                       (((((SmallScheme globalRef:  #'listX3F')                              value: ( list))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'listX2DX3Evector')                              value: ( list))]                         	ifFalse: [((SmallScheme globalRef:  #'error')                              value: ( 'read: ill-formed vector'))].                 ] valueWithArguments: {((readX2Dlist value: ( port))). }]).               (read1 value: ( (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inputX2Dport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( inputX2Dport))])).           ] value] withLastArgRest  ) .! !!SmallScheme class methodsFor: 'initialization'!initString2number SmallScheme define:  #'stringX2DX3Enumber'    "string->number"  as: (         [ | numX2D2X2Dchars numX2D8X2Dchars numX2D10X2Dchars numX2D16X2Dchars exponentX2DmarkerX2Dchars radixX2Dchars exactnessX2Dchars signX2Dchars radixX2Dtable charX2DX3Eradix stringX2Dupcase toX2DssX2Dint toX2DssX2Dfloat coerceX2DifX2Dneeded makeX2Dinteger makeX2Ddecimal makeX2Drational makeX2Dcomplex prefix integer rational decimal exponent complex |                 numX2D2X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '01'))).          numX2D8X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '01234567'))).          numX2D10X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '0123456789'))).          numX2D16X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '0123456789abcdefABCDEF'))).          exponentX2DmarkerX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( 'esfdlESFDL'))).          radixX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( 'bodxBODX'))).          exactnessX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( 'ieIE'))).          signX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '+-'))).          radixX2Dtable := ( ({ (Pair car:  $b cdr:  2).  (Pair car:  $o cdr:  8).  (Pair car:  $d cdr:  10).  (Pair car:  $x cdr:  16).  (Pair car:  $B cdr:  2).  (Pair car:  $O cdr:  8).  (Pair car:  $D cdr:  10).  (Pair car:  $X cdr:  16). } asRest)).          charX2DX3Eradix := (         [ :char |  [ :result42 |                   ((( result42) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'cdr')                          value: ( result42))]                     	ifFalse: [ false].             ] valueWithArguments: {(((SmallScheme globalRef:  #'assq')                      value: ( char) value: ( radixX2Dtable))). }]).          stringX2Dupcase := (         [ :str | ((SmallScheme globalRef:  #'listX2DX3Estring')                  value: (((SmallScheme globalRef:  #'map')                  value: ( (SmallScheme globalRef:  #'charX2Dupcase')                 ) value: (((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( str))))))]).          toX2DssX2Dint := (         [ :intX2Dstr :radix | ((SmallScheme globalRef:  #'stringX2Dappend')                  value: ( [ :key43 |                   (((((SmallScheme globalRef:  #'memv')                          value: ( key43) value: ( ({ 2. } asRest)))) == false) not)                     	ifTrue: [ '2r']                     	ifFalse: [ [ :key44 |                           (((((SmallScheme globalRef:  #'memv')                                  value: ( key44) value: ( ({ 8. } asRest)))) == false) not)                             	ifTrue: [ '8r']                             	ifFalse: [ [ :key45 |                                   (((((SmallScheme globalRef:  #'memv')                                          value: ( key45) value: ( ({ 16. } asRest)))) == false) not)                                     	ifTrue: [ '16r']                                     	ifFalse: [ [                                        key45.                                        ''.                                      ] value].                             ] valueWithArguments: {( key44). }].                     ] valueWithArguments: {( key43). }].             ] valueWithArguments: {( radix). }) value: ((stringX2Dupcase value: ( intX2Dstr))))]).          toX2DssX2Dfloat := (         [ :signX2Dchar :intX2Dstr :fracX2Dstr :exptX2DsignX2Dchar :exptX2Dstr |              [ :int |                [ :frac |                  [ :sign |                    [ :exptX2Dsign |                      [ :expt |                         ((( (((((SmallScheme globalRef:  #'zeroX3F')                                    value: (((SmallScheme globalRef:  #'stringX2Dlength')                                    value: ( intX2Dstr))))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'zeroX3F')                                    value: (((SmallScheme globalRef:  #'stringX2Dlength')                                    value: ( fracX2Dstr))))]                               	ifFalse: [ false]) == false) not)                           	ifTrue: [ false]                           	ifFalse: [((SmallScheme globalRef:  #'stringX2Dappend')                                                           valueWithArguments: {  sign.  int.  '.'.  frac.  expt.})]                     ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                              value: (((SmallScheme globalRef:  #'stringX2Dlength')                              value: ( exptX2Dstr))))) == false) not)                         	ifTrue: [ '']                         	ifFalse: [((SmallScheme globalRef:  #'stringX2Dappend')                              value: ( 'e') value: ( exptX2Dsign) value: ( exptX2Dstr))])                   ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                            value: ( exptX2DsignX2Dchar) value: ( $-))) == false) not)                       	ifTrue: [ '-']                       	ifFalse: [ ''])                 ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( signX2Dchar) value: ( $-))) == false) not)                     	ifTrue: [ '-']                     	ifFalse: [ ''])               ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                        value: (((SmallScheme globalRef:  #'stringX2Dlength')                        value: ( fracX2Dstr))))) == false) not)                   	ifTrue: [ '0']                   	ifFalse: [ fracX2Dstr])             ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                      value: (((SmallScheme globalRef:  #'stringX2Dlength')                      value: ( intX2Dstr))))) == false) not)                 	ifTrue: [ '0']                 	ifFalse: [ intX2Dstr])]).          coerceX2DifX2Dneeded := (         [ :num :exactX3F :makeX2DinexactX3F |  [ :key46 |                   (((((SmallScheme globalRef:  #'memv')                          value: ( key46) value: ( ({ $e. } asRest)))) == false) not)                     	ifTrue: [ ((( exactX3F) == false) not)                         	ifTrue: [ num]                         	ifFalse: [((SmallScheme globalRef:  #'inexactX2DX3Eexact')                              value: ( num))]]                     	ifFalse: [ [ :key47 |                           (((((SmallScheme globalRef:  #'memv')                                  value: ( key47) value: ( ({ $i. } asRest)))) == false) not)                             	ifTrue: [ ((( exactX3F) == false) not)                                 	ifTrue: [((SmallScheme globalRef:  #'exactX2DX3Einexact')                                      value: ( num))]                                 	ifFalse: [ num]]                             	ifFalse: [ [                                key47.                                num.                              ] value].                     ] valueWithArguments: {( key46). }].             ] valueWithArguments: {( makeX2DinexactX3F). }]).          makeX2Dinteger := (         [ :sign :str :radix :exactX3F :makeX2DinexactX3F |  [ :num |                  (coerceX2DifX2Dneeded value: ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( sign) value: ( $-))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'X2D')                          value: ( 00) value: ( num))]                     	ifFalse: [ num]) value: ( exactX3F) value: ( makeX2DinexactX3F)).             ] valueWithArguments: {( ((toX2DssX2Dint value: ( str) value: ( radix)) asNumber)). }]).          makeX2Ddecimal := (         [ :sign :intX2Dpart :fracX2Dpart :expX2Dsign :exponentX2Dpart :exactX3F :makeX2DinexactX3F |  [ :num |                  (coerceX2DifX2Dneeded value: ( num) value: ( exactX3F) value: ( makeX2DinexactX3F)).             ] valueWithArguments: {( ((toX2DssX2Dfloat                  valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign.  exponentX2Dpart.}) asNumber)). }]).          makeX2Drational := (         [ :sign :numerator :denominator :radix :exactX3F :makeX2DinexactX3F |              [ :numX2Dpart |                [ :denomX2Dpart |                  [ :num |                    (coerceX2DifX2Dneeded value: ( num) value: ( exactX3F) value: ( makeX2DinexactX3F))                 ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( sign) value: ( $-))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'X2D')                          value: (((SmallScheme globalRef:  #'X2F')                          value: ( numX2Dpart) value: ( denomX2Dpart))))]                     	ifFalse: [((SmallScheme globalRef:  #'X2F')                          value: ( numX2Dpart) value: ( denomX2Dpart))])               ] value: ( ((toX2DssX2Dint value: ( denominator) value: ( radix)) asNumber))             ] value: ( ((toX2DssX2Dint value: ( numerator) value: ( radix)) asNumber))]).          makeX2Dcomplex := (         [ :realX2Dpart :imaginativeX2Dpart :exactX3F :makeX2DinexactX3F | (coerceX2DifX2Dneeded value: ( ( Complex real: realX2Dpart imaginary: imaginativeX2Dpart)) value: ( exactX3F) value: ( makeX2DinexactX3F))]).          prefix := (         [ :str :idx :sign :radix :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: (((SmallScheme globalRef:  #'stringX2Dlength')                      value: ( str))))) == false) not)                 	ifTrue: [ false]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: ( char) value: ( numX2D16X2Dchars))) == false) not)                         	ifTrue: [ [ :key48 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key48) value: ( ({ 10. } asRest)))) == false) not)                                 	ifTrue: [(integer                                  valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                      value: ( str)).  numX2D10X2Dchars.  sign.  10.  nil.  true.  makeX2DinexactX3F.})]                                 	ifFalse: [ [ :key49 |                                       (((((SmallScheme globalRef:  #'memv')                                              value: ( key49) value: ( ({ 2. } asRest)))) == false) not)                                         	ifTrue: [(integer                                          valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                              value: ( str)).  numX2D2X2Dchars.  sign.  2.  nil.  true.  makeX2DinexactX3F.})]                                         	ifFalse: [ [ :key50 |                                               (((((SmallScheme globalRef:  #'memv')                                                      value: ( key50) value: ( ({ 8. } asRest)))) == false) not)                                                 	ifTrue: [(integer                                                  valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                                      value: ( str)).  numX2D8X2Dchars.  sign.  8.  nil.  true.  makeX2DinexactX3F.})]                                                 	ifFalse: [ [ :key51 |                                                       (((((SmallScheme globalRef:  #'memv')                                                              value: ( key51) value: ( ({ 16. } asRest)))) == false) not)                                                         	ifTrue: [(integer                                                          valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                                              value: ( str)).  numX2D16X2Dchars.  sign.  16.  nil.  true.  makeX2DinexactX3F.})]                                                         	ifFalse: [ [                                                            key51.                                                            false.                                                          ] value].                                                 ] valueWithArguments: {( key50). }].                                         ] valueWithArguments: {( key49). }].                                 ] valueWithArguments: {( key48). }].                         ] valueWithArguments: {( radix). }]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( char) value: ( $.))) == false) not)                             	ifTrue: [(decimal                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                  value: ( 1) value: ( idx)). ((SmallScheme globalRef:  #'stringX2Dlength')                                  value: ( str)).  $+.  '0'.  nil.  true.  makeX2DinexactX3F.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                      value: ( char) value: ( signX2Dchars))) == false) not)                                 	ifTrue: [(prefix                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( 1) value: ( idx)).  char.  radix.  makeX2DinexactX3F.})]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: ( char) value: ( $#))) == false) not)                                     	ifTrue: [ [ :char2 |                                           (((((SmallScheme globalRef:  #'memv')                                                  value: ( char2) value: ( radixX2Dchars))) == false) not)                                             	ifTrue: [(prefix                                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                  value: ( 2) value: ( idx)).  sign. (charX2DX3Eradix value: ( char2)).  makeX2DinexactX3F.})]                                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                      value: ( char2) value: ( exactnessX2Dchars))) == false) not)                                                 	ifTrue: [(prefix                                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                      value: ( 2) value: ( idx)).  sign.  radix.  char2.})]                                                 	ifFalse: [ false]].                                     ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                                              value: ( str) value: (((SmallScheme globalRef:  #'X2B')                                              value: ( 1) value: ( idx))))). }]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                              value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                              value: ( char))) value: ( $i))) == false) not)                                         	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                  value: (((SmallScheme globalRef:  #'X2B')                                                  value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                  value: ( str))))) == false) not)                                             	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                      value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                      value: ( str))))) == false) not)                                                 	ifTrue: [ false]                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                          value: ( sign))) == false) not)                                                     	ifTrue: [ false]                                                     	ifFalse: [(makeX2Dcomplex                                                      valueWithArguments: {  00.  00.  (SmallScheme globalRef:  #'exactX3F')                                                         .  makeX2DinexactX3F.})]]]                                             	ifFalse: [ false]]                                         	ifFalse: [ false]]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          integer := (         [ :str :idx :len :legalX2Dchars :sign :radix :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [(makeX2Dinteger                  valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                      value: (((SmallScheme globalRef:  #'reverse')                      value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.})]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: (((SmallScheme globalRef:  #'stringX2Dref')                              value: ( str) value: ( idx))) value: ( legalX2Dchars))) == false) not)                         	ifTrue: [(integer                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( char) value: ( $#))) == false) not)                             	ifTrue: [(integer                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                  value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'cons')                                  value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( char) value: ( $.))) == false) not)                                 	ifTrue: [ ((( ((( radix) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'X3D')                                              value: ( radix) value: ( 10))]                                         	ifFalse: [ false]) == false) not)                                     	ifTrue: [(decimal                                      valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                          value: ( 1) value: ( idx)).  len.  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( digits)))).  nil.  exactX3F.  makeX2DinexactX3F.})]                                     	ifFalse: [ false]]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: ( char) value: ( $/))) == false) not)                                     	ifTrue: [(rational                                      valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                          value: ( 1) value: ( idx)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( digits)))).  nil.  exactX3F.  makeX2DinexactX3F.})]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                              value: ( char) value: ( signX2Dchars))) == false) not)                                         	ifTrue: [ (((((SmallScheme globalRef:  #'nullX3F')                                                  value: ( digits))) == false) not)                                             	ifTrue: [(complex                                              valueWithArguments: {  00.  str.  idx.  radix.})]                                             	ifFalse: [(complex                                              valueWithArguments: { (makeX2Dinteger                                              valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                  value: (((SmallScheme globalRef:  #'reverse')                                                  value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  radix.})]]                                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                                  value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                                  value: ( char))) value: ( $i))) == false) not)                                             	ifTrue: [ (((((SmallScheme globalRef:  #'not')                                                      value: (((SmallScheme globalRef:  #'X3D')                                                      value: (((SmallScheme globalRef:  #'X2B')                                                      value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                      value: ( str))))))) == false) not)                                                 	ifTrue: [ false]                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                                          value: ( digits))) == false) not)                                                     	ifTrue: [(makeX2Dcomplex                                                      valueWithArguments: {  00.  00.  exactX3F.  makeX2DinexactX3F.})]                                                     	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                              value: ( sign))) == false) not)                                                         	ifTrue: [ false]                                                         	ifFalse: [(makeX2Dcomplex                                                          valueWithArguments: {  00. (makeX2Dinteger                                                          valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                              value: (((SmallScheme globalRef:  #'reverse')                                                              value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]]]                                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                      value: ( char) value: ( exponentX2DmarkerX2Dchars))) == false) not)                                                 	ifTrue: [ ((( ((( radix) == false) not)                                                         	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                                  value: ( radix) value: ( 10))) == false) not)                                                             	ifTrue: [((SmallScheme globalRef:  #'X3E')                                                                  value: (((SmallScheme globalRef:  #'length')                                                                  value: ( digits))) value: ( 00))]                                                             	ifFalse: [ false]]                                                         	ifFalse: [ false]) == false) not)                                                     	ifTrue: [(exponent                                                      valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                          value: ( 1) value: ( idx)).  len.  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                          value: (((SmallScheme globalRef:  #'reverse')                                                          value: ( digits)))).  '0'.  nil.  $+.  exactX3F.  makeX2DinexactX3F.})]                                                     	ifFalse: [ false]]                                                 	ifFalse: [ false]]]]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          rational := (         [ :str :idx :len :legalX2Dchars :sign :radix :numerator :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [(makeX2Drational                  valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                      value: (((SmallScheme globalRef:  #'reverse')                      value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.})]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: (((SmallScheme globalRef:  #'stringX2Dref')                              value: ( str) value: ( idx))) value: ( legalX2Dchars))) == false) not)                         	ifTrue: [(rational                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix.  numerator. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                  value: ( char) value: ( signX2Dchars))) == false) not)                             	ifTrue: [(complex                              valueWithArguments: { (makeX2Drational                              valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                                  value: (((SmallScheme globalRef:  #'reverse')                                  value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  radix.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( char) value: ( $#))) == false) not)                                 	ifTrue: [(rational                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix.  numerator. ((SmallScheme globalRef:  #'cons')                                      value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                          value: ( char))) value: ( $i))) == false) not)                                     	ifTrue: [ (((((SmallScheme globalRef:  #'not')                                              value: (((SmallScheme globalRef:  #'X3D')                                              value: (((SmallScheme globalRef:  #'X2B')                                              value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                              value: ( str))))))) == false) not)                                         	ifTrue: [ false]                                         	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                                  value: ( digits))) == false) not)                                             	ifTrue: [ false]                                             	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                      value: ( sign))) == false) not)                                                 	ifTrue: [ false]                                                 	ifFalse: [(makeX2Dcomplex                                                  valueWithArguments: {  00. (makeX2Drational                                                  valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                      value: (((SmallScheme globalRef:  #'reverse')                                                      value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]]]                                     	ifFalse: [ false]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          decimal := (         [ :str :idx :len :sign :intX2Dpart :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                          value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                          value: ( str))))) == false) not)                     	ifTrue: [ false]                     	ifFalse: [(makeX2Ddecimal                      valueWithArguments: {  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                          value: (((SmallScheme globalRef:  #'reverse')                          value: ( digits)))).  $+.  '0'.  exactX3F.  makeX2DinexactX3F.})]]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: (((SmallScheme globalRef:  #'stringX2Dref')                              value: ( str) value: ( idx))) value: ( numX2D10X2Dchars))) == false) not)                         	ifTrue: [(decimal                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( char) value: ( $#))) == false) not)                             	ifTrue: [(decimal                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                  value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'cons')                                  value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                      value: ( char) value: ( exponentX2DmarkerX2Dchars))) == false) not)                                 	ifTrue: [(exponent                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( 1) value: ( idx)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                                      value: (((SmallScheme globalRef:  #'reverse')                                      value: ( digits)))).  nil.  $+.  exactX3F.  makeX2DinexactX3F.})]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                          value: ( char))) value: ( $i))) == false) not)                                     	ifTrue: [ ((( ((( sign) == false) not)                                             	ifTrue: [((SmallScheme globalRef:  #'X3D')                                                  value: (((SmallScheme globalRef:  #'X2B')                                                  value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                  value: ( str))))]                                             	ifFalse: [ false]) == false) not)                                         	ifTrue: [(makeX2Dcomplex                                          valueWithArguments: {  00. (makeX2Ddecimal                                          valueWithArguments: {  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                                              value: (((SmallScheme globalRef:  #'reverse')                                              value: ( digits)))).  $+.  '0'.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]                                         	ifFalse: [ false]]                                     	ifFalse: [ false]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          exponent := (         [ :str :idx :len :sign :intX2Dpart :fracX2Dpart :digits :expX2Dsign :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [(makeX2Ddecimal                  valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                      value: (((SmallScheme globalRef:  #'reverse')                      value: ( digits)))).  exactX3F.  makeX2DinexactX3F.})]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: ( char) value: ( numX2D10X2Dchars))) == false) not)                         	ifTrue: [(exponent                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart.  fracX2Dpart. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  expX2Dsign.  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                  value: ( char) value: ( signX2Dchars))) == false) not)                             	ifTrue: [ (((((SmallScheme globalRef:  #'nullX3F')                                      value: ( digits))) == false) not)                                 	ifTrue: [(exponent                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart.  fracX2Dpart.  digits.  char.  exactX3F.  makeX2DinexactX3F.})]                                 	ifFalse: [(complex                                  valueWithArguments: { (makeX2Ddecimal                                  valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                      value: (((SmallScheme globalRef:  #'reverse')                                      value: ( digits)))).  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  (SmallScheme globalRef:  #'radix')                                     .})]]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                      value: ( char))) value: ( $i))) == false) not)                                 	ifTrue: [ ((( [ :temp52 |                                           ((( temp52) == false) not)                                             	ifTrue: [ temp52]                                             	ifFalse: [ [ :temp53 |                                                   ((( temp53) == false) not)                                                     	ifTrue: [ temp53]                                                     	ifFalse: [((SmallScheme globalRef:  #'not')                                                          value: (((SmallScheme globalRef:  #'X3D')                                                          value: (((SmallScheme globalRef:  #'X2B')                                                          value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                          value: ( str))))))].                                             ] valueWithArguments: {(((SmallScheme globalRef:  #'not')                                                      value: ( sign))). }].                                     ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                                              value: ( digits))). }) == false) not)                                     	ifTrue: [ false]                                     	ifFalse: [(makeX2Dcomplex                                      valueWithArguments: {  00. (makeX2Ddecimal                                      valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( digits)))).  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]                                 	ifFalse: [ false]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          complex := (         [ :realX2Dpart :str :idx :radix |  [ :imaginitiveX2Dpart |                   ((( imaginitiveX2Dpart) == false) not)                     	ifTrue: [ ( realX2Dpart + imaginitiveX2Dpart)]                     	ifFalse: [ false].             ] valueWithArguments: {((prefix                  valueWithArguments: {  str.  idx.  $+.  radix.  false.})). }]).                      [ :str :radix |                radix := radix asRest.                [                  (((((SmallScheme globalRef:  #'not')                          value: (((SmallScheme globalRef:  #'stringX3F')                          value: ( str))))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'error')                          value: ( 'Expected a string') value: ( str))].                  (((((SmallScheme globalRef:  #'X3C')                          value: (((SmallScheme globalRef:  #'stringX2Dlength')                          value: ( str))) value: ( 1))) == false) not)                     	ifTrue: [ false]                     	ifFalse: [(prefix                      valueWithArguments: {  str.  00.  false.  (((((SmallScheme globalRef:  #'nullX3F')                              value: ( radix))) == false) not)                         	ifTrue: [ 10]                         	ifFalse: [((SmallScheme globalRef:  #'car')                              value: ( radix))].  false.})].                ] value] withLastArgRest .       ] value ) .! !!SmallScheme class methodsFor: 'initialization'!initStrings SmallScheme define:  #'string'  as: (        [ :rest |            rest := rest asRest.            (((((SmallScheme globalRef:  #'nullX3F')                    value: ( rest))) == false) not)               	ifTrue: [ '']               	ifFalse: [((SmallScheme globalRef:  #'listX2DX3Estring')                    value: ( rest))]] withLastArgRest  ) . SmallScheme define:  #'stringX3F'    "string?"  as: (        [ :obj |  ((( ( obj isKindOf: String)) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'not')                    value: ( ( obj isKindOf: Symbol)))]               	ifFalse: [ false]] ) . SmallScheme define:  #'makeX2Dstring'    "make-string"  as: (        [ :k :optionalX2Dchar |            optionalX2Dchar := optionalX2Dchar asRest.            [ :fill |                 ( String new: k withAll: fill).           ] valueWithArguments: {( (((((SmallScheme globalRef:  #'nullX3F')                        value: ( optionalX2Dchar))) == false) not)                   	ifTrue: [ $ ]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dchar))]). }] withLastArgRest  ) . SmallScheme define:  #'stringX2Dlength'    "string-length"  as: (        [ :str |  ( str size)] ) . SmallScheme define:  #'stringX2Dref'    "string-ref"  as: (        [ :str :k |  ( str at:((SmallScheme globalRef:  #'X2B')                value: ( 1) value: ( k)))] ) . SmallScheme define:  #'stringX2DsetX21'    "string-set!!"  as: (        [ :str :k :char |  ( str at:((SmallScheme globalRef:  #'X2B')                value: ( 1) value: ( k)) put: char)] ) . SmallScheme define:  #'stringX3DX3F'    "string=?"  as: (        [ :s1 :s2 |  ( s1 = s2)] ) . SmallScheme define:  #'stringX3CX3F'    "string<?"  as: (        [ :s1 :s2 |  ( s1 < s2)] ) . SmallScheme define:  #'stringX3EX3F'    "string>?"  as: (        [ :s1 :s2 |  ( s1 > s2)] ) . SmallScheme define:  #'stringX3EX3DX3F'    "string>=?"  as: (        [ :s1 :s2 |  ( s1 >= s2)] ) . SmallScheme define:  #'stringX3CX3DX3F'    "string<=?"  as: (        [ :s1 :s2 |  ( s1 <= s2)] ) . SmallScheme define:  #'stringX2DciX3DX3F'    "string-ci=?"  as: (        [ :s1 :s2 |  ( ( s1 asLowercase) = ( s2 asLowercase))] ) . SmallScheme define:  #'stringX2DciX3CX3F'    "string-ci<?"  as: (        [ :s1 :s2 |  ( ( s1 asLowercase) < ( s2 asLowercase))] ) . SmallScheme define:  #'stringX2DciX3EX3F'    "string-ci>?"  as: (        [ :s1 :s2 |  ( ( s1 asLowercase) > ( s2 asLowercase))] ) . SmallScheme define:  #'stringX2DciX3CX3DX3F'    "string-ci<=?"  as: (        [ :s1 :s2 |  ( ( s1 asLowercase) <= ( s2 asLowercase))] ) . SmallScheme define:  #'stringX2DciX3EX3DX3F'    "string-ci>=?"  as: (        [ :s1 :s2 |  ( ( s1 asLowercase) >= ( s2 asLowercase))] ) . SmallScheme define:  #'substring'  as: (        [ :str :start :end |  ((( (((((SmallScheme globalRef:  #'X3CX3D')                        value: ( 00) value: ( start))) == false) not)                   	ifTrue: [ (((((SmallScheme globalRef:  #'X3CX3D')                            value: ( start) value: ( end))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'X3CX3D')                            value: ( end) value: (((SmallScheme globalRef:  #'stringX2Dlength')                            value: ( str))))]                       	ifFalse: [ false]]                   	ifFalse: [ false]) == false) not)               	ifTrue: [ ( str copyFrom:((SmallScheme globalRef:  #'X2B')                    value: ( start) value: ( 1)) to: end)]               	ifFalse: [((SmallScheme globalRef:  #'error')                    value: ( 'substring: indexing error'))]] ) . SmallScheme define:  #'stringX2Dappend'    "string-append"  as: (        [ :strings |            strings := strings asRest.            (((((SmallScheme globalRef:  #'nullX3F')                    value: ( strings))) == false) not)               	ifTrue: [ '']               	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                        value: (((SmallScheme globalRef:  #'cdr')                        value: ( strings))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'car')                        value: ( strings))]                   	ifFalse: [((SmallScheme globalRef:  #'reduce')                        value: (                   [ :s1 :s2 |  ( s1 , s2)]) value: (((SmallScheme globalRef:  #'car')                        value: ( strings))) value: (((SmallScheme globalRef:  #'cdr')                        value: ( strings))))]]] withLastArgRest  ) . SmallScheme define:  #'stringX2DX3Elist'    "string->list"  as: (        [ :str |  ( ( str collectArray:           [ :c |  c]) asRest)] ) . SmallScheme define:  #'listX2DX3Estring'    "list->string"  as: (        [ :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ '']               	ifFalse: [ [ :str |                     [                      ( list collect:                     [ :char |  ( str := str , char asString)]).                      str.                    ] value.               ] valueWithArguments: {( ( '')). }]] ) . SmallScheme define:  #'stringX2Dcopy'    "string-copy"  as: (        [ :str |  ( str copy)] ) . SmallScheme define:  #'stringX2DfillX21'    "string-fill!!"  as: (        [ :str :char |             [ | loop |                loop :=                [ :idx |                 (((((SmallScheme globalRef:  #'X3C')                        value: ( idx) value: ( 00))) == false) not)                   	ifTrue: [ str]                   	ifFalse: [ [                     ((SmallScheme globalRef:  #'stringX2DsetX21')                          value: ( str) value: ( idx) value: ( char)).                     (loop value: (((SmallScheme globalRef:  #'X2D')                          value: ( idx) value: ( 1)))).                    ] value]           ].           loop valueWithArguments: {               ((SmallScheme globalRef:  #'X2D')                    value: (((SmallScheme globalRef:  #'stringX2Dlength')                    value: ( str))) value: ( 1)). } ] value] ) .! !!SmallScheme class methodsFor: 'initialization'!initSymbols SmallScheme define:  #'symbolX3F'    "symbol?"  as: (        [ :obj |  ( obj isKindOf: Symbol)] ) . SmallScheme define:  #'symbolX2DX3Estring'    "symbol->string"  as: (        [ :symbol |  ( symbol asSchemeString)] ) . SmallScheme define:  #'stringX2DX3Esymbol'    "string->symbol"  as: (        [ :string |  ( ( string fromSchemeIdentifier) asSymbol)] ) . SmallScheme define:  #'gensym'  as: (  [ :counter |                       [ :optionalX2DstrX2DorX2Dsym |                optionalX2DstrX2DorX2Dsym := optionalX2DstrX2DorX2Dsym asRest.                [ :stringX2DorX2Dsymbol |                     [                     (counter := ((SmallScheme globalRef:  #'X2B')                          value: ( counter) value: ( 1))).                     ((SmallScheme globalRef:  #'stringX2DX3Esymbol')                          value: (((SmallScheme globalRef:  #'stringX2Dappend')                          value: ( (((((SmallScheme globalRef:  #'symbolX3F')                              value: ( stringX2DorX2Dsymbol))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'symbolX2DX3Estring')                              value: ( stringX2DorX2Dsymbol))]                         	ifFalse: [ stringX2DorX2Dsymbol]) value: (((SmallScheme globalRef:  #'numberX2DX3Estring')                          value: ( counter)))))).                    ] value.               ] valueWithArguments: {( (((((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2DstrX2DorX2Dsym))) == false) not)                       	ifTrue: [ 'g']                       	ifFalse: [((SmallScheme globalRef:  #'car')                            value: ( optionalX2DstrX2DorX2Dsym))]). }] withLastArgRest .       ] valueWithArguments: {( 00). } ) .! !!SmallScheme class methodsFor: 'initialization'!initTranscript SmallScheme define:  #'transcriptX3Aport'    "transcript:port"  as: (  ( Transcript) ) . SmallScheme define:  #'transcriptX2Don'    "transcript-on"  as: (        [ :filename | (SmallScheme setX21:  #'transcriptX3Aport' as: ((SmallScheme globalRef:  #'openX2DoutputX2Dfile')                value: ( filename)))] ) . SmallScheme define:  #'transcriptX2Doff'    "transcript-off"  as: (        [ [              (((((SmallScheme globalRef:  #'outputX2DportX3F')                      value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                     ))) == false) not)                 	ifTrue: [((SmallScheme globalRef:  #'closeX2DoutputX2Dport')                      value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                     ))].             (SmallScheme setX21:  #'transcriptX3Aport' as:  ( Transcript)).            ] value] ) . SmallScheme define:  #'readX2Dchar'    "read-char"  as: (  [ :readX2Dchar :writeX2Dchar |                       [ :opt |                opt := opt asRest.                [ :ans |                     [                      [ :temp54 |                           ((( temp54) == false) not)                             	ifTrue: [ temp54]                             	ifFalse: [ (((((SmallScheme globalRef:  #'outputX2DportX3F')                                      value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                                     ))) == false) not)                                 	ifTrue: [(writeX2Dchar value: ( ans) value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                                     ))]                                 	ifFalse: [ 'Unspecified']].                     ] valueWithArguments: {(((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( ans))). }.                      ans.                    ] value.               ] valueWithArguments: {(((SmallScheme globalRef:  #'apply')                        value: ( readX2Dchar) value: ( opt))). }] withLastArgRest .       ] valueWithArguments: {( (SmallScheme globalRef:  #'readX2Dchar')               ). ( (SmallScheme globalRef:  #'writeX2Dchar')               ). } ) . SmallScheme define:  #'read'  as: (  [ :read :write :newline |                       [ :opt |                opt := opt asRest.                [ :ans |                     [                      [ :temp55 |                           ((( temp55) == false) not)                             	ifTrue: [ temp55]                             	ifFalse: [ (((((SmallScheme globalRef:  #'outputX2DportX3F')                                      value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                                     ))) == false) not)                                 	ifTrue: [ [                                   (write value: ( ans) value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                                       )).                                    (((((SmallScheme globalRef:  #'eqvX3F')                                            value: ((Character cr)) value: (((SmallScheme globalRef:  #'apply')                                            value: ( (SmallScheme globalRef:  #'peekX2Dchar')                                           ) value: ( opt))))) == false) not)                                       	ifTrue: [(newline value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                                           ))].                                  ] value]                                 	ifFalse: [ 'Unspecified']].                     ] valueWithArguments: {(((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( ans))). }.                      ans.                    ] value.               ] valueWithArguments: {(((SmallScheme globalRef:  #'apply')                        value: ( read) value: ( opt))). }] withLastArgRest .       ] valueWithArguments: {( (SmallScheme globalRef:  #'read')               ). ( (SmallScheme globalRef:  #'write')               ). ( (SmallScheme globalRef:  #'newline')               ). } ) . SmallScheme define:  #'writeX2Dchar'    "write-char"  as: (  [ :writeX2Dchar |                       [ :obj :opt |                opt := opt asRest.                [                 ((SmallScheme globalRef:  #'apply')                      value: ( writeX2Dchar) value: ( obj) value: ( opt)).                  (((((SmallScheme globalRef:  #'outputX2DportX3F')                          value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))) == false) not)                     	ifTrue: [(writeX2Dchar value: ( obj) value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))].                ] value] withLastArgRest .       ] valueWithArguments: {( (SmallScheme globalRef:  #'writeX2Dchar')               ). } ) . SmallScheme define:  #'write'  as: (  [ :write |                       [ :obj :opt |                opt := opt asRest.                [                 ((SmallScheme globalRef:  #'apply')                      value: ( write) value: ( obj) value: ( opt)).                  (((((SmallScheme globalRef:  #'outputX2DportX3F')                          value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))) == false) not)                     	ifTrue: [(write value: ( obj) value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))].                ] value] withLastArgRest .       ] valueWithArguments: {( (SmallScheme globalRef:  #'write')               ). } ) . SmallScheme define:  #'display'  as: (  [ :display |                       [ :obj :opt |                opt := opt asRest.                [                 ((SmallScheme globalRef:  #'apply')                      value: ( display) value: ( obj) value: ( opt)).                  (((((SmallScheme globalRef:  #'outputX2DportX3F')                          value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))) == false) not)                     	ifTrue: [(display value: ( obj) value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))].                ] value] withLastArgRest .       ] valueWithArguments: {( (SmallScheme globalRef:  #'display')               ). } ) . SmallScheme define:  #'newline'  as: (  [ :newline |                       [ :opt |                opt := opt asRest.                [                 ((SmallScheme globalRef:  #'apply')                      value: ( newline) value: ( opt)).                  (((((SmallScheme globalRef:  #'outputX2DportX3F')                          value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))) == false) not)                     	ifTrue: [(newline value: ( (SmallScheme globalRef:  #'transcriptX3Aport')                         ))].                ] value] withLastArgRest .       ] valueWithArguments: {( (SmallScheme globalRef:  #'newline')               ). } ) .! !!SmallScheme class methodsFor: 'initialization'!initVectors SmallScheme define:  #'vectorX3F'    "vector?"  as: (        [ :obj |  ( obj isKindOf: Array)] ) . SmallScheme define:  #'makeX2Dvector'    "make-vector"  as: (        [ :k :optionalX2Dobj |            optionalX2Dobj := optionalX2Dobj asRest.            [ :fill |                 ( Array new: k withAll: fill).           ] valueWithArguments: {( (((((SmallScheme globalRef:  #'nullX3F')                        value: ( optionalX2Dobj))) == false) not)                   	ifTrue: [ (SmallScheme globalRef:  #'nil')                       ]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dobj))]). }] withLastArgRest  ) . SmallScheme define:  #'vector'  as: (        [ :list |            list := list asRest.           ((SmallScheme globalRef:  #'listX2DX3Evector')                value: ( list))] withLastArgRest  ) . SmallScheme define:  #'vectorX2Dlength'    "vector-length"  as: (        [ :vec |  ( vec size)] ) . SmallScheme define:  #'vectorX2Dref'    "vector-ref"  as: (        [ :vec :k |  ( vec at:((SmallScheme globalRef:  #'X2B')                value: ( 1) value: ( k)))] ) . SmallScheme define:  #'vectorX2DsetX21'    "vector-set!!"  as: (        [ :vec :k :obj |  ( vec at:((SmallScheme globalRef:  #'X2B')                value: ( 1) value: ( k)) put: obj)] ) . SmallScheme define:  #'vectorX2DX3Elist'    "vector->list"  as: (        [ :vec |  ( vec asRest)] ) . SmallScheme define:  #'listX2DX3Evector'    "list->vector"  as: (        [ :list |  ( list asArray)] ) . SmallScheme define:  #'vectorX2DfillX21'    "vector-fill!!"  as: (        [ :vec :obj |             [ | loop |                loop :=                [ :idx |                 (((((SmallScheme globalRef:  #'X3C')                        value: ( idx) value: ( 00))) == false) not)                   	ifTrue: [ vec]                   	ifFalse: [ [                     ((SmallScheme globalRef:  #'vectorX2DsetX21')                          value: ( vec) value: ( idx) value: ( obj)).                     (loop value: (((SmallScheme globalRef:  #'X2D')                          value: ( idx) value: ( 1)))).                    ] value]           ].           loop valueWithArguments: {               ((SmallScheme globalRef:  #'X2D')                    value: (((SmallScheme globalRef:  #'vectorX2Dlength')                    value: ( vec))) value: ( 1)). } ] value] ) .! !!SmallScheme class methodsFor: 'documentation' stamp: 'KenD 6/8/2002 19:27'!copyright^'SmallScheme COPYRIGHT (c) 2001, 2002 by Kenneth A Dickey This software may be used for any purpose but without warrenty or liability of any kind.'! !!SmallScheme class methodsFor: 'documentation' stamp: 'KenD 6/18/2002 13:49'!history^'KenD 5/10/2002 11:06 -- Pairs/lists implemented and working.KenD 5/13/2002 17:37 -- Complex numbers working.KenD 6/8/2002 19:21  -- Passes most of R4RS Test Suite.KenD 6/13/2002 12:20 -- Successful bootstrap!! (translates self).KenD 6/18/2002 13:49 -- Eval working.'! !!SmallScheme class methodsFor: 'documentation' stamp: 'KenD 6/8/2002 19:27'!status^'Incomplete Prototype; not fully tested'! !!SmallScheme class methodsFor: 'documentation' stamp: 'KenD 6/8/2002 19:27'!whyMe^'SmallScheme is a R5^RS Scheme less call-with-current-continuation.It`s purpose is to have fun!!  It is free to use for any purpose (see SchemeDocs copyright).I can`t promise support, but am interested. <mailto:kend0@earthlink.net>I hope you enjoy it!!-Ken Dickey (KenD)'! !!Stack methodsFor: 'private' stamp: 'KenD 5/14/2002 10:47'!grow	"Expand self"	| originalValues index |	originalValues := self valuesArray: (Array ofSize: (2 * (valuesArray size))).	index := 1.	originalValues do: [ :elt | valuesArray at: index put: elt. index := index + 1.].	^self! !!Stack methodsFor: 'private' stamp: 'KenD 5/14/2002 11:22'!initialize	self top: 0.	self valuesArray: (Array ofSize: 6).	^self! !!Stack methodsFor: 'private' stamp: 'KenD 5/14/2002 10:38'!top	^top! !!Stack methodsFor: 'private' stamp: 'KenD 5/14/2002 10:39'!top: newVal	| oldVal |	oldVal := top.	top := newVal.	^oldVal! !!Stack methodsFor: 'private' stamp: 'KenD 5/14/2002 10:40'!valuesArray	^valuesArray! !!Stack methodsFor: 'private' stamp: 'KenD 5/14/2002 10:40'!valuesArray: newArray	| oldArray |	oldArray := valuesArray.	valuesArray := newArray.	^oldArray! !!Stack methodsFor: 'testing' stamp: 'KenD 5/14/2002 10:52'!isEmpty	^(top = 0)! !!Stack methodsFor: 'printing' stamp: 'KenD 5/14/2002 11:10'!printOn: aStream	aStream nextPut: $(.	1 to: top do: [ :index | 				 aStream print: (valuesArray at: index); space].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !!Stack methodsFor: 'access' stamp: 'KenD 5/15/2002 12:31'!pop	| value |	top > 0		ifTrue: [value _ valuesArray at: top.			valuesArray at: top put: nil.  "allow GC"			top _ top - 1.			^ value]		ifFalse: [Exception signal: 'Attempt to pop from empty Stack']!]style[(3 3 6 4 3 3 1 12 5 3 11 5 3 5 11 5 3 6 3 3 10 4 3 3 3 3 1 7 5 14 9 9 33 1)f1b,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1c146044000,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1! !!Stack methodsFor: 'access' stamp: 'KenD 5/14/2002 11:23'!push: aVal	(top = valuesArray size)		ifTrue: [self grow].	top := top + 1.	valuesArray at: top put: aVal.	^self! !!Stack methodsFor: 'access' stamp: 'KenD 5/14/2002 10:49'!size	^top! !!Stack methodsFor: 'access' stamp: 'KenD 5/14/2002 11:23'!topValue	"return value at top of stack (NB: does NOT pop!!)"	(top < 1)	ifTrue: [Exception signal: 'Attempt to pop from empty Stack'.]	ifFalse: [^valuesArray at: top].! !!Stack methodsFor: 'access' stamp: 'KenD 5/14/2002 11:23'!topValue: newVal	"set top value to newVal"	(self isEmpty)	ifFalse: [valuesArray at: top put: newVal] "set!!"	ifTrue: [Exception signal: 'Attempt to assign to empty Stack'].! !!Stack class methodsFor: 'as yet unclassified' stamp: 'KenD 5/14/2002 11:10'!with: anObject 	"Returns a new Stack with anObject."	^ self new initialize;		push: anObject;		yourself! !!Stream methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:39'!asSchemeString	^ '#<port>'! !!ReadStream methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:41'!asSchemeString	^ '#<input-port>'! !!String methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 09:41'!asPair	"Don't convert strings into lists of characters 	Collection base case:	  Want #(#a #b #c) asPair -> (a b c) NOT ((a)(b)(c))"	^self! !!String methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:50'!asSchemeObjString	| result | 	result := '"'.	self do: [:c |		  "slashify"		  ((c == $\) | (c == $"))		  ifTrue: [result := (result , '\')].		  result := (result , c asString).      ].	^(result , '"')! !!String methodsFor: 'SchemeCore' stamp: 'KenD 5/22/2002 08:23'!fromSchemeIdentifier	"scheme->smallscript"	| result |	result _ ''.	self		do: [:c | "byteStuff $X"			c == $X				ifTrue: [result _ result , c asString , c asString]				ifFalse: [(('!!$%&*+-./:<=>?@^_~'						detect: [:char | char = c]						ifNone: [false]) = false)						ifFalse: [result _ result , 'X' , c hex]						ifTrue: [result _ result , c asString]]].	^ result! !!String methodsFor: 'SchemeCore' stamp: 'KenD 6/12/2002 10:46'!toSchemeIdentifier	"smallscript->scheme"	| result len index c c2 c3 |	result _ String new.	len _ self size.	index _ 1.	"if char is $X and next char !!= $X 	then next 2 chars should make a hex number"	[index <= len]		whileTrue: [			c _ self at: index.			index _ index + 1.			(c = $X) & ((index + 1 > len) not)			ifTrue: [				c2 _ self at: index.				c3 _ self at: index + 1.				(c2 = $X) "XX"				ifTrue: [					index := index + 1.					result _ result , (c asString).				]				ifFalse: [					(c2 isHexChar & c3 isHexChar)						ifTrue: [ "@@ FIXME: make it fast @@"							index _ index + 2.							result _ result , ('16r' , (c2 asString) , (c3 asString)) asNumber asCharacter asString						]						ifFalse: [result _ result , (c asString)].				]			]			ifFalse: [result _ result , (c asString)].		].	^ result! !!Symbol methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 12:12'!asSchemeObjString	^ ((self asString) toSchemeIdentifier)! !!Symbol methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 12:07'!asSchemeString	^ ((self asString) toSchemeIdentifier)! !!Symbol methodsFor: 'SchemeCore' stamp: 'KenD 5/24/2002 11:00'!fromSchemeIdentifier	"scheme->smallscript"	^((self asString) fromSchemeIdentifier) asSymbol.! !!Symbol methodsFor: 'SchemeCore' stamp: 'KenD 5/22/2002 08:25'!toSchemeIdentifier	"smallscript->scheme"	^((self asString) toSchemeIdentifier) asSymbol.! !!SystemDictionary methodsFor: 'special objects' stamp: 'ajh 2/14/2002 02:40'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray |	newArray _ Array new: 49.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext2.	newArray at: 12 put: BlockClosure.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod2.	newArray at: 18 put: (Smalltalk specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:from:.	newArray at: 23 put: nil.  "the input semaphore"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process2.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: (Smalltalk compactClassesArray copy at: 4 put: CallStack; yourself).		"We don't just add CallStack to the current image because the current VM assumes classes at compact index 4 are contexts (PseudoContext)"	newArray at: 30 put: (Smalltalk specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (Smalltalk specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	newArray at: 36 put: #couldNotReturn:from:.	newArray at: 37 put: CallStack.	newArray at: 38 put: SharedTemp.	newArray at: 39 put: Array new.  "array of objects referred to by external code"	"newArray at: 40 put: PseudoContext."	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray at: 42 put: ((Smalltalk specialObjectsArray at: 42) ifNil:[Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (Smalltalk at: #ExternalAddress ifAbsent:[nil]).	newArray at: 45 put: (Smalltalk at: #ExternalStructure ifAbsent:[nil]).	newArray at: 46 put: (Smalltalk at: #ExternalData ifAbsent:[nil]).	newArray at: 47 put: (Smalltalk at: #ExternalFunction ifAbsent:[nil]).	newArray at: 48 put: (Smalltalk at: #ExternalLibrary ifAbsent:[nil]).	newArray at: 49 put: #executeThenReturn:from:.  "was #aboutToReturn:through:"	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!True methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:25'!asSchemeString	^ '#t'! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 5/31/2002 14:14'!asArray	"base case"	^{}! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:56'!asPair	"base case"	^self! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:52'!asSchemeString	^'()'! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:50'!isEmptyList	"for SchemeCore>Pair"	^true! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:51'!isPair	^false! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 5/9/2002 19:51'!length	^0! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 07:18'!reverse	"base case for Pair list REVERSE"	^self! !!UndefinedObject methodsFor: 'SchemeCore' stamp: 'KenD 6/5/2002 08:17'!size	^0! !!WriteStream methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:42'!asSchemeString	^ '#<output-port>'! !!ReadWriteStream methodsFor: 'SchemeCore' stamp: 'KenD 5/10/2002 11:41'!asSchemeString	^ '#<input-output-port>'! !SmallScheme class removeSelector: #initEval!SmallScheme initialize!SmallScheme removeSelector: #copyright!SmallScheme removeSelector: #history!SmallScheme removeSelector: #initXlate!SmallScheme removeSelector: #rwtest!SmallScheme removeSelector: #status!SmallScheme removeSelector: #whyMe!SchemeEvalWindow removeSelector: #setSource:!!BlockClosureLastArgRest reorganize!('evaluating' value value: value:value: value:value:value: value:value:value:value: valueWithArguments: valueWithRestArgs:)('SchemeCore' asSchemeString)!