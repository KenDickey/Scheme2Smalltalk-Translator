'# This file is encoded in ASCII# line delimitor is CR.SmallSchemeSmallScheme code for Squeak 3.0Translated from file /usr/local/src/Squeak/ProtoScheme/scm/numbers.scm'!!SmallScheme class methodsFor: 'initialization'!initNumbers SmallScheme define:  #'nilX3F'    "nil?"  as: (        [ :obj |  ( obj == nil)] ) . SmallScheme define:  #'numberX3F'    "number?"  as: (        [ :obj |  ( obj isKindOf: Number)] ) . SmallScheme define:  #'complexX3F'    "complex?"  as: (        [ :obj |  [ :temp1 |                 ((( temp1) == false) not)                   	ifTrue: [ temp1]                   	ifFalse: [ [ :temp2 |                         ((( temp2) == false) not)                           	ifTrue: [ temp2]                           	ifFalse: [ [ :temp3 |                                 ((( temp3) == false) not)                                   	ifTrue: [ temp3]                                   	ifFalse: [((SmallScheme globalRef:  #'integerX3F')                                        value: ( obj))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'rationalX3F')                                    value: ( obj))). }].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'realX3F')                            value: ( obj))). }].           ] valueWithArguments: {( ( obj isKindOf: Complex)). }] ) . SmallScheme define:  #'realX3F'    "real?"  as: (        [ :obj |  [ :temp4 |                 ((( temp4) == false) not)                   	ifTrue: [ temp4]                   	ifFalse: [ [ :temp5 |                         ((( temp5) == false) not)                           	ifTrue: [ temp5]                           	ifFalse: [((SmallScheme globalRef:  #'integerX3F')                                value: ( obj))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'rationalX3F')                            value: ( obj))). }].           ] valueWithArguments: {( ( obj isKindOf: Float)). }] ) . SmallScheme define:  #'rationalX3F'    "rational?"  as: (        [ :obj |  [ :temp6 |                 ((( temp6) == false) not)                   	ifTrue: [ temp6]                   	ifFalse: [((SmallScheme globalRef:  #'integerX3F')                        value: ( obj))].           ] valueWithArguments: {( ( obj isKindOf: Fraction)). }] ) . SmallScheme define:  #'integerX3F'    "integer?"  as: (        [ :obj |  ( obj isKindOf: Integer)] ) . SmallScheme define:  #'exactX3F'    "exact?"  as: (        [ :n |  [ :temp7 |                 ((( temp7) == false) not)                   	ifTrue: [ temp7]                   	ifFalse: [((SmallScheme globalRef:  #'rationalX3F')                        value: ( n))].           ] valueWithArguments: {(((SmallScheme globalRef:  #'integerX3F')                    value: ( n))). }] ) . SmallScheme define:  #'inexactX3F'    "inexact?"  as: (        [ :n | ((SmallScheme globalRef:  #'not')                value: (((SmallScheme globalRef:  #'exactX3F')                value: ( n))))] ) . SmallScheme define:  #'reduce'  as: (        [ :op :seed :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ seed]               	ifFalse: [((SmallScheme globalRef:  #'reduce')                    value: ( op) value: ((op value: ( seed) value: (((SmallScheme globalRef:  #'car')                    value: ( list))))) value: (((SmallScheme globalRef:  #'cdr')                    value: ( list))))]] ) . SmallScheme define:  #'naryX2Dand'    "nary-and"  as: (        [ :op :seed :list |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( list))) == false) not)               	ifTrue: [ true]               	ifFalse: [ ((((op value: ( seed) value: (((SmallScheme globalRef:  #'car')                        value: ( list))))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'naryX2Dand')                        value: ( op) value: (((SmallScheme globalRef:  #'car')                        value: ( list))) value: (((SmallScheme globalRef:  #'cdr')                        value: ( list))))]                   	ifFalse: [ false]]] ) . SmallScheme define:  #'X3D'    "="  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 = x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3C'    "<"  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 < x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3E'    ">"  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 > x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3CX3D'    "<="  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 <= x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X3EX3D'    ">="  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'naryX2Dand')                value: (           [ :x1 :x2 |  ( x1 >= x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'zeroX3F'    "zero?"  as: (        [ :z |  ( z = 00)] ) . SmallScheme define:  #'positiveX3F'    "positive?"  as: (        [ :x |  ( x > 00)] ) . SmallScheme define:  #'negativeX3F'    "negative?"  as: (        [ :x |  ( x < 00)] ) . SmallScheme define:  #'oddX3F'    "odd?"  as: (        [ :n |  ( n odd)] ) . SmallScheme define:  #'evenX3F'    "even?"  as: (        [ :n |  ( n even)] ) . SmallScheme define:  #'max'  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 max: x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'min'  as: (        [ :x :others |            others := others asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 min: x2)]) value: ( x) value: ( others))] withLastArgRest  ) . SmallScheme define:  #'X2B'    "+"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 + x2)]) value: ( 00) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'X2A'    "*"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'reduce')                value: (           [ :x1 :x2 |  ( x1 * x2)]) value: ( 1) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'uncommunitiveX2Dreduce'    "uncommunitive-reduce"  as: (        [ :op :seed :things |  [ :key8 |                 (((((SmallScheme globalRef:  #'memv')                        value: ( key8) value: ( ({ 00. } asRest)))) == false) not)                   	ifTrue: [ seed]                   	ifFalse: [ [ :key9 |                         (((((SmallScheme globalRef:  #'memv')                                value: ( key9) value: ( ({ 1. } asRest)))) == false) not)                           	ifTrue: [(op value: ( seed) value: (((SmallScheme globalRef:  #'car')                                value: ( things))))]                           	ifFalse: [ [ :key10 |                                 (((((SmallScheme globalRef:  #'memv')                                        value: ( key10) value: ( ({ 2. } asRest)))) == false) not)                                   	ifTrue: [(op value: (((SmallScheme globalRef:  #'car')                                        value: ( things))) value: (((SmallScheme globalRef:  #'cadr')                                        value: ( things))))]                                   	ifFalse: [ [                                      key10.                                     ((SmallScheme globalRef:  #'reduce')                                          value: ( op) value: ((op value: (((SmallScheme globalRef:  #'car')                                          value: ( things))) value: (((SmallScheme globalRef:  #'cadr')                                          value: ( things))))) value: (((SmallScheme globalRef:  #'cddr')                                          value: ( things)))).                                    ] value].                           ] valueWithArguments: {( key9). }].                   ] valueWithArguments: {( key8). }].           ] valueWithArguments: {(((SmallScheme globalRef:  #'length')                    value: ( things))). }] ) . SmallScheme define:  #'X2D'    "-"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :x1 :x2 |  ( x1 - x2)]) value: ( 00) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'X2F'    "/"  as: (        [ :things |            things := things asRest.           ((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :x1 :x2 |  ( x1 / x2)]) value: ( 1) value: ( things))] withLastArgRest  ) . SmallScheme define:  #'abs'  as: (        [ :n |  ( n abs)] ) . SmallScheme define:  #'quotient'  as: (        [ :n1 :n2 |  ( n1 quo: n2)] ) . SmallScheme define:  #'remainder'  as: (        [ :n1 :n2 |  ( n1 rem: n2)] ) . SmallScheme define:  #'modulo'  as: (        [ :n1 :n2 |  [ :rem |                 (((((SmallScheme globalRef:  #'X3E')                        value: ( n2) value: ( 00))) == false) not)                   	ifTrue: [ (((((SmallScheme globalRef:  #'X3C')                            value: ( rem) value: ( 00))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'X2B')                            value: ( rem) value: ( n2))]                       	ifFalse: [ rem]]                   	ifFalse: [ (((((SmallScheme globalRef:  #'X3E')                            value: ( rem) value: ( 00))) == false) not)                       	ifTrue: [((SmallScheme globalRef:  #'X2B')                            value: ( rem) value: ( n2))]                       	ifFalse: [ rem]].           ] valueWithArguments: {(((SmallScheme globalRef:  #'remainder')                    value: ( n1) value: ( n2))). }] ) . SmallScheme define:  #'gcd'  as: (        [ :numbers |            numbers := numbers asRest.           ((SmallScheme globalRef:  #'abs')                value: (((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :n1 :n2 |  ( n1 gcd: n2)]) value: ( 00) value: ( numbers))))] withLastArgRest  ) . SmallScheme define:  #'lcm'  as: (        [ :numbers |            numbers := numbers asRest.           ((SmallScheme globalRef:  #'abs')                value: (((SmallScheme globalRef:  #'uncommunitiveX2Dreduce')                value: (           [ :n1 :n2 |  ( n1 lcm: n2)]) value: ( 1) value: ( numbers))))] withLastArgRest  ) . SmallScheme define:  #'factorial'  as: (        [ :n |  ( n factorial)] ) . SmallScheme define:  #'numerator'  as: (        [ :q |  ( q numerator)] ) . SmallScheme define:  #'denominator'  as: (        [ :q |  ( q denominator)] ) . SmallScheme define:  #'floor'  as: (        [ :x |  ( x floor)] ) . SmallScheme define:  #'ceiling'  as: (        [ :x |  ( x ceiling)] ) . SmallScheme define:  #'truncate'  as: (        [ :x |  ( x truncated)] ) . SmallScheme define:  #'round'  as: (        [ :x |  (((((SmallScheme globalRef:  #'X3D')                    value: ( 00.5) value: ( ( ( x fractionPart) abs)))) == false) not)               	ifTrue: [ [ :trunc |                     (((((SmallScheme globalRef:  #'evenX3F')                            value: ( trunc))) == false) not)                       	ifTrue: [ trunc]                       	ifFalse: [ (((((SmallScheme globalRef:  #'negativeX3F')                                value: ( x))) == false) not)                           	ifTrue: [((SmallScheme globalRef:  #'X2D')                                value: ( trunc) value: ( 1))]                           	ifFalse: [((SmallScheme globalRef:  #'X2B')                                value: ( trunc) value: ( 1))]].               ] valueWithArguments: {( ( x truncated)). }]               	ifFalse: [ (((((SmallScheme globalRef:  #'negativeX3F')                        value: ( x))) == false) not)                   	ifTrue: [ (((SmallScheme globalRef:  #'X2D')                        value: ( x) value: ( 00.5)) truncated)]                   	ifFalse: [ (((SmallScheme globalRef:  #'X2B')                        value: ( x) value: ( 00.5)) truncated)]]] ) . SmallScheme define:  #'exp'  as: (        [ :z |  ( z exp)] ) . SmallScheme define:  #'log'  as: (        [ :z |  ( z ln)] ) . SmallScheme define:  #'sin'  as: (        [ :z |  ( z sin)] ) . SmallScheme define:  #'cos'  as: (        [ :z |  ( z cos)] ) . SmallScheme define:  #'tan'  as: (        [ :z |  ( z tan)] ) . SmallScheme define:  #'asin'  as: (        [ :z |  ( z arcSin)] ) . SmallScheme define:  #'acos'  as: (        [ :z |  ( z arcCos)] ) . SmallScheme define:  #'atan'  as: (        [ :x |  ( x arcTan)] ) . SmallScheme define:  #'atan'  as: (        [ :y :x |  (((((SmallScheme globalRef:  #'nullX3F')                    value: ( x))) == false) not)               	ifTrue: [ ( y arcTan)]               	ifFalse: [ ( y atan2: x)]] ) . SmallScheme define:  #'sqrt'  as: (        [ :z |  ( z sqrt)] ) . SmallScheme define:  #'expt'  as: (        [ :z1 :z2 |  (((((SmallScheme globalRef:  #'integerX3F')                    value: ( z2))) == false) not)               	ifTrue: [ ( z1 raisedToInteger: z2)]               	ifFalse: [ ( z1 raisedTo: z2)]] ) . SmallScheme define:  #'makeX2Drectangular'    "make-rectangular"  as: (        [ :x1 :x2 |  ( Complex real: x1 imaginary: x2)] ) . SmallScheme define:  #'makeX2Dpolar'    "make-polar"  as: (        [ :x3 :x4 |  ( Complex magnitude: (SmallScheme globalRef:  #'x1')                angle: (SmallScheme globalRef:  #'x2')               )] ) . SmallScheme define:  #'realX2Dpart'    "real-part"  as: (        [ :z |  ( z real)] ) . SmallScheme define:  #'imagX2Dpart'    "imag-part"  as: (        [ :z |  ( z imaginary)] ) . SmallScheme define:  #'magnitude'  as: (        [ :z |  ( z magnitude)] ) . SmallScheme define:  #'angle'  as: (        [ :z |  ( z angle)] ) . SmallScheme define:  #'degreesX2DX3Eradians'    "degrees->radians"  as: (        [ :d |  ( d degreesToRadians)] ) . SmallScheme define:  #'radiansX2DX3Edegrees'    "radians->degrees"  as: (        [ :r |  ( r radiansToDegrees)] ) . SmallScheme define:  #'exactX2DX3Einexact'    "exact->inexact"  as: (        [ :z | ((SmallScheme globalRef:  #'X2B')                value: ( z) value: ( 0.0))] ) . SmallScheme define:  #'inexactX2DX3Eexact'    "inexact->exact"  as: (        [ :z | ((SmallScheme globalRef:  #'round')                value: ( z))] ) . SmallScheme define:  #'numberX2DX3Estring'    "number->string"  as: (        [ :z :optionalX2Dradix |            optionalX2Dradix := optionalX2Dradix asRest.                      [ :radix |              [ :stX2Dstring |                 [ :key13 |                     (((((SmallScheme globalRef:  #'memv')                            value: ( key13) value: ( ({ 2.  8. } asRest)))) == false) not)                       	ifTrue: [ ( stX2Dstring copyFrom: 3 to: ( stX2Dstring size))]                       	ifFalse: [ [ :key14 |                             (((((SmallScheme globalRef:  #'memv')                                    value: ( key14) value: ( ({ 10. } asRest)))) == false) not)                               	ifTrue: [ stX2Dstring]                               	ifFalse: [ [ :key15 |                                     (((((SmallScheme globalRef:  #'memv')                                            value: ( key15) value: ( ({ 16. } asRest)))) == false) not)                                       	ifTrue: [ ( stX2Dstring copyFrom: 4 to: ( stX2Dstring size))]                                       	ifFalse: [ key15].                               ] valueWithArguments: {( key14). }].                       ] valueWithArguments: {( key13). }].               ] valueWithArguments: {( radix). }             ] value: ( [ :key11 |                   (((((SmallScheme globalRef:  #'memv')                          value: ( key11) value: ( ({ 2.  8.  16. } asRest)))) == false) not)                     	ifTrue: [ ( z radix: radix)]                     	ifFalse: [ [ :key12 |                           (((((SmallScheme globalRef:  #'memv')                                  value: ( key12) value: ( ({ 10. } asRest)))) == false) not)                             	ifTrue: [ ( z asSchemeString)]                             	ifFalse: [ [                                key12.                               ((SmallScheme globalRef:  #'error')                                    value: ( 'Radix must be 2 8 10 or 16') value: ( radix)).                              ] value].                     ] valueWithArguments: {( key11). }].             ] valueWithArguments: {( radix). })           ] value: ( (((((SmallScheme globalRef:  #'nullX3F')                    value: ( optionalX2Dradix))) == false) not)               	ifTrue: [ 10]               	ifFalse: [((SmallScheme globalRef:  #'car')                    value: ( optionalX2Dradix))])] withLastArgRest  ) .! !!