'# This file is encoded in ASCII# line delimitor is CR.SmallSchemeSmallScheme code for Squeak 3.0Translated from file /usr/local/src/Squeak/ProtoScheme/scm/io.scm'!!SmallScheme class methodsFor: 'initialization'!initIo SmallScheme define:  #'fullX2DpathnameX2Dfor'    "full-pathname-for"  as: (        [ :fileX2DnameX2Dstring |  ( ( FileDirectory forFileName: fileX2DnameX2Dstring) fullNameFor: fileX2DnameX2Dstring)] ) . SmallScheme define:  #'callX2DwithX2DinputX2Dfile'    "call-with-input-file"  as: (        [ :fileX2DnameX2Dstring :proc |  [ :inport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ (                   [(proc value: ( inport))] ensure:                   [ ( inport close)])].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: false)). }] ) . SmallScheme define:  #'callX2DwithX2DoutputX2Dfile'    "call-with-output-file"  as: (        [ :fileX2DnameX2Dstring :proc |  [ :outport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( outport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ (                   [(proc value: ( outport))] ensure:                   [ ( outport close)])].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: true)). }] ) . SmallScheme define:  #'inputX2DportX3F'    "input-port?"  as: (        [ :obj |  [ :temp23 |                 ((( temp23) == false) not)                   	ifTrue: [ temp23]                   	ifFalse: [ ( obj isKindOf: ReadWriteStream)].           ] valueWithArguments: {( ( obj isKindOf: ReadStream)). }] ) . SmallScheme define:  #'outputX2DportX3F'    "output-port?"  as: (        [ :obj |  [ :temp24 |                 ((( temp24) == false) not)                   	ifTrue: [ temp24]                   	ifFalse: [ ( obj isKindOf: ReadWriteStream)].           ] valueWithArguments: {( ( obj isKindOf: WriteStream)). }] ) . SmallScheme define:  #'portX3F'    "port?"  as: (        [ :obj |  ( obj isKindOf: Stream)] ) . SmallScheme dynamicDefine: #X25X2AcurrentX2DinputX2DportX2AX25  as:  nil. SmallScheme dynamicDefine: #X25X2AcurrentX2DoutputX2DportX2AX25  as:  Transcript. SmallScheme define:  #'currentX2DinputX2Dport'    "current-input-port"  as: (        [(SmallScheme dynamicRef: #X25X2AcurrentX2DinputX2DportX2AX25 withDefault:            [ nil])] ) . SmallScheme define:  #'currentX2DoutputX2Dport'    "current-output-port"  as: (        [(SmallScheme dynamicRef: #X25X2AcurrentX2DoutputX2DportX2AX25 withDefault:            [ Transcript])] ) . SmallScheme define:  #'withX2DinputX2DfromX2Dfile'    "with-input-from-file"  as: (        [ :fileX2DnameX2Dstring :thunk |  [ :inport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ [                     SmallScheme dynamicPush: #X25X2AcurrentX2DinputX2DportX2AX25                                as:  inport.                      ( thunk ensure:                     [ ( inport close)]).                   ] ensure: [                     SmallScheme dynamicPop: #X25X2AcurrentX2DinputX2DportX2AX25.].].           ] valueWithArguments: {(((SmallScheme globalRef:  #'openX2DinputX2Dfile')                    value: ( fileX2DnameX2Dstring))). }] ) . SmallScheme define:  #'withX2DoutputX2DtoX2Dfile'    "with-output-to-file"  as: (        [ :fileX2DnameX2Dstring :thunk |  [ :outport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( outport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ [                     SmallScheme dynamicPush: #X25X2AcurrentX2DoutputX2DportX2AX25                                as:  outport.                      ( thunk ensure:                     [ ( outport close)]).                   ] ensure: [                     SmallScheme dynamicPop: #X25X2AcurrentX2DoutputX2DportX2AX25.].].           ] valueWithArguments: {(((SmallScheme globalRef:  #'openX2DoutputX2Dfile')                    value: ( fileX2DnameX2Dstring))). }] ) . SmallScheme define:  #'openX2DinputX2Dfile'    "open-input-file"  as: (        [ :fileX2DnameX2Dstring |  [ :inport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ inport].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: false)). }] ) . SmallScheme define:  #'openX2DoutputX2Dfile'    "open-output-file"  as: (        [ :fileX2DnameX2Dstring |  [ :outport |                 (((((SmallScheme globalRef:  #'nullX3F')                        value: ( outport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'error')                        value: ( 'Could not open file') value: ( fileX2DnameX2Dstring))]                   	ifFalse: [ outport].           ] valueWithArguments: {( ( (StandardFileStream new) open:((SmallScheme globalRef:  #'fullX2DpathnameX2Dfor')                    value: ( fileX2DnameX2Dstring)) forWrite: true)). }] ) . SmallScheme define:  #'closeX2DinputX2Dport'    "close-input-port"  as: (        [ :port |  ( port close)] ) . SmallScheme define:  #'closeX2DoutputX2Dport'    "close-output-port"  as: (        [ :port |  ( port close)] ) . SmallScheme define:  #'theX2DeofX2Dobject'    "the-eof-object"  as: (  'EOF' ) . SmallScheme define:  #'readX2Dchar'    "read-char"  as: (        [ :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :inport |                 ((( ( inport atEnd)) == false) not)                   	ifTrue: [ (SmallScheme globalRef:  #'theX2DeofX2Dobject')                       ]                   	ifFalse: [ ( inport next)].           ] valueWithArguments: {( ((( [ :temp25 |                         ((( temp25) == false) not)                           	ifTrue: [ temp25]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'inputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'peekX2Dchar'    "peek-char"  as: (        [ :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :inport |                 ((( ( inport atEnd)) == false) not)                   	ifTrue: [ (SmallScheme globalRef:  #'theX2DeofX2Dobject')                       ]                   	ifFalse: [ ( inport peek)].           ] valueWithArguments: {( ((( [ :temp26 |                         ((( temp26) == false) not)                           	ifTrue: [ temp26]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'inputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'eofX2DobjectX3F'    "eof-object?"  as: (        [ :obj |  ( obj == (SmallScheme globalRef:  #'theX2DeofX2Dobject')               )] ) . SmallScheme define:  #'charX2DreadyX3F'    "char-ready?"  as: (        [ :port |  true] ) . SmallScheme define:  #'write'  as: (        [ :obj :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                 ( outport nextPutAll: ( obj asSchemeObjString)).           ] valueWithArguments: {( ((( [ :temp27 |                         ((( temp27) == false) not)                           	ifTrue: [ temp27]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'display'  as: (        [ :obj :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                 ( outport nextPutAll: ( obj asSchemeString)).           ] valueWithArguments: {( ((( [ :temp28 |                         ((( temp28) == false) not)                           	ifTrue: [ temp28]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'newline'  as: (        [ :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                 ( outport nextPut: Character cr).           ] valueWithArguments: {( ((( [ :temp29 |                         ((( temp29) == false) not)                           	ifTrue: [ temp29]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'writeX2Dchar'    "write-char"  as: (        [ :char :optionalX2Dport |            optionalX2Dport := optionalX2Dport asRest.            [ :outport |                ((SmallScheme globalRef:  #'display')                    value: ( char) value: ( outport)).           ] valueWithArguments: {( ((( [ :temp30 |                         ((( temp30) == false) not)                           	ifTrue: [ temp30]                           	ifFalse: [((SmallScheme globalRef:  #'not')                                value: (((SmallScheme globalRef:  #'outputX2DportX3F')                                value: (((SmallScheme globalRef:  #'car')                                value: ( optionalX2Dport))))))].                   ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                            value: ( optionalX2Dport))). }) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DoutputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( optionalX2Dport))]). }] withLastArgRest  ) . SmallScheme define:  #'openX2DoutputX2Dstring'    "open-output-string"  as: (        [ ( WriteStream with: '')] ) . SmallScheme define:  #'getX2DoutputX2Dstring'    "get-output-string"  as: (        [ :outputX2DstringX2Dport |  (((((SmallScheme globalRef:  #'outputX2DportX3F')                    value: ( outputX2DstringX2Dport))) == false) not)               	ifTrue: [ ( outputX2DstringX2Dport contents)]               	ifFalse: [((SmallScheme globalRef:  #'error')                    value: ( 'Not an output-string-port') value: ( outputX2DstringX2Dport))]] ) . SmallScheme define:  #'openX2DinputX2Dstring'    "open-input-string"  as: (        [ :str |  ( ReadStream on: str from: 1 to: ( str size))] ) .! !