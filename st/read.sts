'# This file is encoded in ASCII# line delimitor is CR.SmallSchemeSmallScheme code for Squeak 3.4Translated from file /usr/local/src/Squeak/ProtoScheme/scm/read.scm'!!SmallScheme class methodsFor: 'initialization'!initRead SmallScheme define:  #'read'  as: (        [ :inputX2Dport |            inputX2Dport := inputX2Dport asRest.                       [ | whitespace delimiters specialX2DinitialX2Dchars specialX2Dinitials specialX2DsubsequentX2Dchars pecularX2Didentifier pecularX2Dinitials syntacticX2Dkeywords expressionX2Dkeywords characterX2DnamesX2Dalist tokenX2Dclasses abbreviationX2Dstarts radixX2Dchars exactnessX2Dchars letterX2Dchars digitX2Dchars numX2D2X2Dchars numX2D8X2Dchars numX2D10X2Dchars numX2D16X2Dchars exponentX2DmarkerX2Dchars signX2Dchars legalX2DnumberX2DcharsX2Dlist subsequents rparenX2Dmarker periodX2Dmarker stringX2DX3EcaseifiedX2Dsymbol read1 commentX2DcharX3F sharpX2DcharX3F stringX2DcharX3F lparenX2DcharX3F rparenX2DcharX3F specialX2DinitialX3F pecularX2DinitialX3F identifierX2DsubsequentX2DcharX3F abbrevX2DcharX3F legalX2DnumberX2DcharX3F consumeX2Dchar consumeX2Dcomment readX2DsharpX2Dthingie makeX2Dboolean readX2DsharpX2Dsym readX2Dcharacter readX2DidentifierX2Dstring readX2Dnumber readX2DnumberX2Dloop readX2Didentifier readX2Dabbreviation readX2Dstring readX2Dpecular periodX2DmarkerX3F rparenX2DmarkerX3F readX2Dlist readX2Dvector |                         whitespace := ( ({ $ . (Character cr). } asRest)).              delimiters := (((SmallScheme globalRef:  #'append')                  value: (((SmallScheme globalRef:  #'list')                               valueWithArguments: {  $(.  $).  $".  $;.})) value: ( whitespace))).              specialX2DinitialX2Dchars := ( '!!!!$%&/:*<=>?^_~').              specialX2Dinitials := (((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( specialX2DinitialX2Dchars))).              specialX2DsubsequentX2Dchars := ( '+-.@').              pecularX2Didentifier := ( ({ #'X2B'.  #'X2D'.  #'X2EX2EX2E'. } asRest)).              pecularX2Dinitials := ( ({ $+.  $-.  $.. } asRest)).              syntacticX2Dkeywords := ( ({ #'else'.  #'X3DX3E'.  #'define'.  #'unquote'.  #'unquoteX2Dsplicing'. } asRest)).              expressionX2Dkeywords := ( ({ #'quote'.  #'lambda'.  #'if'.  #'setX21'.  #'begin'.  #'cond'.  #'and'.  #'or'.  #'case'.  #'let'.  #'letX2A'.  #'letrec'.  #'do'.  #'delay'.  #'quasiquote'. } asRest)).              characterX2DnamesX2Dalist := (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'space') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 32))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'tab') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 9))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'return') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 13))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'newline') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 10))))) value: (((SmallScheme globalRef:  #'cons')                  value: (((SmallScheme globalRef:  #'cons')                  value: ( #'formfeed') value: (((SmallScheme globalRef:  #'integerX2DX3Echar')                  value: ( 12))))) value: ( nil))))))))))).              tokenX2Dclasses := ( ({ #'identifier'.  #'boolean'.  #'number'.  #'character'.  #'string'.  #'lparen'.  #'rparen'.  #'sharpX2Dlparen'.  #'quote'.  #'backquote'.  #'comma'.  #'commaX2Dsplice'.  #'period'. } asRest)).              abbreviationX2Dstarts := ( ({ $,.  $'.  $`. } asRest)).              radixX2Dchars := ( 'bodx').              exactnessX2Dchars := ( 'ie').              letterX2Dchars := ( 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ').              digitX2Dchars := ( '0123456789').              numX2D2X2Dchars := ( '01').              numX2D8X2Dchars := ( '01234567').              numX2D10X2Dchars := ( digitX2Dchars).              numX2D16X2Dchars := ( '01234567689abcdefABCDEF').              exponentX2DmarkerX2Dchars := ( 'esfdl').              signX2Dchars := ( '+-').              legalX2DnumberX2DcharsX2Dlist := (((SmallScheme globalRef:  #'append')                               valueWithArguments: { ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( signX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( numX2D16X2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( exponentX2DmarkerX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( radixX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( exactnessX2Dchars)). ((SmallScheme globalRef:  #'list')                               valueWithArguments: {  $..  $#.  $@.  $/.}).})).              subsequents := (((SmallScheme globalRef:  #'append')                               valueWithArguments: { ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( letterX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( digitX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( specialX2DinitialX2Dchars)). ((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( specialX2DsubsequentX2Dchars)).})).              rparenX2Dmarker := ( ')').              periodX2Dmarker := ( '.').              stringX2DX3EcaseifiedX2Dsymbol := ( [ :squashX2Dcase |                                   [ :str | ((SmallScheme globalRef:  #'stringX2DX3Esymbol')                          value: (((SmallScheme globalRef:  #'listX2DX3Estring')                          value: (((SmallScheme globalRef:  #'map')                          value: ( squashX2Dcase) value: (((SmallScheme globalRef:  #'stringX2DX3Elist')                          value: ( str))))))))].             ] valueWithArguments: {( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( $a) value: (((SmallScheme globalRef:  #'stringX2Dref')                          value: (((SmallScheme globalRef:  #'symbolX2DX3Estring')                          value: ( #'a'))) value: ( 00))))) == false) not)                     	ifTrue: [ (SmallScheme globalRef:  #'charX2Ddowncase')                         ]                     	ifFalse: [ (SmallScheme globalRef:  #'charX2Dupcase')                         ]). }).              read1 := (             [ :port |                   [ | loop |                      loop :=                      [ :next |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))) == false) not)                         	ifTrue: [ next]                         	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DwhitespaceX3F')                                  value: ( next))) == false) not)                             	ifTrue: [ [                               ((SmallScheme globalRef:  #'readX2Dchar')                                    value: ( port)).                               (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                                    value: ( port)))).                              ] value]                             	ifFalse: [ ((((commentX2DcharX3F value: ( next))) == false) not)                                 	ifTrue: [ [                                   (consumeX2Dcomment value: ( port)).                                   (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                                        value: ( port)))).                                  ] value]                                 	ifFalse: [ ((((sharpX2DcharX3F value: ( next))) == false) not)                                     	ifTrue: [(readX2DsharpX2Dthingie value: ( port))]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DnumericX3F')                                              value: ( next))) == false) not)                                         	ifTrue: [(readX2Dnumber value: ( port))]                                         	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DalphabeticX3F')                                                  value: ( next))) == false) not)                                             	ifTrue: [(readX2Didentifier value: ( port))]                                             	ifFalse: [ ((((stringX2DcharX3F value: ( next))) == false) not)                                                 	ifTrue: [(readX2Dstring value: ( port))]                                                 	ifFalse: [ ((((abbrevX2DcharX3F value: ( next))) == false) not)                                                     	ifTrue: [(readX2Dabbreviation value: ( port))]                                                     	ifFalse: [ ((((lparenX2DcharX3F value: ( next))) == false) not)                                                         	ifTrue: [(readX2Dlist value: ( port))]                                                         	ifFalse: [ ((((specialX2DinitialX3F value: ( next))) == false) not)                                                             	ifTrue: [(readX2Didentifier value: ( port))]                                                             	ifFalse: [ ((((pecularX2DinitialX3F value: ( next))) == false) not)                                                                 	ifTrue: [(readX2Dpecular value: ( port))]                                                                 	ifFalse: [ ((((rparenX2DcharX3F value: ( next))) == false) not)                                                                     	ifTrue: [ [                                                                       (consumeX2Dchar value: ( port)).                                                                        rparenX2Dmarker.                                                                      ] value]                                                                     	ifFalse: [((SmallScheme globalRef:  #'error')                                                                          value: ( 'read: unacceptable character with code:') value: (((SmallScheme globalRef:  #'charX2DX3Einteger')                                                                          value: ( next))))]]]]]]]]]]]]                 ].                 loop valueWithArguments: {                     ((SmallScheme globalRef:  #'peekX2Dchar')                          value: ( port)). } ] value]).              commentX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $;))]).              sharpX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $#))]).              stringX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $"))]).              lparenX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $())]).              rparenX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'eqX3F')                      value: ( c) value: ( $)))]).              specialX2DinitialX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( specialX2Dinitials))]).              pecularX2DinitialX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( pecularX2Dinitials))]).              identifierX2DsubsequentX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( subsequents))]).              abbrevX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( abbreviationX2Dstarts))]).              legalX2DnumberX2DcharX3F := (             [ :c | ((SmallScheme globalRef:  #'memv')                      value: ( c) value: ( legalX2DnumberX2DcharsX2Dlist))]).              consumeX2Dchar := (             [ :port |  (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                          value: (((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port))))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'error')                          value: ( 'Unexpected End Of File'))]]).              consumeX2Dcomment := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                       [ | loop |                        loop :=                        [ :next |                         (((((SmallScheme globalRef:  #'not')                                value: ( [ :temp31 |                                 ((( temp31) == false) not)                                   	ifTrue: [ temp31]                                   	ifFalse: [((SmallScheme globalRef:  #'charX2DnewlineX3F')                                        value: ( next))].                           ] valueWithArguments: {(((SmallScheme globalRef:  #'eofX2DobjectX3F')                                    value: ( next))). }))) == false) not)                           	ifTrue: [ [                             (consumeX2Dchar value: ( port)).                             (loop value: (((SmallScheme globalRef:  #'peekX2Dchar')                                  value: ( port)))).                            ] value]                           	ifFalse: [ #'done']                   ].                   loop valueWithArguments: {                       ((SmallScheme globalRef:  #'peekX2Dchar')                            value: ( port)). } ] value.                  ] value]).              readX2DsharpX2Dthingie := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                    [ :next |                         [ :key32 |                             (((((SmallScheme globalRef:  #'memv')                                    value: ( key32) value: ( ({ $t.  $f.  $T.  $F. } asRest)))) == false) not)                               	ifTrue: [(makeX2Dboolean value: ( port))]                               	ifFalse: [ [ :key33 |                                     (((((SmallScheme globalRef:  #'memv')                                            value: ( key33) value: ( ({ $e.  $i.  $o.  $b.  $d.  $x.  $E.  $I.  $O.  $B.  $D.  $X. } asRest)))) == false) not)                                       	ifTrue: [(readX2DnumberX2Dloop value: ( ({ $#. } asRest)) value: ( port))]                                       	ifFalse: [ [ :key34 |                                             (((((SmallScheme globalRef:  #'memv')                                                    value: ( key34) value: ( ({ $\. } asRest)))) == false) not)                                               	ifTrue: [(readX2Dcharacter value: ( port))]                                               	ifFalse: [ [ :key35 |                                                     (((((SmallScheme globalRef:  #'memv')                                                            value: ( key35) value: ( ({ $(. } asRest)))) == false) not)                                                       	ifTrue: [(readX2Dvector value: ( port))]                                                       	ifFalse: [ [ :key36 |                                                             (((((SmallScheme globalRef:  #'memv')                                                                    value: ( key36) value: ( ({ $'. } asRest)))) == false) not)                                                               	ifTrue: [(readX2DsharpX2Dsym value: ( port))]                                                               	ifFalse: [ [                                                                  key36.                                                                 ((SmallScheme globalRef:  #'error')                                                                      value: ( 'Unknown sharp syntax') value: ( next)).                                                                ] value].                                                       ] valueWithArguments: {( key35). }].                                               ] valueWithArguments: {( key34). }].                                       ] valueWithArguments: {( key33). }].                               ] valueWithArguments: {( key32). }].                       ] valueWithArguments: {( next). }.                   ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                            value: ( port))). }.                  ] value]).              makeX2Dboolean := (             [ :port |  [ :key37 |                       (((((SmallScheme globalRef:  #'memv')                              value: ( key37) value: ( ({ $t.  $T. } asRest)))) == false) not)                         	ifTrue: [ true]                         	ifFalse: [ [ :key38 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key38) value: ( ({ $f.  $F. } asRest)))) == false) not)                                 	ifTrue: [ false]                                 	ifFalse: [ [                                    key38.                                   ((SmallScheme globalRef:  #'error')                                        value: ( 'reading boolean: expected #t or #f here')).                                  ] value].                         ] valueWithArguments: {( key37). }].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port))). }]).              readX2DsharpX2Dsym := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                   ((SmallScheme globalRef:  #'cons')                        value: ( #'stringX2DX3Esymbol') value: (((SmallScheme globalRef:  #'cons')                        value: ((readX2DidentifierX2Dstring value: ( port))) value: ( nil)))).                  ] value]).              readX2Dcharacter := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                      [ :next |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'error')                              value: ( 'EOF parsing character while reading file'))]                         	ifFalse: [ (((((SmallScheme globalRef:  #'charX2DalphabeticX3F')                                  value: ( next))) == false) not)                             	ifTrue: [ [ :charX2DnameX2Dstring |                                   (((((SmallScheme globalRef:  #'X3D')                                          value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                          value: ( charX2DnameX2Dstring))))) == false) not)                                     	ifTrue: [((SmallScheme globalRef:  #'stringX2Dref')                                          value: ( charX2DnameX2Dstring) value: ( 00))]                                     	ifFalse: [ [ :result39 |                                           ((( result39) == false) not)                                             	ifTrue: [((                                             [ :bucket | ((SmallScheme globalRef:  #'cdr')                                                      value: ( bucket))]) value: ( result39))]                                             	ifFalse: [((SmallScheme globalRef:  #'error')                                                  value: ( 'read: invalid character name') value: ( charX2DnameX2Dstring))].                                     ] valueWithArguments: {(((SmallScheme globalRef:  #'assq')                                              value: ((stringX2DX3EcaseifiedX2Dsymbol value: ( charX2DnameX2Dstring))) value: ( characterX2DnamesX2Dalist))). }].                             ] valueWithArguments: {((readX2DidentifierX2Dstring value: ( port))). }]                             	ifFalse: [((SmallScheme globalRef:  #'readX2Dchar')                                  value: ( port))]]                   ] value: (((SmallScheme globalRef:  #'peekX2Dchar')                        value: ( port))).                  ] value]).              readX2DidentifierX2Dstring := (             [ :port |                   [ | loop |                      loop :=                      [ :chars |                       [ :next |                           (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                  value: ( next))) == false) not)                             	ifTrue: [((SmallScheme globalRef:  #'listX2DX3Estring')                                  value: (((SmallScheme globalRef:  #'reverse')                                  value: ( chars))))]                             	ifFalse: [ ((((identifierX2DsubsequentX2DcharX3F value: ( next))) == false) not)                                 	ifTrue: [(loop value: (((SmallScheme globalRef:  #'cons')                                      value: (((SmallScheme globalRef:  #'readX2Dchar')                                      value: ( port))) value: ( chars))))]                                 	ifFalse: [((SmallScheme globalRef:  #'listX2DX3Estring')                                      value: (((SmallScheme globalRef:  #'reverse')                                      value: ( chars))))]].                     ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                              value: ( port))). }                 ].                 loop valueWithArguments: {                     ((SmallScheme globalRef:  #'list')                          value: (((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port)))). } ] value]).              readX2Dnumber := (             [ :port | (readX2DnumberX2Dloop value: (((SmallScheme globalRef:  #'list')                      value: (((SmallScheme globalRef:  #'readX2Dchar')                      value: ( port))))) value: ( port))]).              readX2DnumberX2Dloop := (             [ :chars :port |  [ :next |                       (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                              value: ( next))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'stringX2DX3Enumber')                              value: (((SmallScheme globalRef:  #'listX2DX3Estring')                              value: (((SmallScheme globalRef:  #'reverse')                              value: ( chars))))))]                         	ifFalse: [ ((((legalX2DnumberX2DcharX3F value: ( next))) == false) not)                             	ifTrue: [(readX2DnumberX2Dloop value: (((SmallScheme globalRef:  #'cons')                                  value: (((SmallScheme globalRef:  #'readX2Dchar')                                  value: ( port))) value: ( chars))) value: ( port))]                             	ifFalse: [((SmallScheme globalRef:  #'stringX2DX3Enumber')                                  value: (((SmallScheme globalRef:  #'listX2DX3Estring')                                  value: (((SmallScheme globalRef:  #'reverse')                                  value: ( chars))))))]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                          value: ( port))). }]).              readX2Didentifier := (             [ :port | (stringX2DX3EcaseifiedX2Dsymbol value: ((readX2DidentifierX2Dstring value: ( port))))]).              readX2Dabbreviation := (             [ :port |  [ :key40 |                       (((((SmallScheme globalRef:  #'memv')                              value: ( key40) value: ( ({ $`. } asRest)))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'list')                              value: ( #'quasiquote') value: ((read1 value: ( port))))]                         	ifFalse: [ [ :key41 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key41) value: ( ({ $'. } asRest)))) == false) not)                                 	ifTrue: [((SmallScheme globalRef:  #'list')                                      value: ( #'quote') value: ((read1 value: ( port))))]                                 	ifFalse: [ [ :key42 |                                       (((((SmallScheme globalRef:  #'memv')                                              value: ( key42) value: ( ({ $,. } asRest)))) == false) not)                                         	ifTrue: [ (((((SmallScheme globalRef:  #'eqX3F')                                                  value: ( $@) value: (((SmallScheme globalRef:  #'peekX2Dchar')                                                  value: ( port))))) == false) not)                                             	ifTrue: [ [                                               (consumeX2Dchar value: ( port)).                                               ((SmallScheme globalRef:  #'list')                                                    value: ( #'unquoteX2Dsplicing') value: ((read1 value: ( port)))).                                              ] value]                                             	ifFalse: [((SmallScheme globalRef:  #'list')                                                  value: ( #'unquote') value: ((read1 value: ( port))))]]                                         	ifFalse: [ [                                            key42.                                           ((SmallScheme globalRef:  #'error')                                                value: ( 'Assert failed in reading abbreviation')).                                          ] value].                                 ] valueWithArguments: {( key41). }].                         ] valueWithArguments: {( key40). }].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dchar')                          value: ( port))). }]).              readX2Dstring := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                       [ | loop |                        loop :=                        [ :chars |                         [ :next |                             (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                    value: ( next))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'error')                                    value: ( 'read: End Of File reading string'))]                               	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                        value: ( next) value: ( $"))) == false) not)                                   	ifTrue: [ [                                     (consumeX2Dchar value: ( port)).                                     ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( chars)))).                                    ] value]                                   	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                            value: ( next) value: ( $\))) == false) not)                                       	ifTrue: [ [                                         (consumeX2Dchar value: ( port)).                                          [ :following |                                               (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                                      value: ( following))) == false) not)                                                 	ifTrue: [((SmallScheme globalRef:  #'error')                                                      value: ( 'EOF in read-string'))]                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                          value: ( following) value: ( ({ $".  $\. } asRest)))) == false) not)                                                     	ifTrue: [(loop value: (((SmallScheme globalRef:  #'cons')                                                          value: (((SmallScheme globalRef:  #'readX2Dchar')                                                          value: ( port))) value: ( chars))))]                                                     	ifFalse: [((SmallScheme globalRef:  #'error')                                                          value: ( 'Illegal char following #\') value: ( following))]].                                         ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                                                  value: ( port))). }.                                        ] value]                                       	ifFalse: [(loop value: (((SmallScheme globalRef:  #'cons')                                            value: (((SmallScheme globalRef:  #'readX2Dchar')                                            value: ( port))) value: ( chars))))]]].                       ] valueWithArguments: {(((SmallScheme globalRef:  #'peekX2Dchar')                                value: ( port))). }                   ].                   loop valueWithArguments: {                        nil. } ] value.                  ] value]).              readX2Dpecular := (             [ :port |                  [ :char |                    [ :next |                       (((((SmallScheme globalRef:  #'memv')                              value: ( char) value: ( ({ $+.  $-. } asRest)))) == false) not)                         	ifTrue: [ ((((legalX2DnumberX2DcharX3F value: ( next))) == false) not)                             	ifTrue: [(readX2DnumberX2Dloop value: (((SmallScheme globalRef:  #'list')                                  value: ( char))) value: ( port))]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( char) value: ( $+))) == false) not)                                 	ifTrue: [ #'X2B']                                 	ifFalse: [ #'X2D']]]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( $.) value: ( char))) == false) not)                             	ifTrue: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( $.) value: ( next))) == false) not)                                 	ifTrue: [ [                                   (consumeX2Dchar value: ( port)).                                    (((((SmallScheme globalRef:  #'eqX3F')                                            value: ( $.) value: (((SmallScheme globalRef:  #'peekX2Dchar')                                            value: ( port))))) == false) not)                                       	ifTrue: [ [                                         (consumeX2Dchar value: ( port)).                                          #'X2EX2EX2E'.                                        ] value]                                       	ifFalse: [((SmallScheme globalRef:  #'error')                                            value: ( 'Illegal period literal'))].                                  ] value]                                 	ifFalse: [ periodX2Dmarker]]                             	ifFalse: [((SmallScheme globalRef:  #'error')                                  value: ( 'Assert failed in reading pecular identifier') value: ( char))]]                   ] value: (((SmallScheme globalRef:  #'peekX2Dchar')                        value: ( port)))                 ] value: (((SmallScheme globalRef:  #'readX2Dchar')                      value: ( port)))]).              periodX2DmarkerX3F := (             [ :thing | ((SmallScheme globalRef:  #'eqX3F')                      value: ( periodX2Dmarker) value: ( thing))]).              rparenX2DmarkerX3F := (             [ :thing | ((SmallScheme globalRef:  #'eqX3F')                      value: ( rparenX2Dmarker) value: ( thing))]).              readX2Dlist := (             [ :port |  [                   (consumeX2Dchar value: ( port)).                                       [ | loop |                        loop :=                        [ :result |                         [ :thing |                             (((((SmallScheme globalRef:  #'eofX2DobjectX3F')                                    value: ( thing))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'error')                                    value: ( 'unexpected end of file reading list'))]                               	ifFalse: [ ((((rparenX2DmarkerX3F value: ( thing))) == false) not)                                   	ifTrue: [((SmallScheme globalRef:  #'reverse')                                        value: ( result))]                                   	ifFalse: [ ((((periodX2DmarkerX3F value: ( thing))) == false) not)                                       	ifTrue: [ [ :next |                                             (((((SmallScheme globalRef:  #'memv')                                                    value: ( next) value: (((SmallScheme globalRef:  #'cons')                                                    value: ( periodX2Dmarker) value: (((SmallScheme globalRef:  #'cons')                                                    value: ( rparenX2Dmarker) value: ( nil))))))) == false) not)                                               	ifTrue: [((SmallScheme globalRef:  #'error')                                                    value: ( 'read: ill-formed list'))]                                               	ifFalse: [ [ :final |                                                     ((((rparenX2DmarkerX3F value: ( final))) == false) not)                                                       	ifTrue: [((SmallScheme globalRef:  #'setX2DlastX2Dpair')                                                            value: (((SmallScheme globalRef:  #'reverse')                                                            value: ( result))) value: ( next))]                                                       	ifFalse: [((SmallScheme globalRef:  #'error')                                                            value: ( 'read: ill-formed dotted list tail'))].                                               ] valueWithArguments: {((read1 value: ( port))). }].                                       ] valueWithArguments: {((read1 value: ( port))). }]                                       	ifFalse: [(loop value: (((SmallScheme globalRef:  #'cons')                                            value: ( thing) value: ( result))))]]].                       ] valueWithArguments: {((read1 value: ( port))). }                   ].                   loop valueWithArguments: {                        nil. } ] value.                  ] value]).              readX2Dvector := (             [ :port |  [ :list |                       (((((SmallScheme globalRef:  #'listX3F')                              value: ( list))) == false) not)                         	ifTrue: [((SmallScheme globalRef:  #'listX2DX3Evector')                              value: ( list))]                         	ifFalse: [((SmallScheme globalRef:  #'error')                              value: ( 'read: ill-formed vector'))].                 ] valueWithArguments: {((readX2Dlist value: ( port))). }]).               (read1 value: ( (((((SmallScheme globalRef:  #'nullX3F')                        value: ( inputX2Dport))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                        value)]                   	ifFalse: [((SmallScheme globalRef:  #'car')                        value: ( inputX2Dport))])).           ] value] withLastArgRest  ) .! !                               value: ( thing))) == false) not)                                 	ifTrue: [ [ :next |                                       (((((SmallScheme globalRef:  #'memv')                                              value: ( next) value: (((SmallScheme globalRef:  #'cons')                                              value: ( (SmallScheme globalRef:  #'periodX2Dmarker')                                             ) value: (((SmallScheme globalRef:  #'cons')                                              value: ( (SmallScheme globalRef:  #'rparenX2Dmarker')                                             ) value: ( nil))))))) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'error')                                              value: ( 'read: ill-formed list'))]                                         	ifFalse: [ [ :final |                                               (((((SmallScheme globalRef:  #'rparenX2DmarkerX3F')                                                      value: ( final))) == false) not)                                                 	ifTrue: [((SmallScheme globalRef:  #'setX2DlastX2Dpair')                                                      value: (((SmallScheme globalRef:  #'reverse')                                                      value: ( result))) value: ( next))]                                                 	ifFalse: [((SmallScheme globalRef:  #'error')                                                      value: ( 'read: ill-formed dotted list tail'))].                                         ] valueWithArguments: {(((SmallScheme globalRef:  #'read1')                                                  value: ( port))). }].                                 ] valueWithArguments: {(((SmallScheme globalRef:  #'read1')                                          value: ( port))). }]                                 	ifFalse: [(loop value: (((SmallScheme globalRef:  #'cons')                                      value: ( thing) value: ( result))))]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'read1')                          value: ( port))). }             ].             loop valueWithArguments: {                  nil. } ] value.            ] value] ) . SmallScheme define:  #'readX2Dvector'    "read-vector"  as: (        [ :port |  [ :list |                 (((((SmallScheme globalRef:  #'listX3F')                        value: ( list))) == false) not)                   	ifTrue: [((SmallScheme globalRef:  #'listX2DX3Evector')                        value: ( list))]                   	ifFalse: [((SmallScheme globalRef:  #'error')                        value: ( 'read: ill-formed vector'))].           ] valueWithArguments: {(((SmallScheme globalRef:  #'readX2Dlist')                    value: ( port))). }] ) . SmallScheme define:  #'read'  as: (        [ :inputX2Dport |            inputX2Dport := inputX2Dport asRest.           ((SmallScheme globalRef:  #'read1')                value: ( (((((SmallScheme globalRef:  #'nullX3F')                    value: ( inputX2Dport))) == false) not)               	ifTrue: [((SmallScheme globalRef:  #'currentX2DinputX2Dport')                    value)]               	ifFalse: [((SmallScheme globalRef:  #'car')                    value: ( inputX2Dport))]))] withLastArgRest  ) .! !