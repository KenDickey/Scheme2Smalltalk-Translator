'# This file is encoded in ASCII# line delimitor is CR.SmallSchemeSmallScheme code for Squeak 3.4Translated from file /usr/local/src/Squeak/ProtoScheme/scm/string2number.scm'!!SmallScheme class methodsFor: 'initialization'!initString2number SmallScheme define:  #'stringX2DX3Enumber'    "string->number"  as: (         [ | numX2D2X2Dchars numX2D8X2Dchars numX2D10X2Dchars numX2D16X2Dchars exponentX2DmarkerX2Dchars radixX2Dchars exactnessX2Dchars signX2Dchars radixX2Dtable charX2DX3Eradix stringX2Dupcase toX2DssX2Dint toX2DssX2Dfloat coerceX2DifX2Dneeded makeX2Dinteger makeX2Ddecimal makeX2Drational makeX2Dcomplex prefix integer rational decimal exponent complex |                 numX2D2X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '01'))).          numX2D8X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '01234567'))).          numX2D10X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '0123456789'))).          numX2D16X2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '0123456789abcdefABCDEF'))).          exponentX2DmarkerX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( 'esfdlESFDL'))).          radixX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( 'bodxBODX'))).          exactnessX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( 'ieIE'))).          signX2Dchars := (((SmallScheme globalRef:  #'stringX2DX3Elist')              value: ( '+-'))).          radixX2Dtable := ( ({ (Pair car:  $b cdr:  2).  (Pair car:  $o cdr:  8).  (Pair car:  $d cdr:  10).  (Pair car:  $x cdr:  16).  (Pair car:  $B cdr:  2).  (Pair car:  $O cdr:  8).  (Pair car:  $D cdr:  10).  (Pair car:  $X cdr:  16). } asRest)).          charX2DX3Eradix := (         [ :char |  [ :result43 |                   ((( result43) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'cdr')                          value: ( result43))]                     	ifFalse: [ false].             ] valueWithArguments: {(((SmallScheme globalRef:  #'assq')                      value: ( char) value: ( radixX2Dtable))). }]).          stringX2Dupcase := (         [ :str | ((SmallScheme globalRef:  #'listX2DX3Estring')                  value: (((SmallScheme globalRef:  #'map')                  value: ( (SmallScheme globalRef:  #'charX2Dupcase')                 ) value: (((SmallScheme globalRef:  #'stringX2DX3Elist')                  value: ( str))))))]).          toX2DssX2Dint := (         [ :intX2Dstr :radix | ((SmallScheme globalRef:  #'stringX2Dappend')                  value: ( [ :key44 |                   (((((SmallScheme globalRef:  #'memv')                          value: ( key44) value: ( ({ 2. } asRest)))) == false) not)                     	ifTrue: [ '2r']                     	ifFalse: [ [ :key45 |                           (((((SmallScheme globalRef:  #'memv')                                  value: ( key45) value: ( ({ 8. } asRest)))) == false) not)                             	ifTrue: [ '8r']                             	ifFalse: [ [ :key46 |                                   (((((SmallScheme globalRef:  #'memv')                                          value: ( key46) value: ( ({ 16. } asRest)))) == false) not)                                     	ifTrue: [ '16r']                                     	ifFalse: [ [                                        key46.                                        ''.                                      ] value].                             ] valueWithArguments: {( key45). }].                     ] valueWithArguments: {( key44). }].             ] valueWithArguments: {( radix). }) value: ((stringX2Dupcase value: ( intX2Dstr))))]).          toX2DssX2Dfloat := (         [ :signX2Dchar :intX2Dstr :fracX2Dstr :exptX2DsignX2Dchar :exptX2Dstr |              [ :int |                [ :frac |                  [ :sign |                    [ :exptX2Dsign |                      [ :expt |                         ((( (((((SmallScheme globalRef:  #'zeroX3F')                                    value: (((SmallScheme globalRef:  #'stringX2Dlength')                                    value: ( intX2Dstr))))) == false) not)                               	ifTrue: [((SmallScheme globalRef:  #'zeroX3F')                                    value: (((SmallScheme globalRef:  #'stringX2Dlength')                                    value: ( fracX2Dstr))))]                               	ifFalse: [ false]) == false) not)                           	ifTrue: [ false]                           	ifFalse: [((SmallScheme globalRef:  #'stringX2Dappend')                                                           valueWithArguments: {  sign.  int.  '.'.  frac.  expt.})]                     ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                              value: (((SmallScheme globalRef:  #'stringX2Dlength')                              value: ( exptX2Dstr))))) == false) not)                         	ifTrue: [ '']                         	ifFalse: [((SmallScheme globalRef:  #'stringX2Dappend')                              value: ( 'e') value: ( exptX2Dsign) value: ( exptX2Dstr))])                   ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                            value: ( exptX2DsignX2Dchar) value: ( $-))) == false) not)                       	ifTrue: [ '-']                       	ifFalse: [ ''])                 ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( signX2Dchar) value: ( $-))) == false) not)                     	ifTrue: [ '-']                     	ifFalse: [ ''])               ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                        value: (((SmallScheme globalRef:  #'stringX2Dlength')                        value: ( fracX2Dstr))))) == false) not)                   	ifTrue: [ '0']                   	ifFalse: [ fracX2Dstr])             ] value: ( (((((SmallScheme globalRef:  #'zeroX3F')                      value: (((SmallScheme globalRef:  #'stringX2Dlength')                      value: ( intX2Dstr))))) == false) not)                 	ifTrue: [ '0']                 	ifFalse: [ intX2Dstr])]).          coerceX2DifX2Dneeded := (         [ :num :exactX3F :makeX2DinexactX3F |  [ :key47 |                   (((((SmallScheme globalRef:  #'memv')                          value: ( key47) value: ( ({ $e. } asRest)))) == false) not)                     	ifTrue: [ ((( exactX3F) == false) not)                         	ifTrue: [ num]                         	ifFalse: [((SmallScheme globalRef:  #'inexactX2DX3Eexact')                              value: ( num))]]                     	ifFalse: [ [ :key48 |                           (((((SmallScheme globalRef:  #'memv')                                  value: ( key48) value: ( ({ $i. } asRest)))) == false) not)                             	ifTrue: [ ((( exactX3F) == false) not)                                 	ifTrue: [((SmallScheme globalRef:  #'exactX2DX3Einexact')                                      value: ( num))]                                 	ifFalse: [ num]]                             	ifFalse: [ [                                key48.                                num.                              ] value].                     ] valueWithArguments: {( key47). }].             ] valueWithArguments: {( makeX2DinexactX3F). }]).          makeX2Dinteger := (         [ :sign :str :radix :exactX3F :makeX2DinexactX3F |  [ :num |                  (coerceX2DifX2Dneeded value: ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( sign) value: ( $-))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'X2D')                          value: ( 00) value: ( num))]                     	ifFalse: [ num]) value: ( exactX3F) value: ( makeX2DinexactX3F)).             ] valueWithArguments: {( ((toX2DssX2Dint value: ( str) value: ( radix)) asNumber)). }]).          makeX2Ddecimal := (         [ :sign :intX2Dpart :fracX2Dpart :expX2Dsign :exponentX2Dpart :exactX3F :makeX2DinexactX3F |  [ :num |                  (coerceX2DifX2Dneeded value: ( num) value: ( exactX3F) value: ( makeX2DinexactX3F)).             ] valueWithArguments: {( ((toX2DssX2Dfloat                  valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign.  exponentX2Dpart.}) asNumber)). }]).          makeX2Drational := (         [ :sign :numerator :denominator :radix :exactX3F :makeX2DinexactX3F |              [ :numX2Dpart |                [ :denomX2Dpart |                  [ :num |                    (coerceX2DifX2Dneeded value: ( num) value: ( exactX3F) value: ( makeX2DinexactX3F))                 ] value: ( (((((SmallScheme globalRef:  #'eqX3F')                          value: ( sign) value: ( $-))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'X2D')                          value: (((SmallScheme globalRef:  #'X2F')                          value: ( numX2Dpart) value: ( denomX2Dpart))))]                     	ifFalse: [((SmallScheme globalRef:  #'X2F')                          value: ( numX2Dpart) value: ( denomX2Dpart))])               ] value: ( ((toX2DssX2Dint value: ( denominator) value: ( radix)) asNumber))             ] value: ( ((toX2DssX2Dint value: ( numerator) value: ( radix)) asNumber))]).          makeX2Dcomplex := (         [ :realX2Dpart :imaginativeX2Dpart :exactX3F :makeX2DinexactX3F | (coerceX2DifX2Dneeded value: ( ( Complex real: realX2Dpart imaginary: imaginativeX2Dpart)) value: ( exactX3F) value: ( makeX2DinexactX3F))]).          prefix := (         [ :str :idx :sign :radix :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: (((SmallScheme globalRef:  #'stringX2Dlength')                      value: ( str))))) == false) not)                 	ifTrue: [ false]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: ( char) value: ( numX2D16X2Dchars))) == false) not)                         	ifTrue: [ [ :key49 |                               (((((SmallScheme globalRef:  #'memv')                                      value: ( key49) value: ( ({ 10. } asRest)))) == false) not)                                 	ifTrue: [(integer                                  valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                      value: ( str)).  numX2D10X2Dchars.  sign.  10.  nil.  true.  makeX2DinexactX3F.})]                                 	ifFalse: [ [ :key50 |                                       (((((SmallScheme globalRef:  #'memv')                                              value: ( key50) value: ( ({ 2. } asRest)))) == false) not)                                         	ifTrue: [(integer                                          valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                              value: ( str)).  numX2D2X2Dchars.  sign.  2.  nil.  true.  makeX2DinexactX3F.})]                                         	ifFalse: [ [ :key51 |                                               (((((SmallScheme globalRef:  #'memv')                                                      value: ( key51) value: ( ({ 8. } asRest)))) == false) not)                                                 	ifTrue: [(integer                                                  valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                                      value: ( str)).  numX2D8X2Dchars.  sign.  8.  nil.  true.  makeX2DinexactX3F.})]                                                 	ifFalse: [ [ :key52 |                                                       (((((SmallScheme globalRef:  #'memv')                                                              value: ( key52) value: ( ({ 16. } asRest)))) == false) not)                                                         	ifTrue: [(integer                                                          valueWithArguments: {  str.  idx. ((SmallScheme globalRef:  #'stringX2Dlength')                                                              value: ( str)).  numX2D16X2Dchars.  sign.  16.  nil.  true.  makeX2DinexactX3F.})]                                                         	ifFalse: [ [                                                            key52.                                                            false.                                                          ] value].                                                 ] valueWithArguments: {( key51). }].                                         ] valueWithArguments: {( key50). }].                                 ] valueWithArguments: {( key49). }].                         ] valueWithArguments: {( radix). }]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( char) value: ( $.))) == false) not)                             	ifTrue: [(decimal                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                  value: ( 1) value: ( idx)). ((SmallScheme globalRef:  #'stringX2Dlength')                                  value: ( str)).  $+.  '0'.  nil.  true.  makeX2DinexactX3F.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                      value: ( char) value: ( signX2Dchars))) == false) not)                                 	ifTrue: [(prefix                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( 1) value: ( idx)).  char.  radix.  makeX2DinexactX3F.})]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: ( char) value: ( $#))) == false) not)                                     	ifTrue: [ [ :char2 |                                           (((((SmallScheme globalRef:  #'memv')                                                  value: ( char2) value: ( radixX2Dchars))) == false) not)                                             	ifTrue: [(prefix                                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                  value: ( 2) value: ( idx)).  sign. (charX2DX3Eradix value: ( char2)).  makeX2DinexactX3F.})]                                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                      value: ( char2) value: ( exactnessX2Dchars))) == false) not)                                                 	ifTrue: [(prefix                                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                      value: ( 2) value: ( idx)).  sign.  radix.  char2.})]                                                 	ifFalse: [ false]].                                     ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                                              value: ( str) value: (((SmallScheme globalRef:  #'X2B')                                              value: ( 1) value: ( idx))))). }]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                              value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                              value: ( char))) value: ( $i))) == false) not)                                         	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                  value: (((SmallScheme globalRef:  #'X2B')                                                  value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                  value: ( str))))) == false) not)                                             	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                      value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                      value: ( str))))) == false) not)                                                 	ifTrue: [ false]                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                          value: ( sign))) == false) not)                                                     	ifTrue: [ false]                                                     	ifFalse: [(makeX2Dcomplex                                                      valueWithArguments: {  00.  00.  (SmallScheme globalRef:  #'exactX3F')                                                         .  makeX2DinexactX3F.})]]]                                             	ifFalse: [ false]]                                         	ifFalse: [ false]]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          integer := (         [ :str :idx :len :legalX2Dchars :sign :radix :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [(makeX2Dinteger                  valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                      value: (((SmallScheme globalRef:  #'reverse')                      value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.})]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: (((SmallScheme globalRef:  #'stringX2Dref')                              value: ( str) value: ( idx))) value: ( legalX2Dchars))) == false) not)                         	ifTrue: [(integer                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( char) value: ( $#))) == false) not)                             	ifTrue: [(integer                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                  value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'cons')                                  value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( char) value: ( $.))) == false) not)                                 	ifTrue: [ ((( ((( radix) == false) not)                                         	ifTrue: [((SmallScheme globalRef:  #'X3D')                                              value: ( radix) value: ( 10))]                                         	ifFalse: [ false]) == false) not)                                     	ifTrue: [(decimal                                      valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                          value: ( 1) value: ( idx)).  len.  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( digits)))).  nil.  exactX3F.  makeX2DinexactX3F.})]                                     	ifFalse: [ false]]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: ( char) value: ( $/))) == false) not)                                     	ifTrue: [(rational                                      valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                          value: ( 1) value: ( idx)).  len.  legalX2Dchars.  sign.  radix. ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( digits)))).  nil.  exactX3F.  makeX2DinexactX3F.})]                                     	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                              value: ( char) value: ( signX2Dchars))) == false) not)                                         	ifTrue: [ (((((SmallScheme globalRef:  #'nullX3F')                                                  value: ( digits))) == false) not)                                             	ifTrue: [(complex                                              valueWithArguments: {  00.  str.  idx.  radix.})]                                             	ifFalse: [(complex                                              valueWithArguments: { (makeX2Dinteger                                              valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                  value: (((SmallScheme globalRef:  #'reverse')                                                  value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  radix.})]]                                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                                  value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                                  value: ( char))) value: ( $i))) == false) not)                                             	ifTrue: [ (((((SmallScheme globalRef:  #'not')                                                      value: (((SmallScheme globalRef:  #'X3D')                                                      value: (((SmallScheme globalRef:  #'X2B')                                                      value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                      value: ( str))))))) == false) not)                                                 	ifTrue: [ false]                                                 	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                                          value: ( digits))) == false) not)                                                     	ifTrue: [(makeX2Dcomplex                                                      valueWithArguments: {  00.  00.  exactX3F.  makeX2DinexactX3F.})]                                                     	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                              value: ( sign))) == false) not)                                                         	ifTrue: [ false]                                                         	ifFalse: [(makeX2Dcomplex                                                          valueWithArguments: {  00. (makeX2Dinteger                                                          valueWithArguments: {  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                              value: (((SmallScheme globalRef:  #'reverse')                                                              value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]]]                                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                                      value: ( char) value: ( exponentX2DmarkerX2Dchars))) == false) not)                                                 	ifTrue: [ ((( ((( radix) == false) not)                                                         	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                                                                  value: ( radix) value: ( 10))) == false) not)                                                             	ifTrue: [((SmallScheme globalRef:  #'X3E')                                                                  value: (((SmallScheme globalRef:  #'length')                                                                  value: ( digits))) value: ( 00))]                                                             	ifFalse: [ false]]                                                         	ifFalse: [ false]) == false) not)                                                     	ifTrue: [(exponent                                                      valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                                          value: ( 1) value: ( idx)).  len.  sign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                          value: (((SmallScheme globalRef:  #'reverse')                                                          value: ( digits)))).  '0'.  nil.  $+.  exactX3F.  makeX2DinexactX3F.})]                                                     	ifFalse: [ false]]                                                 	ifFalse: [ false]]]]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          rational := (         [ :str :idx :len :legalX2Dchars :sign :radix :numerator :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [(makeX2Drational                  valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                      value: (((SmallScheme globalRef:  #'reverse')                      value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.})]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: (((SmallScheme globalRef:  #'stringX2Dref')                              value: ( str) value: ( idx))) value: ( legalX2Dchars))) == false) not)                         	ifTrue: [(rational                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix.  numerator. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                  value: ( char) value: ( signX2Dchars))) == false) not)                             	ifTrue: [(complex                              valueWithArguments: { (makeX2Drational                              valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                                  value: (((SmallScheme globalRef:  #'reverse')                                  value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  radix.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: ( char) value: ( $#))) == false) not)                                 	ifTrue: [(rational                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( idx) value: ( 1)).  len.  legalX2Dchars.  sign.  radix.  numerator. ((SmallScheme globalRef:  #'cons')                                      value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                          value: ( char))) value: ( $i))) == false) not)                                     	ifTrue: [ (((((SmallScheme globalRef:  #'not')                                              value: (((SmallScheme globalRef:  #'X3D')                                              value: (((SmallScheme globalRef:  #'X2B')                                              value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                              value: ( str))))))) == false) not)                                         	ifTrue: [ false]                                         	ifFalse: [ (((((SmallScheme globalRef:  #'nullX3F')                                                  value: ( digits))) == false) not)                                             	ifTrue: [ false]                                             	ifFalse: [ (((((SmallScheme globalRef:  #'not')                                                      value: ( sign))) == false) not)                                                 	ifTrue: [ false]                                                 	ifFalse: [(makeX2Dcomplex                                                  valueWithArguments: {  00. (makeX2Drational                                                  valueWithArguments: {  sign.  numerator. ((SmallScheme globalRef:  #'listX2DX3Estring')                                                      value: (((SmallScheme globalRef:  #'reverse')                                                      value: ( digits)))).  radix.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]]]                                     	ifFalse: [ false]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          decimal := (         [ :str :idx :len :sign :intX2Dpart :digits :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [ (((((SmallScheme globalRef:  #'X3D')                          value: ( 1) value: (((SmallScheme globalRef:  #'stringX2Dlength')                          value: ( str))))) == false) not)                     	ifTrue: [ false]                     	ifFalse: [(makeX2Ddecimal                      valueWithArguments: {  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                          value: (((SmallScheme globalRef:  #'reverse')                          value: ( digits)))).  $+.  '0'.  exactX3F.  makeX2DinexactX3F.})]]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: (((SmallScheme globalRef:  #'stringX2Dref')                              value: ( str) value: ( idx))) value: ( numX2D10X2Dchars))) == false) not)                         	ifTrue: [(decimal                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                  value: ( char) value: ( $#))) == false) not)                             	ifTrue: [(decimal                              valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                  value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'cons')                                  value: ( $0) value: ( digits)).  false.  makeX2DinexactX3F.})]                             	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                      value: ( char) value: ( exponentX2DmarkerX2Dchars))) == false) not)                                 	ifTrue: [(exponent                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( 1) value: ( idx)).  len.  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                                      value: (((SmallScheme globalRef:  #'reverse')                                      value: ( digits)))).  nil.  $+.  exactX3F.  makeX2DinexactX3F.})]                                 	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                          value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                          value: ( char))) value: ( $i))) == false) not)                                     	ifTrue: [ ((( ((( sign) == false) not)                                             	ifTrue: [((SmallScheme globalRef:  #'X3D')                                                  value: (((SmallScheme globalRef:  #'X2B')                                                  value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                  value: ( str))))]                                             	ifFalse: [ false]) == false) not)                                         	ifTrue: [(makeX2Dcomplex                                          valueWithArguments: {  00. (makeX2Ddecimal                                          valueWithArguments: {  sign.  intX2Dpart. ((SmallScheme globalRef:  #'listX2DX3Estring')                                              value: (((SmallScheme globalRef:  #'reverse')                                              value: ( digits)))).  $+.  '0'.  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]                                         	ifFalse: [ false]]                                     	ifFalse: [ false]]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          exponent := (         [ :str :idx :len :sign :intX2Dpart :fracX2Dpart :digits :expX2Dsign :exactX3F :makeX2DinexactX3F |  (((((SmallScheme globalRef:  #'X3EX3D')                      value: ( idx) value: ( len))) == false) not)                 	ifTrue: [(makeX2Ddecimal                  valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                      value: (((SmallScheme globalRef:  #'reverse')                      value: ( digits)))).  exactX3F.  makeX2DinexactX3F.})]                 	ifFalse: [ [ :char |                       (((((SmallScheme globalRef:  #'memv')                              value: ( char) value: ( numX2D10X2Dchars))) == false) not)                         	ifTrue: [(exponent                          valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                              value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart.  fracX2Dpart. ((SmallScheme globalRef:  #'cons')                              value: ( char) value: ( digits)).  expX2Dsign.  exactX3F.  makeX2DinexactX3F.})]                         	ifFalse: [ (((((SmallScheme globalRef:  #'memv')                                  value: ( char) value: ( signX2Dchars))) == false) not)                             	ifTrue: [ (((((SmallScheme globalRef:  #'nullX3F')                                      value: ( digits))) == false) not)                                 	ifTrue: [(exponent                                  valueWithArguments: {  str. ((SmallScheme globalRef:  #'X2B')                                      value: ( idx) value: ( 1)).  len.  sign.  intX2Dpart.  fracX2Dpart.  digits.  char.  exactX3F.  makeX2DinexactX3F.})]                                 	ifFalse: [(complex                                  valueWithArguments: { (makeX2Ddecimal                                  valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                      value: (((SmallScheme globalRef:  #'reverse')                                      value: ( digits)))).  exactX3F.  makeX2DinexactX3F.}).  str.  idx.  (SmallScheme globalRef:  #'radix')                                     .})]]                             	ifFalse: [ (((((SmallScheme globalRef:  #'eqX3F')                                      value: (((SmallScheme globalRef:  #'charX2Ddowncase')                                      value: ( char))) value: ( $i))) == false) not)                                 	ifTrue: [ ((( [ :temp53 |                                           ((( temp53) == false) not)                                             	ifTrue: [ temp53]                                             	ifFalse: [ [ :temp54 |                                                   ((( temp54) == false) not)                                                     	ifTrue: [ temp54]                                                     	ifFalse: [((SmallScheme globalRef:  #'not')                                                          value: (((SmallScheme globalRef:  #'X3D')                                                          value: (((SmallScheme globalRef:  #'X2B')                                                          value: ( 1) value: ( idx))) value: (((SmallScheme globalRef:  #'stringX2Dlength')                                                          value: ( str))))))].                                             ] valueWithArguments: {(((SmallScheme globalRef:  #'not')                                                      value: ( sign))). }].                                     ] valueWithArguments: {(((SmallScheme globalRef:  #'nullX3F')                                              value: ( digits))). }) == false) not)                                     	ifTrue: [ false]                                     	ifFalse: [(makeX2Dcomplex                                      valueWithArguments: {  00. (makeX2Ddecimal                                      valueWithArguments: {  sign.  intX2Dpart.  fracX2Dpart.  expX2Dsign. ((SmallScheme globalRef:  #'listX2DX3Estring')                                          value: (((SmallScheme globalRef:  #'reverse')                                          value: ( digits)))).  exactX3F.  makeX2DinexactX3F.}).  exactX3F.  makeX2DinexactX3F.})]]                                 	ifFalse: [ false]]].                 ] valueWithArguments: {(((SmallScheme globalRef:  #'stringX2Dref')                          value: ( str) value: ( idx))). }]]).          complex := (         [ :realX2Dpart :str :idx :radix |  [ :imaginitiveX2Dpart |                   ((( imaginitiveX2Dpart) == false) not)                     	ifTrue: [ ( realX2Dpart + imaginitiveX2Dpart)]                     	ifFalse: [ false].             ] valueWithArguments: {((prefix                  valueWithArguments: {  str.  idx.  $+.  radix.  false.})). }]).                      [ :str :radix |                radix := radix asRest.                [                  (((((SmallScheme globalRef:  #'not')                          value: (((SmallScheme globalRef:  #'stringX3F')                          value: ( str))))) == false) not)                     	ifTrue: [((SmallScheme globalRef:  #'error')                          value: ( 'Expected a string') value: ( str))].                  (((((SmallScheme globalRef:  #'X3C')                          value: (((SmallScheme globalRef:  #'stringX2Dlength')                          value: ( str))) value: ( 1))) == false) not)                     	ifTrue: [ false]                     	ifFalse: [(prefix                      valueWithArguments: {  str.  00.  false.  (((((SmallScheme globalRef:  #'nullX3F')                              value: ( radix))) == false) not)                         	ifTrue: [ 10]                         	ifFalse: [((SmallScheme globalRef:  #'car')                              value: ( radix))].  false.})].                ] value] withLastArgRest .       ] value ) .! !